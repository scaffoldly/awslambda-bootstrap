#!/usr/bin/env node
exports.id=495,exports.ids=[495],exports.modules={4993:(e,t,r)=>{"use strict";const n=r(5317),o=r(2014),i=r(3436);function s(e,t,r){const s=o(e,t,r),a=n.spawn(s.command,s.args,s.options);return i.hookChildProcess(a,s),a}e.exports=s,e.exports.spawn=s,e.exports.sync=function(e,t,r){const s=o(e,t,r),a=n.spawnSync(s.command,s.args,s.options);return a.error=a.error||i.verifyENOENTSync(a.status,s),a},e.exports._parse=o,e.exports._enoent=i},3436:e=>{"use strict";const t="win32"===process.platform;function r(e,t){return Object.assign(new Error(`${t} ${e.command} ENOENT`),{code:"ENOENT",errno:"ENOENT",syscall:`${t} ${e.command}`,path:e.command,spawnargs:e.args})}function n(e,n){return t&&1===e&&!n.file?r(n.original,"spawn"):null}e.exports={hookChildProcess:function(e,r){if(!t)return;const o=e.emit;e.emit=function(t,i){if("exit"===t){const t=n(i,r);if(t)return o.call(e,"error",t)}return o.apply(e,arguments)}},verifyENOENT:n,verifyENOENTSync:function(e,n){return t&&1===e&&!n.file?r(n.original,"spawnSync"):null},notFoundError:r}},2014:(e,t,r)=>{"use strict";const n=r(6928),o=r(9045),i=r(4483),s=r(9182),a="win32"===process.platform,l=/\.(?:com|exe)$/i,c=/node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;e.exports=function(e,t,r){t&&!Array.isArray(t)&&(r=t,t=null);const d={command:e,args:t=t?t.slice(0):[],options:r=Object.assign({},r),file:void 0,original:{command:e,args:t}};return r.shell?d:function(e){if(!a)return e;const t=function(e){e.file=o(e);const t=e.file&&s(e.file);return t?(e.args.unshift(e.file),e.command=t,o(e)):e.file}(e),r=!l.test(t);if(e.options.forceShell||r){const r=c.test(t);e.command=n.normalize(e.command),e.command=i.command(e.command),e.args=e.args.map((e=>i.argument(e,r)));const o=[e.command].concat(e.args).join(" ");e.args=["/d","/s","/c",`"${o}"`],e.command=process.env.comspec||"cmd.exe",e.options.windowsVerbatimArguments=!0}return e}(d)}},4483:e=>{"use strict";const t=/([()\][%!^"`<>&|;, *?])/g;e.exports.command=function(e){return e.replace(t,"^$1")},e.exports.argument=function(e,r){return e=(e=`"${e=(e=(e=`${e}`).replace(/(\\*)"/g,'$1$1\\"')).replace(/(\\*)$/,"$1$1")}"`).replace(t,"^$1"),r&&(e=e.replace(t,"^$1")),e}},9182:(e,t,r)=>{"use strict";const n=r(9896),o=r(1395);e.exports=function(e){const t=Buffer.alloc(150);let r;try{r=n.openSync(e,"r"),n.readSync(r,t,0,150,0),n.closeSync(r)}catch(e){}return o(t.toString())}},9045:(e,t,r)=>{"use strict";const n=r(6928),o=r(307),i=r(9376);function s(e,t){const r=e.options.env||process.env,s=process.cwd(),a=null!=e.options.cwd,l=a&&void 0!==process.chdir&&!process.chdir.disabled;if(l)try{process.chdir(e.options.cwd)}catch(e){}let c;try{c=o.sync(e.command,{path:r[i({env:r})],pathExt:t?n.delimiter:void 0})}catch(e){}finally{l&&process.chdir(s)}return c&&(c=n.resolve(a?e.options.cwd:"",c)),c}e.exports=function(e){return s(e)||s(e,!0)}},8311:(e,t,r)=>{var n;function o(e,t,r){if("function"==typeof t&&(r=t,t={}),!r){if("function"!=typeof Promise)throw new TypeError("callback not provided");return new Promise((function(r,n){o(e,t||{},(function(e,t){e?n(e):r(t)}))}))}n(e,t||{},(function(e,n){e&&("EACCES"===e.code||t&&t.ignoreErrors)&&(e=null,n=!1),r(e,n)}))}r(9896),n="win32"===process.platform||global.TESTING_WINDOWS?r(3730):r(2044),e.exports=o,o.sync=function(e,t){try{return n.sync(e,t||{})}catch(e){if(t&&t.ignoreErrors||"EACCES"===e.code)return!1;throw e}}},2044:(e,t,r)=>{e.exports=o,o.sync=function(e,t){return i(n.statSync(e),t)};var n=r(9896);function o(e,t,r){n.stat(e,(function(e,n){r(e,!e&&i(n,t))}))}function i(e,t){return e.isFile()&&function(e,t){var r=e.mode,n=e.uid,o=e.gid,i=void 0!==t.uid?t.uid:process.getuid&&process.getuid(),s=void 0!==t.gid?t.gid:process.getgid&&process.getgid(),a=parseInt("100",8),l=parseInt("010",8);return r&parseInt("001",8)||r&l&&o===s||r&a&&n===i||r&(a|l)&&0===i}(e,t)}},3730:(e,t,r)=>{e.exports=i,i.sync=function(e,t){return o(n.statSync(e),e,t)};var n=r(9896);function o(e,t,r){return!(!e.isSymbolicLink()&&!e.isFile())&&function(e,t){var r=void 0!==t.pathExt?t.pathExt:process.env.PATHEXT;if(!r)return!0;if(-1!==(r=r.split(";")).indexOf(""))return!0;for(var n=0;n<r.length;n++){var o=r[n].toLowerCase();if(o&&e.substr(-o.length).toLowerCase()===o)return!0}return!1}(t,r)}function i(e,t,r){n.stat(e,(function(n,i){r(n,!n&&o(i,e,t))}))}},307:(e,t,r)=>{const n="win32"===process.platform||"cygwin"===process.env.OSTYPE||"msys"===process.env.OSTYPE,o=r(6928),i=n?";":":",s=r(8311),a=e=>Object.assign(new Error(`not found: ${e}`),{code:"ENOENT"}),l=(e,t)=>{const r=t.colon||i,o=e.match(/\//)||n&&e.match(/\\/)?[""]:[...n?[process.cwd()]:[],...(t.path||process.env.PATH||"").split(r)],s=n?t.pathExt||process.env.PATHEXT||".EXE;.CMD;.BAT;.COM":"",a=n?s.split(r):[""];return n&&-1!==e.indexOf(".")&&""!==a[0]&&a.unshift(""),{pathEnv:o,pathExt:a,pathExtExe:s}},c=(e,t,r)=>{"function"==typeof t&&(r=t,t={}),t||(t={});const{pathEnv:n,pathExt:i,pathExtExe:c}=l(e,t),d=[],u=r=>new Promise(((i,s)=>{if(r===n.length)return t.all&&d.length?i(d):s(a(e));const l=n[r],c=/^".*"$/.test(l)?l.slice(1,-1):l,u=o.join(c,e),f=!c&&/^\.[\\\/]/.test(e)?e.slice(0,2)+u:u;i(p(f,r,0))})),p=(e,r,n)=>new Promise(((o,a)=>{if(n===i.length)return o(u(r+1));const l=i[n];s(e+l,{pathExt:c},((i,s)=>{if(!i&&s){if(!t.all)return o(e+l);d.push(e+l)}return o(p(e,r,n+1))}))}));return r?u(0).then((e=>r(null,e)),r):u(0)};e.exports=c,c.sync=(e,t)=>{t=t||{};const{pathEnv:r,pathExt:n,pathExtExe:i}=l(e,t),c=[];for(let a=0;a<r.length;a++){const l=r[a],d=/^".*"$/.test(l)?l.slice(1,-1):l,u=o.join(d,e),p=!d&&/^\.[\\\/]/.test(e)?e.slice(0,2)+u:u;for(let e=0;e<n.length;e++){const r=p+n[e];try{if(s.sync(r,{pathExt:i})){if(!t.all)return r;c.push(r)}}catch(e){}}}if(t.all&&c.length)return c;if(t.nothrow)return null;throw a(e)}},9376:e=>{"use strict";const t=(e={})=>{const t=e.env||process.env;return"win32"!==(e.platform||process.platform)?"PATH":Object.keys(t).reverse().find((e=>"PATH"===e.toUpperCase()))||"Path"};e.exports=t,e.exports.default=t},1395:(e,t,r)=>{"use strict";const n=r(7521);e.exports=(e="")=>{const t=e.match(n);if(!t)return null;const[r,o]=t[0].replace(/#! ?/,"").split(" "),i=r.split("/").pop();return"env"===i?o:o?`${i} ${o}`:i}},7521:e=>{"use strict";e.exports=/^#!(.*)/},6495:(e,t,r)=>{"use strict";function n(e){if("object"!=typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t)||Symbol.toStringTag in e||Symbol.iterator in e)}r.d(t,{execa:()=>qa});var o=r(3136);const i=(e,t)=>{const r=s(e);if("string"!=typeof r)throw new TypeError(`${t} must be a string or a file URL: ${r}.`);return r},s=e=>e instanceof URL?(0,o.fileURLToPath)(e):e,a=(e,t=[],r={})=>{const o=i(e,"First argument"),[s,a]=n(t)?[[],t]:[t,r];if(!Array.isArray(s))throw new TypeError(`Second argument must be either an array of arguments or an options object: ${s}`);if(s.some((e=>"object"==typeof e&&null!==e)))throw new TypeError(`Second argument must be an array of strings: ${s}`);const l=s.map(String),c=l.find((e=>e.includes("\0")));if(void 0!==c)throw new TypeError(`Arguments cannot contain null bytes ("\\0"): ${c}`);if(!n(a))throw new TypeError(`Last argument must be an options object: ${a}`);return[o,l,a]};var l=r(1421),c=r(6193);const{toString:d}=Object.prototype,u=e=>"[object Uint8Array]"===d.call(e),p=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),f=new TextEncoder,m=e=>f.encode(e),b=new TextDecoder,h=e=>b.decode(e),g=e=>1===e.length&&u(e[0])?e[0]:w(y(e)),y=e=>e.map((e=>"string"==typeof e?m(e):e)),w=e=>{const t=new Uint8Array(v(e));let r=0;for(const n of e)t.set(n,r),r+=n.length;return t},v=e=>{let t=0;for(const r of e)t+=r.length;return t},S=({templates:e,expressions:t,tokens:r,index:n,template:o})=>{if(void 0===o)throw new TypeError(`Invalid backslash sequence: ${e.raw[n]}`);const{nextTokens:i,leadingWhitespaces:s,trailingWhitespaces:a}=x(o,e.raw[n]),l=E(r,i,s);if(n===t.length)return l;const c=t[n],d=Array.isArray(c)?c.map((e=>I(e))):[I(c)];return E(l,d,a)},x=(e,t)=>{if(0===t.length)return{nextTokens:[],leadingWhitespaces:!1,trailingWhitespaces:!1};const r=[];let n=0;const o=D.has(t[0]);for(let o=0,i=0;o<e.length;o+=1,i+=1){const s=t[i];if(D.has(s))n!==o&&r.push(e.slice(n,o)),n=o+1;else if("\\"===s){const e=t[i+1];"u"===e&&"{"===t[i+2]?i=t.indexOf("}",i+3):i+=T[e]??1}}const i=n===e.length;return i||r.push(e.slice(n)),{nextTokens:r,leadingWhitespaces:o,trailingWhitespaces:i}},D=new Set([" ","\t","\r","\n"]),T={x:3,u:5},E=(e,t,r)=>r||0===e.length||0===t.length?[...e,...t]:[...e.slice(0,-1),`${e.at(-1)}${t[0]}`,...t.slice(1)],I=e=>{const t=typeof e;if("string"===t)return e;if("number"===t)return String(e);if(n(e)&&("stdout"in e||"isMaxBuffer"in e))return O(e);if(e instanceof l.ChildProcess||"[object Promise]"===Object.prototype.toString.call(e))throw new TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");throw new TypeError(`Unexpected "${t}" in template expression`)},O=({stdout:e})=>{if("string"==typeof e)return e;if(u(e))return h(e);if(void 0===e)throw new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\' "stdout" option.');throw new TypeError(`Unexpected "${typeof e}" stdout in template expression`)};var M=r(7066);const N=M.WriteStream.prototype.hasColors(),B=(e,t)=>{if(!N)return e=>e;const r=`[${e}m`,n=`[${t}m`;return e=>{const t=e+"";let o=t.indexOf(n);if(-1===o)return r+t+n;let i=r,s=0;for(;-1!==o;)i+=t.slice(s,o)+r,s=o+n.length,o=t.indexOf(n,s);return i+=t.slice(s)+n,i}},$=(B(0,0),B(1,22)),j=(B(2,22),B(3,23),B(4,24),B(53,55),B(7,27),B(8,28),B(9,29),B(30,39),B(31,39),B(32,39),B(33,39),B(34,39),B(35,39),B(36,39),B(37,39),B(90,39)),C=(B(40,49),B(41,49),B(42,49),B(43,49),B(44,49),B(45,49),B(46,49),B(47,49),B(100,49),B(91,39)),A=(B(92,39),B(93,39));B(94,39),B(95,39),B(96,39),B(97,39),B(101,49),B(102,49),B(103,49),B(104,49),B(105,49),B(106,49),B(107,49);var R=r(7975);const L=(0,R.debuglog)("execa").enabled?"full":"none";let k=0n;const U=e=>e.some((e=>"none"!==e)),P=new Set(["none","short","full"]);var F=r(3024),G=r(1708);const W={circleQuestionMark:"(?)",questionMarkPrefix:"(?)",square:"â–ˆ",squareDarkShade:"â–“",squareMediumShade:"â–’",squareLightShade:"â–‘",squareTop:"â–€",squareBottom:"â–„",squareLeft:"â–Œ",squareRight:"â–",squareCenter:"â– ",bullet:"â—",dot:"â€¤",ellipsis:"â€¦",pointerSmall:"â€º",triangleUp:"â–²",triangleUpSmall:"â–´",triangleDown:"â–¼",triangleDownSmall:"â–¾",triangleLeftSmall:"â—‚",triangleRightSmall:"â–¸",home:"âŒ‚",heart:"â™¥",musicNote:"â™ª",musicNoteBeamed:"â™«",arrowUp:"â†‘",arrowDown:"â†“",arrowLeft:"â†",arrowRight:"â†’",arrowLeftRight:"â†”",arrowUpDown:"â†•",almostEqual:"â‰ˆ",notEqual:"â‰ ",lessOrEqual:"â‰¤",greaterOrEqual:"â‰¥",identical:"â‰¡",infinity:"âˆž",subscriptZero:"â‚€",subscriptOne:"â‚",subscriptTwo:"â‚‚",subscriptThree:"â‚ƒ",subscriptFour:"â‚„",subscriptFive:"â‚…",subscriptSix:"â‚†",subscriptSeven:"â‚‡",subscriptEight:"â‚ˆ",subscriptNine:"â‚‰",oneHalf:"Â½",oneThird:"â…“",oneQuarter:"Â¼",oneFifth:"â…•",oneSixth:"â…™",oneEighth:"â…›",twoThirds:"â…”",twoFifths:"â…–",threeQuarters:"Â¾",threeFifths:"â…—",threeEighths:"â…œ",fourFifths:"â…˜",fiveSixths:"â…š",fiveEighths:"â…",sevenEighths:"â…ž",line:"â”€",lineBold:"â”",lineDouble:"â•",lineDashed0:"â”„",lineDashed1:"â”…",lineDashed2:"â”ˆ",lineDashed3:"â”‰",lineDashed4:"â•Œ",lineDashed5:"â•",lineDashed6:"â•´",lineDashed7:"â•¶",lineDashed8:"â•¸",lineDashed9:"â•º",lineDashed10:"â•¼",lineDashed11:"â•¾",lineDashed12:"âˆ’",lineDashed13:"â€“",lineDashed14:"â€",lineDashed15:"âƒ",lineVertical:"â”‚",lineVerticalBold:"â”ƒ",lineVerticalDouble:"â•‘",lineVerticalDashed0:"â”†",lineVerticalDashed1:"â”‡",lineVerticalDashed2:"â”Š",lineVerticalDashed3:"â”‹",lineVerticalDashed4:"â•Ž",lineVerticalDashed5:"â•",lineVerticalDashed6:"â•µ",lineVerticalDashed7:"â•·",lineVerticalDashed8:"â•¹",lineVerticalDashed9:"â•»",lineVerticalDashed10:"â•½",lineVerticalDashed11:"â•¿",lineDownLeft:"â”",lineDownLeftArc:"â•®",lineDownBoldLeftBold:"â”“",lineDownBoldLeft:"â”’",lineDownLeftBold:"â”‘",lineDownDoubleLeftDouble:"â•—",lineDownDoubleLeft:"â•–",lineDownLeftDouble:"â••",lineDownRight:"â”Œ",lineDownRightArc:"â•­",lineDownBoldRightBold:"â”",lineDownBoldRight:"â”Ž",lineDownRightBold:"â”",lineDownDoubleRightDouble:"â•”",lineDownDoubleRight:"â•“",lineDownRightDouble:"â•’",lineUpLeft:"â”˜",lineUpLeftArc:"â•¯",lineUpBoldLeftBold:"â”›",lineUpBoldLeft:"â”š",lineUpLeftBold:"â”™",lineUpDoubleLeftDouble:"â•",lineUpDoubleLeft:"â•œ",lineUpLeftDouble:"â•›",lineUpRight:"â””",lineUpRightArc:"â•°",lineUpBoldRightBold:"â”—",lineUpBoldRight:"â”–",lineUpRightBold:"â”•",lineUpDoubleRightDouble:"â•š",lineUpDoubleRight:"â•™",lineUpRightDouble:"â•˜",lineUpDownLeft:"â”¤",lineUpBoldDownBoldLeftBold:"â”«",lineUpBoldDownBoldLeft:"â”¨",lineUpDownLeftBold:"â”¥",lineUpBoldDownLeftBold:"â”©",lineUpDownBoldLeftBold:"â”ª",lineUpDownBoldLeft:"â”§",lineUpBoldDownLeft:"â”¦",lineUpDoubleDownDoubleLeftDouble:"â•£",lineUpDoubleDownDoubleLeft:"â•¢",lineUpDownLeftDouble:"â•¡",lineUpDownRight:"â”œ",lineUpBoldDownBoldRightBold:"â”£",lineUpBoldDownBoldRight:"â” ",lineUpDownRightBold:"â”",lineUpBoldDownRightBold:"â”¡",lineUpDownBoldRightBold:"â”¢",lineUpDownBoldRight:"â”Ÿ",lineUpBoldDownRight:"â”ž",lineUpDoubleDownDoubleRightDouble:"â• ",lineUpDoubleDownDoubleRight:"â•Ÿ",lineUpDownRightDouble:"â•ž",lineDownLeftRight:"â”¬",lineDownBoldLeftBoldRightBold:"â”³",lineDownLeftBoldRightBold:"â”¯",lineDownBoldLeftRight:"â”°",lineDownBoldLeftBoldRight:"â”±",lineDownBoldLeftRightBold:"â”²",lineDownLeftRightBold:"â”®",lineDownLeftBoldRight:"â”­",lineDownDoubleLeftDoubleRightDouble:"â•¦",lineDownDoubleLeftRight:"â•¥",lineDownLeftDoubleRightDouble:"â•¤",lineUpLeftRight:"â”´",lineUpBoldLeftBoldRightBold:"â”»",lineUpLeftBoldRightBold:"â”·",lineUpBoldLeftRight:"â”¸",lineUpBoldLeftBoldRight:"â”¹",lineUpBoldLeftRightBold:"â”º",lineUpLeftRightBold:"â”¶",lineUpLeftBoldRight:"â”µ",lineUpDoubleLeftDoubleRightDouble:"â•©",lineUpDoubleLeftRight:"â•¨",lineUpLeftDoubleRightDouble:"â•§",lineUpDownLeftRight:"â”¼",lineUpBoldDownBoldLeftBoldRightBold:"â•‹",lineUpDownBoldLeftBoldRightBold:"â•ˆ",lineUpBoldDownLeftBoldRightBold:"â•‡",lineUpBoldDownBoldLeftRightBold:"â•Š",lineUpBoldDownBoldLeftBoldRight:"â•‰",lineUpBoldDownLeftRight:"â•€",lineUpDownBoldLeftRight:"â•",lineUpDownLeftBoldRight:"â”½",lineUpDownLeftRightBold:"â”¾",lineUpBoldDownBoldLeftRight:"â•‚",lineUpDownLeftBoldRightBold:"â”¿",lineUpBoldDownLeftBoldRight:"â•ƒ",lineUpBoldDownLeftRightBold:"â•„",lineUpDownBoldLeftBoldRight:"â•…",lineUpDownBoldLeftRightBold:"â•†",lineUpDoubleDownDoubleLeftDoubleRightDouble:"â•¬",lineUpDoubleDownDoubleLeftRight:"â•«",lineUpDownLeftDoubleRightDouble:"â•ª",lineCross:"â•³",lineBackslash:"â•²",lineSlash:"â•±"},_={tick:"âœ”",info:"â„¹",warning:"âš ",cross:"âœ˜",squareSmall:"â—»",squareSmallFilled:"â—¼",circle:"â—¯",circleFilled:"â—‰",circleDotted:"â—Œ",circleDouble:"â—Ž",circleCircle:"â“ž",circleCross:"â“§",circlePipe:"â’¾",radioOn:"â—‰",radioOff:"â—¯",checkboxOn:"â˜’",checkboxOff:"â˜",checkboxCircleOn:"â“§",checkboxCircleOff:"â’¾",pointer:"â¯",triangleUpOutline:"â–³",triangleLeft:"â—€",triangleRight:"â–¶",lozenge:"â—†",lozengeOutline:"â—‡",hamburger:"â˜°",smiley:"ã‹¡",mustache:"à·´",star:"â˜…",play:"â–¶",nodejs:"â¬¢",oneSeventh:"â…",oneNinth:"â…‘",oneTenth:"â…’"},V={...W,..._},z={...W,tick:"âˆš",info:"i",warning:"â€¼",cross:"Ã—",squareSmall:"â–¡",squareSmallFilled:"â– ",circle:"( )",circleFilled:"(*)",circleDotted:"( )",circleDouble:"( )",circleCircle:"(â—‹)",circleCross:"(Ã—)",circlePipe:"(â”‚)",radioOn:"(*)",radioOff:"( )",checkboxOn:"[Ã—]",checkboxOff:"[ ]",checkboxCircleOn:"(Ã—)",checkboxCircleOff:"( )",pointer:">",triangleUpOutline:"âˆ†",triangleLeft:"â—„",triangleRight:"â–º",lozenge:"â™¦",lozengeOutline:"â—Š",hamburger:"â‰¡",smiley:"â˜º",mustache:"â”Œâ”€â”",star:"âœ¶",play:"â–º",nodejs:"â™¦",oneSeventh:"1/7",oneNinth:"1/9",oneTenth:"1/10"},H=("win32"!==G.platform?"linux"!==G.env.TERM:Boolean(G.env.WT_SESSION)||Boolean(G.env.TERMINUS_SUBLIME)||"{cmd::Cmder}"===G.env.ConEmuTask||"Terminus-Sublime"===G.env.TERM_PROGRAM||"vscode"===G.env.TERM_PROGRAM||"xterm-256color"===G.env.TERM||"alacritty"===G.env.TERM||"JetBrains-JediTerm"===G.env.TERMINAL_EMULATOR)?V:z,q=(Object.entries(_),(e,t,r,n)=>{const o=Y(e,t,r,n);(0,F.writeFileSync)(K,`${o}\n`)}),K=2,Y=(e,t,r,n)=>e.includes("\n")?e.split("\n").map((e=>X(e,t,r,n))).join("\n"):X(e,t,r,n),X=(e,t,r,n=Q)=>[j(`[${Z()}]`),j(`[${t}]`),n(ee[r]),n(e)].join(" "),Q=e=>e,Z=()=>{const e=new Date;return`${J(e.getHours(),2)}:${J(e.getMinutes(),2)}:${J(e.getSeconds(),2)}.${J(e.getMilliseconds(),3)}`},J=(e,t)=>String(e).padStart(t,"0"),ee={command:"$",pipedCommand:"|",output:" ",error:H.cross,warning:H.warning,success:H.tick},te=()=>G.hrtime.bigint(),re=e=>Number(G.hrtime.bigint()-e)/1e6,ne=e=>(0,R.stripVTControlCharacters)(e).split("\n").map((e=>oe(e))).join("\n"),oe=e=>e.replaceAll(se,(e=>ie(e))),ie=e=>{const t=ae[e];if(void 0!==t)return t;const r=e.codePointAt(0),n=r.toString(16);return r<=le?`\\u${n.padStart(4,"0")}`:`\\U${n}`},se=/\p{Separator}|\p{Other}/gu,ae={" ":" ","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t"},le=65535,ce=/^[\w./-]+$/,de=e=>ue.includes(e),ue=[G.stdin,G.stdout,G.stderr],pe=["stdin","stdout","stderr"],fe=e=>pe[e]??`stdio[${e}]`,me=(e,t)=>{const r=Array.from({length:be(e)}),n=he(e[t],r,t);return De(n,t)},be=({stdio:e})=>Array.isArray(e)?Math.max(e.length,pe.length):pe.length,he=(e,t,r)=>n(e)?ge(e,t,r):t.fill(e),ge=(e,t,r)=>{for(const n of Object.keys(e).sort(ye))for(const o of ve(n,r,t))t[o]=e[n];return t},ye=(e,t)=>we(e)<we(t)?1:-1,we=e=>"stdout"===e||"stderr"===e?0:"all"===e?2:1,ve=(e,t,r)=>{const n=Se(e);if(void 0===n||0===n)throw new TypeError(`"${t}.${e}" is invalid.\nIt must be "${t}.stdout", "${t}.stderr", "${t}.all", or "${t}.fd3", "${t}.fd4" (and so on).`);if(n>=r.length)throw new TypeError(`"${t}.${e}" is invalid: that file descriptor does not exist.\nPlease set the "stdio" option to ensure that file descriptor exists.`);return"all"===n?[1,2]:[n]},Se=e=>{if("all"===e)return e;if(pe.includes(e))return pe.indexOf(e);const t=xe.exec(e);return null!==t?Number(t[1]):void 0},xe=/^fd(\d+)$/,De=(e,t)=>e.map((e=>void 0===e?Te[t]:e)),Te={lines:!1,buffer:!0,maxBuffer:1e8,verbose:L,stripFinalNewline:!0},Ee=["lines","buffer","maxBuffer","verbose","stripFinalNewline"],Ie=(e,t,r)=>{const n=te(),{command:o,escapedCommand:i}=((e,t)=>{const r=[e,...t];return{command:r.join(" "),escapedCommand:r.map((e=>{return t=oe(e),ce.test(t)?t:"win32"===G.platform?`"${t.replaceAll('"','""')}"`:`'${t.replaceAll("'","'\\''")}'`;var t})).join(" ")}})(e,t),s=(e=>{const t=U(e)?k++:void 0;return(e=>{for(const t of e){if(!1===t)throw new TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');if(!0===t)throw new TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');if(!P.has(t)){const e=[...P].map((e=>`'${e}'`)).join(", ");throw new TypeError(`The "verbose" option must not be ${t}. Allowed values are: ${e}.`)}}})(e),{verbose:e,verboseId:t}})(me(r,"verbose"));return((e,{verbose:t,verboseId:r},{piped:n=!1})=>{U(t)&&q(e,r,n?"pipedCommand":"command",$)})(i,s,r),{command:o,escapedCommand:i,startTime:n,verboseInfo:s}};var Oe=r(6760),Me=r(4993);function Ne(e={}){const{env:t=process.env,platform:r=process.platform}=e;return"win32"!==r?"PATH":Object.keys(t).reverse().find((e=>"PATH"===e.toUpperCase()))||"Path"}const Be=({env:e=G.env,...t}={})=>{const r=Ne({env:e={...e}});return t.path=e[r],e[r]=(({cwd:e=G.cwd(),path:t=G.env[Ne()],preferLocal:r=!0,execPath:n=G.execPath,addExecPath:i=!0}={})=>{const s=e instanceof URL?(0,o.fileURLToPath)(e):e,a=Oe.resolve(s),l=[];return r&&((e,t)=>{let r;for(;r!==t;)e.push(Oe.join(t,"node_modules/.bin")),r=t,t=Oe.resolve(t,"..")})(l,a),i&&((e,t,r)=>{const n=t instanceof URL?(0,o.fileURLToPath)(t):t;e.push(Oe.resolve(r,n,".."))})(l,n,a),[...l,t].join(Oe.delimiter)})(t),e};var $e=r(8500);class je extends Error{}const Ce=(e,t)=>{Object.defineProperty(e.prototype,"name",{value:t,writable:!0,enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,Ae,{value:!0,writable:!1,enumerable:!1,configurable:!1})},Ae=Symbol("isExecaError"),Re=e=>"[object Error]"===Object.prototype.toString.call(e);class Le extends Error{}Ce(Le,Le.name);class ke extends Error{}Ce(ke,ke.name);var Ue=r(8161);const Pe=e=>0===e?e:Fe(e,"`subprocess.kill()`'s argument"),Fe=(e,t)=>{if(Number.isInteger(e))return Ge(e,t);if("string"==typeof e)return _e(e,t);throw new TypeError(`Invalid ${t} ${String(e)}: it must be a string or an integer.\n${Ve()}`)},Ge=(e,t)=>{if(We.has(e))return We.get(e);throw new TypeError(`Invalid ${t} ${e}: this signal integer does not exist.\n${Ve()}`)},We=new Map(Object.entries(Ue.constants.signals).reverse().map((([e,t])=>[t,e]))),_e=(e,t)=>{if(e in Ue.constants.signals)return e;if(e.toUpperCase()in Ue.constants.signals)throw new TypeError(`Invalid ${t} '${e}': please rename it to '${e.toUpperCase()}'.`);throw new TypeError(`Invalid ${t} '${e}': this signal name does not exist.\n${Ve()}`)},Ve=()=>`Available signal names: ${ze()}.\nAvailable signal numbers: ${He()}.`,ze=()=>Object.keys(Ue.constants.signals).sort().map((e=>`'${e}'`)).join(", "),He=()=>[...new Set(Object.values(Ue.constants.signals).sort(((e,t)=>e-t)))].join(", "),qe=({kill:e,options:{forceKillAfterDelay:t,killSignal:r},onInternalError:n,controller:o},i,s)=>{const{signal:a,error:l}=Ke(i,s,r);Ye(l,n);const c=e(a);return Xe({kill:e,signal:a,forceKillAfterDelay:t,killSignal:r,killResult:c,controller:o}),c},Ke=(e,t,r)=>{const[n=r,o]=Re(e)?[void 0,e]:[e,t];if("string"!=typeof n&&!Number.isInteger(n))throw new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(n)}`);if(void 0!==o&&!Re(o))throw new TypeError(`The second argument is optional. If specified, it must be an error instance: ${o}`);return{signal:Pe(n),error:o}},Ye=(e,t)=>{void 0!==e&&t.reject(e)},Xe=async({kill:e,signal:t,forceKillAfterDelay:r,killSignal:n,killResult:o,controller:i})=>{if(Qe(t,r,n,o))try{await(0,$e.setTimeout)(r,void 0,{signal:i.signal}),e("SIGKILL")}catch{}},Qe=(e,t,r,n)=>e===r&&!1!==t&&n,Ze=(e,t,r,n)=>0===t||void 0===t?[]:[Je(e,t,r,n)],Je=async(e,t,r,{signal:n})=>{throw await(0,$e.setTimeout)(t,void 0,{signal:n}),r.timedOut=!0,e.kill(),new je},et=new Set(["utf8","utf16le"]),tt=new Set(["buffer","hex","base64","base64url","latin1","ascii"]),rt=new Set([...et,...tt]),nt={"utf-8":"utf8","utf-16le":"utf16le","ucs-2":"utf16le",ucs2:"utf16le",binary:"latin1"},ot=e=>"string"==typeof e?`"${e}"`:String(e),it=()=>{try{return G.cwd()}catch(e){throw e.message=`The current directory does not exist.\n${e.message}`,e}},st=(e,t,r)=>{r.cwd=((e=it())=>{const t=i(e,'The "cwd" option');return(0,Oe.resolve)(t)})(r.cwd);const[n,o,a]=((e,t,{node:r=!1,nodePath:n=G.execPath,nodeOptions:o=G.execArgv.filter((e=>!e.startsWith("--inspect"))),cwd:s,execPath:a,...l})=>{if(void 0!==a)throw new TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');const c=i(n,'The "nodePath" option'),d=(0,Oe.resolve)(s,c),u={...l,nodePath:d,node:r,cwd:s};if(!r)return[e,t,u];if("node"===(0,Oe.basename)(e,".exe"))throw new TypeError('When the "node" option is true, the first argument does not need to be "node".');return[d,[...o,e,...t],{ipc:!0,...u,shell:!1}]})(e,t,r),{command:l,args:c,options:d}=Me._parse(n,o,a),u=(e=>{const t={...e};for(const r of Ee)t[r]=me(e,r);return t})(d),p=at(u);return(({timeout:e})=>{if(void 0!==e&&(!Number.isFinite(e)||e<0))throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`)})(p),(({encoding:e})=>{if(rt.has(e))return;const t=(e=>{if(null===e)return"buffer";if("string"!=typeof e)return;const t=e.toLowerCase();return t in nt?nt[t]:rt.has(t)?t:void 0})(e);if(void 0!==t)throw new TypeError(`Invalid option \`encoding: ${ot(e)}\`.\nPlease rename it to ${ot(t)}.`);const r=[...rt].map((e=>ot(e))).join(", ");throw new TypeError(`Invalid option \`encoding: ${ot(e)}\`.\nPlease rename it to one of: ${r}.`)})(p),p.shell=s(p.shell),p.env=lt(p),p.killSignal=(e=>{const t="option `killSignal`";if(0===e)throw new TypeError(`Invalid ${t}: 0 cannot be used.`);return Fe(e,t)})(p.killSignal),p.forceKillAfterDelay=(e=>{if(!1===e)return e;if(!0===e)return 5e3;if(!Number.isFinite(e)||e<0)throw new TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);return e})(p.forceKillAfterDelay),p.lines=p.lines.map(((e,t)=>e&&!tt.has(p.encoding)&&p.buffer[t])),"win32"===G.platform&&"cmd"===(0,Oe.basename)(l,".exe")&&c.unshift("/q"),{file:l,commandArguments:c,options:p}},at=({extendEnv:e=!0,preferLocal:t=!1,cwd:r,localDir:n=r,encoding:o="utf8",reject:i=!0,cleanup:s=!0,all:a=!1,windowsHide:l=!0,killSignal:c="SIGTERM",forceKillAfterDelay:d=!0,ipc:u=!1,serialization:p="advanced",...f})=>({...f,extendEnv:e,preferLocal:t,cwd:r,localDirectory:n,encoding:o,reject:i,cleanup:s,all:a,windowsHide:l,killSignal:c,forceKillAfterDelay:d,ipc:u,serialization:p}),lt=({env:e,extendEnv:t,preferLocal:r,node:n,localDirectory:o,nodePath:i})=>{const s=t?{...G.env,...e}:e;return r||n?Be({env:s,cwd:o,execPath:i,preferLocal:r,addExecPath:n}):s},ct=(e,t)=>({name:`SIGRT${t+1}`,number:dt+t,action:"terminate",description:"Application-specific signal (realtime)",standard:"posix"}),dt=34,ut=[{name:"SIGHUP",number:1,action:"terminate",description:"Terminal closed",standard:"posix"},{name:"SIGINT",number:2,action:"terminate",description:"User interruption with CTRL-C",standard:"ansi"},{name:"SIGQUIT",number:3,action:"core",description:"User interruption with CTRL-\\",standard:"posix"},{name:"SIGILL",number:4,action:"core",description:"Invalid machine instruction",standard:"ansi"},{name:"SIGTRAP",number:5,action:"core",description:"Debugger breakpoint",standard:"posix"},{name:"SIGABRT",number:6,action:"core",description:"Aborted",standard:"ansi"},{name:"SIGIOT",number:6,action:"core",description:"Aborted",standard:"bsd"},{name:"SIGBUS",number:7,action:"core",description:"Bus error due to misaligned, non-existing address or paging error",standard:"bsd"},{name:"SIGEMT",number:7,action:"terminate",description:"Command should be emulated but is not implemented",standard:"other"},{name:"SIGFPE",number:8,action:"core",description:"Floating point arithmetic error",standard:"ansi"},{name:"SIGKILL",number:9,action:"terminate",description:"Forced termination",standard:"posix",forced:!0},{name:"SIGUSR1",number:10,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGSEGV",number:11,action:"core",description:"Segmentation fault",standard:"ansi"},{name:"SIGUSR2",number:12,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGPIPE",number:13,action:"terminate",description:"Broken pipe or socket",standard:"posix"},{name:"SIGALRM",number:14,action:"terminate",description:"Timeout or timer",standard:"posix"},{name:"SIGTERM",number:15,action:"terminate",description:"Termination",standard:"ansi"},{name:"SIGSTKFLT",number:16,action:"terminate",description:"Stack is empty or overflowed",standard:"other"},{name:"SIGCHLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"posix"},{name:"SIGCLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"other"},{name:"SIGCONT",number:18,action:"unpause",description:"Unpaused",standard:"posix",forced:!0},{name:"SIGSTOP",number:19,action:"pause",description:"Paused",standard:"posix",forced:!0},{name:"SIGTSTP",number:20,action:"pause",description:'Paused using CTRL-Z or "suspend"',standard:"posix"},{name:"SIGTTIN",number:21,action:"pause",description:"Background process cannot read terminal input",standard:"posix"},{name:"SIGBREAK",number:21,action:"terminate",description:"User interruption with CTRL-BREAK",standard:"other"},{name:"SIGTTOU",number:22,action:"pause",description:"Background process cannot write to terminal output",standard:"posix"},{name:"SIGURG",number:23,action:"ignore",description:"Socket received out-of-band data",standard:"bsd"},{name:"SIGXCPU",number:24,action:"core",description:"Process timed out",standard:"bsd"},{name:"SIGXFSZ",number:25,action:"core",description:"File too big",standard:"bsd"},{name:"SIGVTALRM",number:26,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGPROF",number:27,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGWINCH",number:28,action:"ignore",description:"Terminal window size changed",standard:"bsd"},{name:"SIGIO",number:29,action:"terminate",description:"I/O is available",standard:"other"},{name:"SIGPOLL",number:29,action:"terminate",description:"Watched event",standard:"other"},{name:"SIGINFO",number:29,action:"ignore",description:"Request for process information",standard:"other"},{name:"SIGPWR",number:30,action:"terminate",description:"Device running out of power",standard:"systemv"},{name:"SIGSYS",number:31,action:"core",description:"Invalid system call",standard:"other"},{name:"SIGUNUSED",number:31,action:"terminate",description:"Invalid system call",standard:"other"}],pt=()=>{const e=(()=>{const e=64-dt+1;return Array.from({length:e},ct)})();return[...ut,...e].map(ft)},ft=({name:e,number:t,description:r,action:n,forced:o=!1,standard:i})=>{const{signals:{[e]:s}}=Ue.constants,a=void 0!==s;return{name:e,number:a?s:t,description:r,supported:a,action:n,forced:o,standard:i}},mt=({name:e,number:t,description:r,supported:n,action:o,forced:i,standard:s})=>[e,{name:e,number:t,description:r,supported:n,action:o,forced:i,standard:s}],bt=(()=>{const e=pt();return Object.fromEntries(e.map(mt))})(),ht=(e,t)=>{const r=t.find((({name:t})=>Ue.constants.signals[t]===e));return void 0!==r?r:t.find((t=>t.number===e))};function gt(e){if("string"==typeof e)return yt(e);if(!ArrayBuffer.isView(e)||1!==e.BYTES_PER_ELEMENT)throw new Error("Input must be a string or a Uint8Array");return wt(e)}(()=>{const e=pt(),t=Array.from({length:65},((t,r)=>((e,t)=>{const r=ht(e,t);if(void 0===r)return{};const{name:n,description:o,supported:i,action:s,forced:a,standard:l}=r;return{[e]:{name:n,number:e,description:o,supported:i,action:s,forced:a,standard:l}}})(r,e)));Object.assign({},...t)})();const yt=e=>e.at(-1)===vt?e.slice(0,e.at(-2)===xt?-2:-1):e,wt=e=>e.at(-1)===St?e.subarray(0,e.at(-2)===Dt?-2:-1):e,vt="\n",St=vt.codePointAt(0),xt="\r",Dt=xt.codePointAt(0);function Tt(e,{checkOpen:t=!0}={}){return null!==e&&"object"==typeof e&&(e.writable||e.readable||!t||void 0===e.writable&&void 0===e.readable)&&"function"==typeof e.pipe}function Et(e,{checkOpen:t=!0}={}){return Tt(e,{checkOpen:t})&&(e.writable||!t)&&"function"==typeof e.write&&"function"==typeof e.end&&"boolean"==typeof e.writable&&"boolean"==typeof e.writableObjectMode&&"function"==typeof e.destroy&&"boolean"==typeof e.destroyed}function It(e,{checkOpen:t=!0}={}){return Tt(e,{checkOpen:t})&&(e.readable||!t)&&"function"==typeof e.read&&"boolean"==typeof e.readable&&"boolean"==typeof e.readableObjectMode&&"function"==typeof e.destroy&&"boolean"==typeof e.destroyed}function Ot(e,t){return Et(e,t)&&It(e,t)}const Mt=Object.getPrototypeOf(Object.getPrototypeOf((async function*(){})).prototype);class Nt{#e;#t;#r=!1;#n=void 0;constructor(e,t){this.#e=e,this.#t=t}next(){const e=()=>this.#o();return this.#n=this.#n?this.#n.then(e,e):e(),this.#n}return(e){const t=()=>this.#i(e);return this.#n?this.#n.then(t,t):t()}async#o(){if(this.#r)return{done:!0,value:void 0};let e;try{e=await this.#e.read()}catch(e){throw this.#n=void 0,this.#r=!0,this.#e.releaseLock(),e}return e.done&&(this.#n=void 0,this.#r=!0,this.#e.releaseLock()),e}async#i(e){if(this.#r)return{done:!0,value:e};if(this.#r=!0,!this.#t){const t=this.#e.cancel(e);return this.#e.releaseLock(),await t,{done:!0,value:e}}return this.#e.releaseLock(),{done:!0,value:e}}}const Bt=Symbol();function $t(){return this[Bt].next()}function jt(e){return this[Bt].return(e)}Object.defineProperty($t,"name",{value:"next"}),Object.defineProperty(jt,"name",{value:"return"});const Ct=Object.create(Mt,{next:{enumerable:!0,configurable:!0,writable:!0,value:$t},return:{enumerable:!0,configurable:!0,writable:!0,value:jt}});function At({preventCancel:e=!1}={}){const t=this.getReader(),r=new Nt(t,e),n=Object.create(Ct);return n[Bt]=r,n}const Rt=e=>{if(It(e,{checkOpen:!1})&&void 0!==Pt.on)return kt(e);if("function"==typeof e?.[Symbol.asyncIterator])return e;if("[object ReadableStream]"===Lt.call(e))return At.call(e);throw new TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.")},{toString:Lt}=Object.prototype,kt=async function*(e){const t=new AbortController,r={};Ut(e,t,r);try{for await(const[r]of Pt.on(e,"data",{signal:t.signal}))yield r}catch(e){if(void 0!==r.error)throw r.error;if(!t.signal.aborted)throw e}finally{e.destroy()}},Ut=async(e,t,r)=>{try{await Pt.finished(e,{cleanup:!0,readable:!0,writable:!1,error:!1})}catch(e){r.error=e}finally{t.abort()}},Pt={},Ft=async(e,{init:t,convertChunk:r,getSize:n,truncateChunk:o,addChunk:i,getFinalChunk:s,finalize:a},{maxBuffer:l=Number.POSITIVE_INFINITY}={})=>{const c=Rt(e),d=t();d.length=0;try{for await(const e of c){const t=r[Vt(e)](e,d);Wt({convertedChunk:t,state:d,getSize:n,truncateChunk:o,addChunk:i,maxBuffer:l})}return Gt({state:d,convertChunk:r,getSize:n,truncateChunk:o,addChunk:i,getFinalChunk:s,maxBuffer:l}),a(d)}catch(e){const t="object"==typeof e&&null!==e?e:new Error(e);throw t.bufferedData=a(d),t}},Gt=({state:e,getSize:t,truncateChunk:r,addChunk:n,getFinalChunk:o,maxBuffer:i})=>{const s=o(e);void 0!==s&&Wt({convertedChunk:s,state:e,getSize:t,truncateChunk:r,addChunk:n,maxBuffer:i})},Wt=({convertedChunk:e,state:t,getSize:r,truncateChunk:n,addChunk:o,maxBuffer:i})=>{const s=r(e),a=t.length+s;if(a<=i)return void _t(e,t,o,a);const l=n(e,i-t.length);throw void 0!==l&&_t(l,t,o,i),new Ht},_t=(e,t,r,n)=>{t.contents=r(e,t,n),t.length=n},Vt=e=>{const t=typeof e;if("string"===t)return"string";if("object"!==t||null===e)return"others";if(globalThis.Buffer?.isBuffer(e))return"buffer";const r=zt.call(e);return"[object ArrayBuffer]"===r?"arrayBuffer":"[object DataView]"===r?"dataView":Number.isInteger(e.byteLength)&&Number.isInteger(e.byteOffset)&&"[object ArrayBuffer]"===zt.call(e.buffer)?"typedArray":"others"},{toString:zt}=Object.prototype;class Ht extends Error{name="MaxBufferError";constructor(){super("maxBuffer exceeded")}}const qt=([,e])=>e,Kt=({originalError:e,timedOut:t,timeout:r,isMaxBuffer:n,maxBuffer:o,errorCode:i,signal:s,signalDescription:a,exitCode:l,isCanceled:c})=>t?`Command timed out after ${r} milliseconds`:c?"Command was canceled":n?((e,t)=>{const{streamName:r,threshold:n,unit:o}=((e,t)=>{if(void 0===e?.maxBufferInfo)return{streamName:"output",threshold:t[1],unit:"bytes"};const{maxBufferInfo:{fdNumber:r,unit:n}}=e;return delete e.maxBufferInfo,{streamName:fe(r),threshold:t[r],unit:n}})(e,t);return`Command's ${r} was larger than ${n} ${o}`})(e,o):void 0!==i?`Command failed with ${i}`:void 0!==s?`Command was killed with ${s} (${a})`:void 0!==l?`Command failed with exit code ${l}`:"Command failed",Yt=e=>"string"==typeof e?e:u(e)?h(e):"",Xt=({command:e,escapedCommand:t,stdio:r,all:n,options:{cwd:o},startTime:i})=>er({command:e,escapedCommand:t,cwd:o,durationMs:re(i),failed:!1,timedOut:!1,isCanceled:!1,isTerminated:!1,isMaxBuffer:!1,exitCode:0,stdout:r[1],stderr:r[2],all:n,stdio:r,pipedFrom:[]}),Qt=({error:e,command:t,escapedCommand:r,fileDescriptors:n,options:o,startTime:i,isSync:s})=>Zt({error:e,command:t,escapedCommand:r,startTime:i,timedOut:!1,isCanceled:!1,isMaxBuffer:!1,stdio:Array.from({length:n.length}),options:o,isSync:s}),Zt=({error:e,command:t,escapedCommand:r,startTime:n,timedOut:o,isCanceled:i,isMaxBuffer:s,exitCode:a,signal:l,stdio:c,all:d,options:{timeoutDuration:u,timeout:p=u,cwd:f,maxBuffer:m},isSync:b})=>{const{exitCode:h,signal:g,signalDescription:y}=tr(a,l),{originalMessage:w,shortMessage:v,message:S}=(({stdio:e,all:t,originalError:r,signal:n,signalDescription:o,exitCode:i,escapedCommand:s,timedOut:a,isCanceled:l,isMaxBuffer:c,maxBuffer:d,timeout:u,cwd:p})=>{const f=r?.code,m=Kt({originalError:r,timedOut:a,timeout:u,isMaxBuffer:c,maxBuffer:d,errorCode:f,signal:n,signalDescription:o,exitCode:i,isCanceled:l}),b=((e,t)=>{if(e instanceof je)return;const r=Re(n=e)&&Ae in n?e.originalMessage:String(e?.message??e);var n;const o=ne(((e,t)=>{if(t===it())return e;let r;try{r=(0,F.statSync)(t)}catch(r){return`The "cwd" option is invalid: ${t}.\n${r.message}\n${e}`}return r.isDirectory()?e:`The "cwd" option is not a directory: ${t}.\n${e}`})(r,t));return""===o?void 0:o})(r,p),h=`${m}: ${s}${void 0===b?"":`\n${b}`}`,g=[h,...void 0===t?[e[2],e[1]]:[t],...e.slice(3)].map((e=>ne(gt((e=>Array.isArray(e)?e.map((e=>gt(Yt(e)))).filter(Boolean).join("\n"):Yt(e))(e))))).filter(Boolean).join("\n\n");return{originalMessage:b,shortMessage:h,message:g}})({stdio:c,all:d,originalError:e,signal:g,signalDescription:y,exitCode:h,escapedCommand:r,timedOut:o,isCanceled:i,isMaxBuffer:s,maxBuffer:m,timeout:p,cwd:f}),x=((e,t,r)=>new(r?ke:Le)(t,e instanceof je?{}:{cause:e}))(e,S,b);return Object.assign(x,Jt({error:x,command:t,escapedCommand:r,startTime:n,timedOut:o,isCanceled:i,isMaxBuffer:s,exitCode:h,signal:g,signalDescription:y,stdio:c,all:d,cwd:f,originalMessage:w,shortMessage:v})),x},Jt=({error:e,command:t,escapedCommand:r,startTime:n,timedOut:o,isCanceled:i,isMaxBuffer:s,exitCode:a,signal:l,signalDescription:c,stdio:d,all:u,cwd:p,originalMessage:f,shortMessage:m})=>er({shortMessage:m,originalMessage:f,command:t,escapedCommand:r,cwd:p,durationMs:re(n),failed:!0,timedOut:o,isCanceled:i,isTerminated:void 0!==l,isMaxBuffer:s,exitCode:a,signal:l,signalDescription:c,code:e.cause?.code,stdout:d[1],stderr:d[2],all:u,stdio:d,pipedFrom:[]}),er=e=>Object.fromEntries(Object.entries(e).filter((([,e])=>void 0!==e))),tr=(e,t)=>{const r=null===t?void 0:t;return{exitCode:null===e?void 0:e,signal:r,signalDescription:void 0===r?void 0:bt[t].description}},rr=e=>Number.isFinite(e)?e:0;function nr(e,t){const r="bigint"==typeof e;if(!r&&!Number.isFinite(e))throw new TypeError("Expected a finite number or bigint");(t={...t}).colonNotation&&(t.compact=!1,t.formatSubMilliseconds=!1,t.separateMilliseconds=!1,t.verbose=!1),t.compact&&(t.unitCount=1,t.secondsDecimalDigits=0,t.millisecondsDecimalDigits=0);let n=[];const o=(e,r,o,i)=>{if(0!==n.length&&t.colonNotation||!(e=>0===e||0n===e)(e)||t.colonNotation&&"m"===o){if(i=i??String(e),t.colonNotation){const e=i.includes(".")?i.split(".")[0].length:i.length,t=n.length>0?2:1;i="0".repeat(Math.max(0,t-e))+i}else i+=t.verbose?" "+(s=r,1===(a=e)||1n===a?s:`${s}s`):o;var s,a;n.push(i)}},i=function(e){switch(typeof e){case"number":if(Number.isFinite(e))return function(e){return{days:Math.trunc(e/864e5),hours:Math.trunc(e/36e5%24),minutes:Math.trunc(e/6e4%60),seconds:Math.trunc(e/1e3%60),milliseconds:Math.trunc(e%1e3),microseconds:Math.trunc(rr(1e3*e)%1e3),nanoseconds:Math.trunc(rr(1e6*e)%1e3)}}(e);break;case"bigint":return function(e){return{days:e/86400000n,hours:e/3600000n%24n,minutes:e/60000n%60n,seconds:e/1000n%60n,milliseconds:e%1000n,microseconds:0n,nanoseconds:0n}}(e)}throw new TypeError("Expected a finite number or bigint")}(e),s=BigInt(i.days);if(o(s/365n,"year","y"),o(s%365n,"day","d"),o(Number(i.hours),"hour","h"),o(Number(i.minutes),"minute","m"),t.separateMilliseconds||t.formatSubMilliseconds||!t.colonNotation&&e<1e3){const e=Number(i.seconds),r=Number(i.milliseconds),n=Number(i.microseconds),s=Number(i.nanoseconds);if(o(e,"second","s"),t.formatSubMilliseconds)o(r,"millisecond","ms"),o(n,"microsecond","Âµs"),o(s,"nanosecond","ns");else{const e=r+n/1e3+s/1e6,i="number"==typeof t.millisecondsDecimalDigits?t.millisecondsDecimalDigits:0,a=e>=1?Math.round(e):Math.ceil(e),l=i?e.toFixed(i):a;o(Number.parseFloat(l),"millisecond","ms",l)}}else{const n=((e,t)=>{const r=Math.floor(e*10**t+1e-7);return(Math.round(r)/10**t).toFixed(t)})((r?Number(e%86400000n):e)/1e3%60,"number"==typeof t.secondsDecimalDigits?t.secondsDecimalDigits:1),i=t.keepDecimalsOnWholeSeconds?n:n.replace(/\.0+$/,"");o(Number.parseFloat(i),"second","s",i)}if(0===n.length)return"0"+(t.verbose?" milliseconds":"ms");const a=t.colonNotation?":":" ";return"number"==typeof t.unitCount&&(n=n.slice(0,Math.max(t.unitCount,1))),n.join(a)}const or=(e,t,r)=>{ir({message:ne(String(e)),failed:!0,reject:!0,durationMs:re(t),verboseInfo:r})},ir=({message:e,failed:t,reject:r,durationMs:n,verboseInfo:{verbose:o,verboseId:i}})=>{if(!U(o))return;const s=ar(t,r);(({message:e,failed:t,reject:r,verboseId:n,icon:o})=>{t&&q(e,n,o,r?C:A)})({message:e,failed:t,reject:r,verboseId:i,icon:s}),sr(n,i,s)},sr=(e,t,r)=>{const n=`(done in ${nr(e)})`;q(n,t,r,j)},ar=(e,t)=>e?t?"error":"warning":"success",lr=(e,t,{reject:r})=>{if((({shortMessage:e,failed:t,durationMs:r},n,o)=>{ir({message:e,failed:t,reject:n,durationMs:r,verboseInfo:o})})(e,r,t),e.failed&&r)throw e;return e},cr=(e,t)=>yr(e)?"asyncGenerator":wr(e)?"generator":Sr(e)?"fileUrl":xr(e)?"filePath":Or(e)?"webStream":Tt(e,{checkOpen:!1})?"native":u(e)?"uint8Array":Nr(e)?"asyncIterable":Br(e)?"iterable":Mr(e)?pr({transform:e},t):vr(e)?dr(e,t):"native",dr=(e,t)=>Ot(e.transform,{checkOpen:!1})?ur(e,t):Mr(e.transform)?pr(e,t):br(e,t),ur=(e,t)=>(fr(e,t,"Duplex stream"),"duplex"),pr=(e,t)=>(fr(e,t,"web TransformStream"),"webTransform"),fr=({final:e,binary:t,objectMode:r},n,o)=>{mr(e,`${n}.final`,o),mr(t,`${n}.binary`,o),hr(r,`${n}.objectMode`)},mr=(e,t,r)=>{if(void 0!==e)throw new TypeError(`The \`${t}\` option can only be defined when using a generator, not a ${r}.`)},br=({transform:e,final:t,binary:r,objectMode:n},o)=>{if(void 0!==e&&!gr(e))throw new TypeError(`The \`${o}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);if(Ot(t,{checkOpen:!1}))throw new TypeError(`The \`${o}.final\` option must not be a Duplex stream.`);if(Mr(t))throw new TypeError(`The \`${o}.final\` option must not be a web TransformStream.`);if(void 0!==t&&!gr(t))throw new TypeError(`The \`${o}.final\` option must be a generator.`);return hr(r,`${o}.binary`),hr(n,`${o}.objectMode`),yr(e)||yr(t)?"asyncGenerator":"generator"},hr=(e,t)=>{if(void 0!==e&&"boolean"!=typeof e)throw new TypeError(`The \`${t}\` option must use a boolean.`)},gr=e=>yr(e)||wr(e),yr=e=>"[object AsyncGeneratorFunction]"===Object.prototype.toString.call(e),wr=e=>"[object GeneratorFunction]"===Object.prototype.toString.call(e),vr=e=>n(e)&&(void 0!==e.transform||void 0!==e.final),Sr=e=>"[object URL]"===Object.prototype.toString.call(e),xr=e=>n(e)&&1===Object.keys(e).length&&Dr(e.file),Dr=e=>"string"==typeof e,Tr=new Set(["ipc","ignore","inherit","overlapped","pipe"]),Er=e=>"[object ReadableStream]"===Object.prototype.toString.call(e),Ir=e=>"[object WritableStream]"===Object.prototype.toString.call(e),Or=e=>Er(e)||Ir(e),Mr=e=>Er(e?.readable)&&Ir(e?.writable),Nr=e=>$r(e)&&"function"==typeof e[Symbol.asyncIterator],Br=e=>$r(e)&&"function"==typeof e[Symbol.iterator],$r=e=>"object"==typeof e&&null!==e,jr=new Set(["generator","asyncGenerator","duplex","webTransform"]),Cr=new Set(["fileUrl","filePath","fileNumber"]),Ar=new Set(["fileUrl","filePath"]),Rr=new Set([...Ar,"webStream","nodeStream"]),Lr=new Set(["webTransform","duplex"]),kr={generator:"a generator",asyncGenerator:"an async generator",fileUrl:"a file URL",filePath:"a file path string",fileNumber:"a file descriptor number",webStream:"a web stream",nodeStream:"a Node.js stream",webTransform:"a web TransformStream",duplex:"a Duplex stream",native:"any value",iterable:"an iterable",asyncIterable:"an async iterable",string:"a string",uint8Array:"a Uint8Array"},Ur=(e,t,r,n)=>"output"===n?Pr(e,t,r):Fr(e,t,r),Pr=(e,t,r)=>{const n=0!==t&&r[t-1].value.readableObjectMode;return{writableObjectMode:n,readableObjectMode:e??n}},Fr=(e,t,r)=>{const n=0===t?!0===e:r[t-1].value.readableObjectMode;return{writableObjectMode:n,readableObjectMode:t!==r.length-1&&(e??n)}},Gr=(e,t,r,{encoding:n})=>{const o=e.filter((({type:e})=>jr.has(e))),i=Array.from({length:o.length});for(const[e,s]of Object.entries(o))i[e]=Wr({stdioItem:s,index:Number(e),newTransforms:i,optionName:t,direction:r,encoding:n});return Hr(i,r)},Wr=({stdioItem:e,stdioItem:{type:t},index:r,newTransforms:n,optionName:o,direction:i,encoding:s})=>"duplex"===t?_r({stdioItem:e,optionName:o}):"webTransform"===t?Vr({stdioItem:e,index:r,newTransforms:n,direction:i}):zr({stdioItem:e,index:r,newTransforms:n,direction:i,encoding:s}),_r=({stdioItem:e,stdioItem:{value:{transform:t,transform:{writableObjectMode:r,readableObjectMode:n},objectMode:o=n}},optionName:i})=>{if(o&&!n)throw new TypeError(`The \`${i}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);if(!o&&n)throw new TypeError(`The \`${i}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);return{...e,value:{transform:t,writableObjectMode:r,readableObjectMode:n}}},Vr=({stdioItem:e,stdioItem:{value:t},index:r,newTransforms:o,direction:i})=>{const{transform:s,objectMode:a}=n(t)?t:{transform:t},{writableObjectMode:l,readableObjectMode:c}=Ur(a,r,o,i);return{...e,value:{transform:s,writableObjectMode:l,readableObjectMode:c}}},zr=({stdioItem:e,stdioItem:{value:t},index:r,newTransforms:o,direction:i,encoding:s})=>{const{transform:a,final:l,binary:c=!1,preserveNewlines:d=!1,objectMode:u}=n(t)?t:{transform:t},p=c||tt.has(s),{writableObjectMode:f,readableObjectMode:m}=Ur(u,r,o,i);return{...e,value:{transform:a,final:l,binary:p,preserveNewlines:d,writableObjectMode:f,readableObjectMode:m}}},Hr=(e,t)=>"input"===t?e.reverse():e,qr=["input","output","output"],Kr=()=>{},Yr=()=>"input",Xr={generator:Kr,asyncGenerator:Kr,fileUrl:Kr,filePath:Kr,iterable:Yr,asyncIterable:Yr,uint8Array:Yr,webStream:e=>Ir(e)?"output":"input",nodeStream:e=>It(e,{checkOpen:!1})?Et(e,{checkOpen:!1})?void 0:"input":"output",webTransform:Kr,duplex:Kr,native(e){const t=Qr(e);return void 0!==t?t:Tt(e,{checkOpen:!1})?Xr.nodeStream(e):void 0}},Qr=e=>[0,G.stdin].includes(e)?"input":[1,2,G.stdout,G.stderr].includes(e)?"output":void 0,Zr=e=>pe.some((t=>void 0!==e[t])),Jr=(e,t)=>Array.isArray(e)?e.map((e=>Jr(e,t))):null==e?t>=pe.length?"ignore":"pipe":e,en=e=>"pipe"===e||Array.isArray(e)&&e.every((e=>"pipe"===e)),tn=(e,t="stdin")=>{const r=!0,{options:n,fileDescriptors:o}=nn.get(e),i=on(o,t,r),s=e.stdio[i];if(null===s)throw new TypeError(ln(i,t,n,r));return s},rn=(e,t="stdout")=>{const r=!1,{options:n,fileDescriptors:o}=nn.get(e),i=on(o,t,r),s="all"===i?e.all:e.stdio[i];if(null==s)throw new TypeError(ln(i,t,n,r));return s},nn=new WeakMap,on=(e,t,r)=>{const n=sn(t,r);return an(n,t,r,e),n},sn=(e,t)=>{const r=Se(e);if(void 0!==r)return r;const{validOptions:n,defaultValue:o}=t?{validOptions:'"stdin"',defaultValue:"stdin"}:{validOptions:'"stdout", "stderr", "all"',defaultValue:"stdout"};throw new TypeError(`"${un(t)}" must not be "${e}".\nIt must be ${n} or "fd3", "fd4" (and so on).\nIt is optional and defaults to "${o}".`)},an=(e,t,r,n)=>{const o=n[dn(e)];if(void 0===o)throw new TypeError(`"${un(r)}" must not be ${t}. That file descriptor does not exist.\nPlease set the "stdio" option to ensure that file descriptor exists.`);if("input"===o.direction&&!r)throw new TypeError(`"${un(r)}" must not be ${t}. It must be a readable stream, not writable.`);if("input"!==o.direction&&r)throw new TypeError(`"${un(r)}" must not be ${t}. It must be a writable stream, not readable.`)},ln=(e,t,r,n)=>{if("all"===e&&!r.all)return'The "all" option must be true to use "from: \'all\'".';const{optionName:o,optionValue:i}=cn(e,r);return`The "${o}: ${pn(i)}" option is incompatible with using "${un(n)}: ${pn(t)}".\nPlease set this option with "pipe" instead.`},cn=(e,{stdin:t,stdout:r,stderr:n,stdio:o})=>{const i=dn(e);return 0===i&&void 0!==t?{optionName:"stdin",optionValue:t}:1===i&&void 0!==r?{optionName:"stdout",optionValue:r}:2===i&&void 0!==n?{optionName:"stderr",optionValue:n}:{optionName:`stdio[${i}]`,optionValue:o[i]}},dn=e=>"all"===e?1:e,un=e=>e?"to":"from",pn=e=>"string"==typeof e?`'${e}'`:"number"==typeof e?`${e}`:"Stream",fn=({value:e,optionName:t,fdNumber:r,direction:n})=>{const o=mn(e,r);if(void 0!==o){if("output"===n)return{type:"fileNumber",value:o,optionName:t};if(M.isatty(o))throw new TypeError(`The \`${t}: ${pn(e)}\` option is invalid: it cannot be a TTY with synchronous methods.`);return{type:"uint8Array",value:p((0,F.readFileSync)(o)),optionName:t}}},mn=(e,t)=>{if("inherit"===e)return t;if("number"==typeof e)return e;const r=ue.indexOf(e);return-1!==r?r:void 0},bn=(e,t,r)=>{const n=ue[e];if(void 0===n)throw new TypeError(`The \`${r}: ${t}\` option is invalid: no such standard stream.`);return n},hn=({input:e,inputFile:t},r)=>0===r?[...gn(e),...wn(t)]:[],gn=e=>void 0===e?[]:[{type:yn(e),value:e,optionName:"input"}],yn=e=>{if(It(e,{checkOpen:!1}))return"nodeStream";if("string"==typeof e)return"string";if(u(e))return"uint8Array";throw new Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.")},wn=e=>void 0===e?[]:[{...vn(e),optionName:"inputFile"}],vn=e=>{if(Sr(e))return{type:"fileUrl",value:e};if(Dr(e))return{type:"filePath",value:{file:e}};throw new Error("The `inputFile` option must be a file path string or a file URL.")},Sn=({otherStdioItems:e,type:t,value:r,optionName:n,direction:o})=>{const i=e.filter((e=>xn(e,r)));if(0===i.length)return;const s=i.find((e=>e.direction!==o));return Dn(s,n,t),"output"===o?i[0].stream:void 0},xn=({type:e,value:t},r)=>"filePath"===e?t.path===r.path:"fileUrl"===e?t.href===r.href:t===r,Dn=(e,t,r)=>{if(void 0!==e)throw new TypeError(`The \`${e.optionName}\` and \`${t}\` options must not target ${kr[r]} that is the same.`)},Tn=(e,t,r,n)=>{const o=(({stdio:e,ipc:t,buffer:r,verbose:n,...o},i)=>{const s=((e,t)=>{if(void 0===e)return pe.map((e=>t[e]));if(Zr(t))throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${pe.map((e=>`\`${e}\``)).join(", ")}`);if("string"==typeof e)return[e,e,e];if(!Array.isArray(e))throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof e}\``);const r=Math.max(e.length,pe.length);return Array.from({length:r},((t,r)=>e[r]))})(e,o).map(((e,t)=>Jr(e,t)));return i?((e,t,r)=>e.map(((e,n)=>!t[n]&&0!==n&&"full"!==r[n]&&en(e)?"ignore":e)))(s,r,n):((e,t)=>t&&!e.includes("ipc")?[...e,"ipc"]:e)(s,t)})(t,n),i=o.map(((e,r)=>En({stdioOption:e,fdNumber:r,options:t,isSync:n}))),s=Cn({initialFileDescriptors:i,addProperties:e,options:t,isSync:n});return t.stdio=s.map((({stdioItems:e})=>kn(e))),s},En=({stdioOption:e,fdNumber:t,options:r,isSync:n})=>{const o=fe(t),{stdioItems:i,isStdioArray:s}=In({stdioOption:e,fdNumber:t,options:r,optionName:o}),a=((e,t,r)=>{const n=e.map((e=>(({type:e,value:t},r)=>qr[r]??Xr[e](t))(e,t)));if(n.includes("input")&&n.includes("output"))throw new TypeError(`The \`${r}\` option must not be an array of both readable and writable values.`);return n.find(Boolean)??"output"})(i,t,o),l=i.map((e=>(({stdioItem:e,stdioItem:{type:t},isStdioArray:r,fdNumber:n,direction:o,isSync:i})=>r&&"native"===t?i?(({stdioItem:e,stdioItem:{value:t,optionName:r},fdNumber:n,direction:o})=>{const i=fn({value:t,optionName:r,fdNumber:n,direction:o});if(void 0!==i)return i;if(Tt(t,{checkOpen:!1}))throw new TypeError(`The \`${r}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);return e})({stdioItem:e,fdNumber:n,direction:o}):(({stdioItem:e,stdioItem:{value:t,optionName:r},fdNumber:n})=>"inherit"===t?{type:"nodeStream",value:bn(n,t,r),optionName:r}:"number"==typeof t?{type:"nodeStream",value:bn(t,t,r),optionName:r}:Tt(t,{checkOpen:!1})?{type:"nodeStream",value:t,optionName:r}:e)({stdioItem:e,fdNumber:n}):e)({stdioItem:e,isStdioArray:s,fdNumber:t,direction:a,isSync:n}))),c=((e,t,r,n)=>[...e.filter((({type:e})=>!jr.has(e))),...Gr(e,t,r,n)])(l,o,a,r),d=((e,t)=>{const r=e.findLast((({type:e})=>jr.has(e)));return void 0!==r&&("input"===t?r.value.writableObjectMode:r.value.readableObjectMode)})(c,a);return jn(c,d),{direction:a,objectMode:d,stdioItems:c}},In=({stdioOption:e,fdNumber:t,options:r,optionName:n})=>{const o=(e=>e.filter(((t,r)=>e.every(((e,n)=>t.value!==e.value||r>=n||"generator"===t.type||"asyncGenerator"===t.type)))))([...(Array.isArray(e)?e:[e]).map((e=>On(e,n))),...hn(r,t)]),i=o.length>1;return Mn(o,i,n),Bn(o),{stdioItems:o,isStdioArray:i}},On=(e,t)=>({type:cr(e,t),value:e,optionName:t}),Mn=(e,t,r)=>{if(0===e.length)throw new TypeError(`The \`${r}\` option must not be an empty array.`);if(t)for(const{value:t,optionName:r}of e)if(Nn.has(t))throw new Error(`The \`${r}\` option must not include \`${t}\`.`)},Nn=new Set(["ignore","ipc"]),Bn=e=>{for(const t of e)$n(t)},$n=({type:e,value:t,optionName:r})=>{if((e=>Sr(e)&&"file:"!==e.protocol)(t))throw new TypeError(`The \`${r}: URL\` option must use the \`file:\` scheme.\nFor example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);if(((e,t)=>"native"===e&&"string"==typeof t&&!Tr.has(t))(e,t))throw new TypeError(`The \`${r}: { file: '...' }\` option must be used instead of \`${r}: '...'\`.`)},jn=(e,t)=>{if(!t)return;const r=e.find((({type:e})=>Cr.has(e)));if(void 0!==r)throw new TypeError(`The \`${r.optionName}\` option cannot use both files and transforms in objectMode.`)},Cn=({initialFileDescriptors:e,addProperties:t,options:r,isSync:n})=>{const o=[];try{for(const i of e)o.push(An({fileDescriptor:i,fileDescriptors:o,addProperties:t,options:r,isSync:n}));return o}catch(e){throw Ln(o),e}},An=({fileDescriptor:{direction:e,objectMode:t,stdioItems:r},fileDescriptors:n,addProperties:o,options:i,isSync:s})=>{const a=r.map((t=>Rn({stdioItem:t,addProperties:o,direction:e,options:i,fileDescriptors:n,isSync:s})));return{direction:e,objectMode:t,stdioItems:a}},Rn=({stdioItem:e,addProperties:t,direction:r,options:n,fileDescriptors:o,isSync:i})=>{const s=(({stdioItem:{type:e,value:t,optionName:r},direction:n,fileDescriptors:o,isSync:i})=>{const s=((e,t)=>e.flatMap((({direction:e,stdioItems:r})=>r.filter((e=>e.type===t)).map((t=>({...t,direction:e}))))))(o,e);if(0!==s.length){if(!i)return Rr.has(e)?Sn({otherStdioItems:s,type:e,value:t,optionName:r,direction:n}):void(Lr.has(e)&&(({otherStdioItems:e,type:t,value:r,optionName:n})=>{const o=e.find((({value:{transform:e}})=>e===r.transform));Dn(o,n,t)})({otherStdioItems:s,type:e,value:t,optionName:r}));(({otherStdioItems:e,type:t,value:r,optionName:n,direction:o})=>{Ar.has(t)&&Sn({otherStdioItems:e,type:t,value:r,optionName:n,direction:o})})({otherStdioItems:s,type:e,value:t,optionName:r,direction:n})}})({stdioItem:e,direction:r,fileDescriptors:o,isSync:i});return void 0!==s?{...e,stream:s}:{...e,...t[r][e.type](e,n)}},Ln=e=>{for(const{stdioItems:t}of e)for(const{stream:e}of t)void 0===e||de(e)||e.destroy()},kn=e=>{if(e.length>1)return e.some((({value:e})=>"overlapped"===e))?"overlapped":"pipe";const[{type:t,value:r}]=e;return"native"===t?r:"pipe"},Un=({type:e,optionName:t})=>{Pn(t,kr[e])},Pn=(e,t)=>{throw new TypeError(`The \`${e}\` option cannot be ${t} with synchronous methods.`)},Fn={generator(){},asyncGenerator:Un,webStream:Un,nodeStream:Un,webTransform:Un,duplex:Un,asyncIterable:Un,native:({optionName:e,value:t})=>("ipc"!==t&&"overlapped"!==t||Pn(e,`"${t}"`),{})},Gn={input:{...Fn,fileUrl:({value:e})=>({contents:[p((0,F.readFileSync)(e))]}),filePath:({value:{file:e}})=>({contents:[p((0,F.readFileSync)(e))]}),fileNumber:Un,iterable:({value:e})=>({contents:[...e]}),string:({value:e})=>({contents:[e]}),uint8Array:({value:e})=>({contents:[e]})},output:{...Fn,fileUrl:({value:e})=>({path:e}),filePath:({value:{file:e}})=>({path:e}),fileNumber:({value:e})=>({path:e}),iterable:Un,string:Un,uint8Array:Un}},Wn=(e,{stripFinalNewline:t},r)=>_n(t,r)&&void 0!==e&&!Array.isArray(e)?gt(e):e,_n=(e,t)=>"all"===t?e[1]||e[2]:e[t];var Vn=r(7075);const zn=(e,t,r,n)=>e||r?void 0:Kn(t,n),Hn=(e,t,r)=>r?e.flatMap((e=>qn(e,t))):qn(e,t),qn=(e,t)=>{const{transform:r,final:n}=Kn(t,{});return[...r(e),...n()]},Kn=(e,t)=>(t.previousChunks="",{transform:Yn.bind(void 0,t,e),final:Qn.bind(void 0,t)}),Yn=function*(e,t,r){if("string"!=typeof r)return void(yield r);let{previousChunks:n}=e,o=-1;for(let i=0;i<r.length;i+=1)if("\n"===r[i]){const s=Xn(r,i,t,e);let a=r.slice(o+1,i+1-s);n.length>0&&(a=eo(n,a),n=""),yield a,o=i}o!==r.length-1&&(n=eo(n,r.slice(o+1))),e.previousChunks=n},Xn=(e,t,r,n)=>r?0:(n.isWindowsNewline=0!==t&&"\r"===e[t-1],n.isWindowsNewline?2:1),Qn=function*({previousChunks:e}){e.length>0&&(yield e)},Zn=({binary:e,preserveNewlines:t,readableObjectMode:r,state:n})=>e||t||r?void 0:{transform:Jn.bind(void 0,n)},Jn=function*({isWindowsNewline:e=!1},t){const{unixNewline:r,windowsNewline:n,LF:o,concatBytes:i}="string"==typeof t?to:ro;if(t.at(-1)===o)return void(yield t);const s=e?n:r;yield i(t,s)},eo=(e,t)=>`${e}${t}`,to={windowsNewline:"\r\n",unixNewline:"\n",LF:"\n",concatBytes:eo},ro={windowsNewline:new Uint8Array([13,10]),unixNewline:new Uint8Array([10]),LF:10,concatBytes:(e,t)=>{const r=new Uint8Array(e.length+t.length);return r.set(e,0),r.set(t,e.length),r}};var no=r(4573);const oo=(e,t)=>e?void 0:io.bind(void 0,t),io=function*(e,t){if("string"!=typeof t&&!u(t)&&!no.Buffer.isBuffer(t))throw new TypeError(`The \`${e}\` option's transform must use "objectMode: true" to receive as input: ${typeof t}.`);yield t},so=(e,t)=>e?ao.bind(void 0,t):lo.bind(void 0,t),ao=function*(e,t){co(e,t),yield t},lo=function*(e,t){if(co(e,t),"string"!=typeof t&&!u(t))throw new TypeError(`The \`${e}\` option's function must yield a string or an Uint8Array, not ${typeof t}.`);yield t},co=(e,t)=>{if(null==t)throw new TypeError(`The \`${e}\` option's function must not call \`yield ${t}\`.\nInstead, \`yield\` should either be called with a value, or not be called at all. For example:\n  if (condition) { yield value; }`)},uo=(e,t,r)=>{if(r)return;if(e)return{transform:po.bind(void 0,new TextEncoder)};const n=new c.StringDecoder(t);return{transform:fo.bind(void 0,n),final:mo.bind(void 0,n)}},po=function*(e,t){no.Buffer.isBuffer(t)?yield p(t):"string"==typeof t?yield e.encode(t):yield t},fo=function*(e,t){yield u(t)?e.write(t):t},mo=function*(e){const t=e.end();""!==t&&(yield t)},bo=(0,R.callbackify)((async(e,t,r,n)=>{t.currentIterable=e(...r);try{for await(const e of t.currentIterable)n.push(e)}finally{delete t.currentIterable}})),ho=async function*(e,t,r){if(r===t.length)return void(yield e);const{transform:n=vo}=t[r];for await(const o of n(e))yield*ho(o,t,r+1)},go=async function*(e){for(const[t,{final:r}]of Object.entries(e))yield*yo(r,Number(t),e)},yo=async function*(e,t,r){if(void 0!==e)for await(const n of e())yield*ho(n,r,t+1)},wo=(0,R.callbackify)((async({currentIterable:e},t)=>{if(void 0===e){if(t)throw t}else await(t?e.throw(t):e.return())})),vo=function*(e){yield e},So=(e,t,r,n)=>{try{for(const n of e(...t))r.push(n);n()}catch(e){n(e)}},xo=(e,t)=>[...t.flatMap((t=>[...Do(t,e,0)])),...To(e)],Do=function*(e,t,r){if(r===t.length)return void(yield e);const{transform:n=Io}=t[r];for(const o of n(e))yield*Do(o,t,r+1)},To=function*(e){for(const[t,{final:r}]of Object.entries(e))yield*Eo(r,Number(t),e)},Eo=function*(e,t,r){if(void 0!==e)for(const n of e())yield*Do(n,r,t+1)},Io=function*(e){yield e},Oo=({value:e,value:{transform:t,final:r,writableObjectMode:n,readableObjectMode:o},optionName:i},{encoding:s})=>{const a={},l=No(e,s,i),c=yr(t),d=yr(r),u=c?bo.bind(void 0,ho,a):So.bind(void 0,Do),p=c||d?bo.bind(void 0,go,a):So.bind(void 0,To),f=c||d?wo.bind(void 0,a):void 0;return{stream:new Vn.Transform({writableObjectMode:n,writableHighWaterMark:(0,Vn.getDefaultHighWaterMark)(n),readableObjectMode:o,readableHighWaterMark:(0,Vn.getDefaultHighWaterMark)(o),transform(e,t,r){u([e,l,0],this,r)},flush(e){p([l],this,e)},destroy:f})}},Mo=(e,t,r,n)=>{const o=t.filter((({type:e})=>"generator"===e)),i=n?o.reverse():o;for(const{value:t,optionName:n}of i){const o=No(t,r,n);e=xo(o,e)}return e},No=({transform:e,final:t,binary:r,writableObjectMode:n,readableObjectMode:o,preserveNewlines:i},s,a)=>{const l={};return[{transform:oo(n,a)},uo(r,s,n),zn(r,i,n,l),{transform:e,final:t},{transform:so(o,a)},Zn({binary:r,preserveNewlines:i,readableObjectMode:o,state:l})].filter(Boolean)},Bo=(e,t,r)=>{const{stdioItems:n}=e[t],o=n.filter((({contents:e})=>void 0!==e));if(0===o.length)return;if(0!==t){const[{type:e,optionName:t}]=o;throw new TypeError(`Only the \`stdin\` option, not \`${t}\`, can be ${kr[e]} with synchronous methods.`)}const i=o.map((({contents:e})=>e)).map((e=>$o(e,n)));r.input=g(i)},$o=(e,t)=>{const r=Mo(e,t,"utf8",!0);return jo(r),g(r)},jo=e=>{const t=e.find((e=>"string"!=typeof e&&!u(e)));if(void 0!==t)throw new TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${t}.`)},Co=({stdioItems:e,encoding:t,verboseInfo:{verbose:r},fdNumber:n})=>"all"!==n&&"full"===r[n]&&!tt.has(t)&&Ao(n)&&(e.some((({type:e,value:t})=>"native"===e&&Ro.has(t)))||e.every((({type:e})=>jr.has(e)))),Ao=e=>1===e||2===e,Ro=new Set(["pipe","overlapped"]),Lo=e=>e._readableState.pipes.length>0,ko=(e,{verboseId:t})=>{const r="string"==typeof e?e:(0,R.inspect)(e),n=ne(r).replaceAll("\t"," ".repeat(Uo));q(n,t,"output")},Uo=2,Po=(e,t,r,n)=>{try{return Mo(e,t,r,!1)}catch(t){return n.error=t,e}},Fo=({chunks:e,objectMode:t,encoding:r,lines:n,stripFinalNewline:o,fdNumber:i})=>{if(t)return{serializedResult:e};if("buffer"===r)return{serializedResult:g(e)};const s=((e,t)=>((e,t)=>{if("utf8"===t&&e.every((e=>"string"==typeof e)))return e;const r=new c.StringDecoder(t),n=e.map((e=>"string"==typeof e?m(e):e)).map((e=>r.write(e))),o=r.end();return""===o?n:[...n,o]})(e,t).join(""))(e,r);return n[i]?{serializedResult:s,finalResult:Hn(s,!o[i],t)}:{serializedResult:s}},Go=(e,t,r)=>{for(const{path:n}of t.filter((({type:e})=>Cr.has(e)))){const t="string"==typeof n?n:n.toString();r.has(t)?(0,F.appendFileSync)(n,e):(r.add(t),(0,F.writeFileSync)(n,e))}};var Wo=r(8474);const _o=async e=>{try{return await(0,Wo.once)(e,"exit")}catch{return _o(e)}},Vo=async e=>{const[t,r]=await e;if(!zo(t,r)&&Ho(t,r))throw new je;return[t,r]},zo=(e,t)=>void 0===e&&void 0===t,Ho=(e,t)=>0!==e||null!==t,qo=(e,t,r)=>void 0!==e?e:Ho(t,r)?new je:void 0,Ko=e=>e.node&&!e.ipc?{...e,ipc:!1}:e,Yo=({ipc:e,detached:t,cancelSignal:r})=>{e&&Xo("ipc: true"),t&&Xo("detached: true"),r&&Xo("cancelSignal")},Xo=e=>{throw new TypeError(`The "${e}" option cannot be used with synchronous methods.`)},Qo=({file:e,commandArguments:t,options:r,command:n,escapedCommand:o,verboseInfo:i,fileDescriptors:s,startTime:a})=>{const l=Zo({file:e,commandArguments:t,options:r,command:n,escapedCommand:o,fileDescriptors:s,startTime:a});if(l.failed)return l;const{resultError:c,exitCode:d,signal:f,timedOut:m,isMaxBuffer:b}=(({error:e,status:t,signal:r,output:n},{maxBuffer:o})=>{const i=qo(e,t,r),s="ETIMEDOUT"===i?.code,a=((e,t,r)=>"ENOBUFS"===e?.code&&null!==t&&t.some((e=>null!==e&&e.length>qt(r))))(i,n,o);return{resultError:i,exitCode:t,signal:r,timedOut:s,isMaxBuffer:a}})(l,r),{output:h,error:g=c}=(({fileDescriptors:e,syncResult:{output:t},options:r,isMaxBuffer:n,verboseInfo:o})=>{if(null===t)return{output:Array.from({length:3})};const i={},s=new Set([]);return{output:t.map(((t,a)=>(({result:e,fileDescriptors:t,fdNumber:r,state:n,outputFiles:o,isMaxBuffer:i,verboseInfo:s},{buffer:a,encoding:l,lines:c,stripFinalNewline:d,maxBuffer:u})=>{if(null===e)return;const f=((e,t,r)=>{if(!t)return e;const n=qt(r);return e.length>n?e.slice(0,n):e})(e,i,u),m=p(f),{stdioItems:b,objectMode:h}=t[r],g=Po([m],b,l,n),{serializedResult:y,finalResult:w=y}=Fo({chunks:g,objectMode:h,encoding:l,lines:c,stripFinalNewline:d,fdNumber:r});Co({stdioItems:b,encoding:l,verboseInfo:s,fdNumber:r})&&((e,t)=>{for(const r of e)ko(r,t)})(Hn(y,!1,h),s);const v=a[r]?w:void 0;try{return void 0===n.error&&Go(y,b,o),v}catch(e){return n.error=e,v}})({result:t,fileDescriptors:e,fdNumber:a,state:i,outputFiles:s,isMaxBuffer:n,verboseInfo:o},r))),...i}})({fileDescriptors:s,syncResult:l,options:r,isMaxBuffer:b,verboseInfo:i}),y=h.map(((e,t)=>Wn(e,r,t))),v=Wn((([,e,t],r)=>{if(r.all)return void 0===e?t:void 0===t?e:Array.isArray(e)?Array.isArray(t)?[...e,...t]:[...e,Wn(t,r,"all")]:Array.isArray(t)?[Wn(e,r,"all"),...t]:u(e)&&u(t)?w([e,t]):`${e}${t}`})(h,r),r,"all");return ei({error:g,exitCode:d,signal:f,timedOut:m,isMaxBuffer:b,stdio:y,all:v,options:r,command:n,escapedCommand:o,startTime:a})},Zo=({file:e,commandArguments:t,options:r,command:n,escapedCommand:o,fileDescriptors:i,startTime:s})=>{try{((e,t)=>{for(const r of(e=>new Set(Object.entries(e).filter((([,{direction:e}])=>"input"===e)).map((([e])=>Number(e)))))(e))Bo(e,r,t)})(i,r);const n=Jo(r);return(0,l.spawnSync)(e,t,n)}catch(e){return Qt({error:e,command:n,escapedCommand:o,fileDescriptors:i,options:r,startTime:s,isSync:!0})}},Jo=({encoding:e,maxBuffer:t,...r})=>({...r,encoding:"buffer",maxBuffer:qt(t)}),ei=({error:e,exitCode:t,signal:r,timedOut:n,isMaxBuffer:o,stdio:i,all:s,options:a,command:l,escapedCommand:c,startTime:d})=>void 0===e?Xt({command:l,escapedCommand:c,stdio:i,all:s,options:a,startTime:d}):Zt({error:e,command:l,escapedCommand:c,timedOut:n,isCanceled:!1,isMaxBuffer:o,exitCode:t,signal:r,stdio:i,all:s,options:a,startTime:d,isSync:!0}),ti=()=>{const e=new Vn.PassThrough;return e.end(),e},ri=()=>new Vn.Readable({read(){}}),ni=()=>new Vn.Writable({write(){}}),oi=()=>new Vn.Duplex({read(){},write(){}}),ii=async(e,t,r)=>lr(e,t,r),si=({type:e,optionName:t})=>{throw new TypeError(`The \`${t}\` option cannot be ${kr[e]}.`)},ai={fileNumber:si,generator:Oo,asyncGenerator:Oo,nodeStream:({value:e})=>({stream:e}),webTransform({value:{transform:e,writableObjectMode:t,readableObjectMode:r}}){const n=t||r;return{stream:Vn.Duplex.fromWeb(e,{objectMode:n})}},duplex:({value:{transform:e}})=>({stream:e}),native(){}},li={input:{...ai,fileUrl:({value:e})=>({stream:(0,F.createReadStream)(e)}),filePath:({value:{file:e}})=>({stream:(0,F.createReadStream)(e)}),webStream:({value:e})=>({stream:Vn.Readable.fromWeb(e)}),iterable:({value:e})=>({stream:Vn.Readable.from(e)}),asyncIterable:({value:e})=>({stream:Vn.Readable.from(e)}),string:({value:e})=>({stream:Vn.Readable.from(e)}),uint8Array:({value:e})=>({stream:Vn.Readable.from(no.Buffer.from(e))})},output:{...ai,fileUrl:({value:e})=>({stream:(0,F.createWriteStream)(e)}),filePath:({value:{file:e}})=>({stream:(0,F.createWriteStream)(e)}),webStream:({value:e})=>({stream:Vn.Writable.fromWeb(e)}),iterable:si,asyncIterable:si,string:si,uint8Array:si}};var ci=r(6466);function di(e){if(!Array.isArray(e))throw new TypeError(`Expected an array, got \`${typeof e}\`.`);for(const t of e)hi(t);const t=e.some((({readableObjectMode:e})=>e)),r=ui(e,t),n=new pi({objectMode:t,writableHighWaterMark:r,readableHighWaterMark:r});for(const t of e)n.add(t);return n}const ui=(e,t)=>{if(0===e.length)return(0,Vn.getDefaultHighWaterMark)(t);const r=e.filter((({readableObjectMode:e})=>e===t)).map((({readableHighWaterMark:e})=>e));return Math.max(...r)};class pi extends Vn.PassThrough{#s=new Set([]);#a=new Set([]);#l=new Set([]);#c;#d=Symbol("unpipe");#u=new WeakMap;add(e){if(hi(e),this.#s.has(e))return;this.#s.add(e),this.#c??=fi(this,this.#s,this.#d);const t=gi({passThroughStream:this,stream:e,streams:this.#s,ended:this.#a,aborted:this.#l,onFinished:this.#c,unpipeEvent:this.#d});this.#u.set(e,t),e.pipe(this,{end:!1})}async remove(e){if(hi(e),!this.#s.has(e))return!1;const t=this.#u.get(e);return void 0!==t&&(this.#u.delete(e),e.unpipe(this),await t,!0)}}const fi=async(e,t,r)=>{Oi(e,Mi);const n=new AbortController;try{await Promise.race([mi(e,n),bi(e,t,r,n)])}finally{n.abort(),Oi(e,-Mi)}},mi=async(e,{signal:t})=>{try{await(0,ci.finished)(e,{signal:t,cleanup:!0})}catch(t){throw xi(e,t),t}},bi=async(e,t,r,{signal:n})=>{for await(const[o]of(0,Wo.on)(e,"unpipe",{signal:n}))t.has(o)&&o.emit(r)},hi=e=>{if("function"!=typeof e?.pipe)throw new TypeError(`Expected a readable stream, got: \`${typeof e}\`.`)},gi=async({passThroughStream:e,stream:t,streams:r,ended:n,aborted:o,onFinished:i,unpipeEvent:s})=>{Oi(e,Ni);const a=new AbortController;try{await Promise.race([yi(i,t,a),wi({passThroughStream:e,stream:t,streams:r,ended:n,aborted:o,controller:a}),vi({stream:t,streams:r,ended:n,aborted:o,unpipeEvent:s,controller:a})])}finally{a.abort(),Oi(e,-Ni)}r.size>0&&r.size===n.size+o.size&&(0===n.size&&o.size>0?Ti(e):Si(e))},yi=async(e,t,{signal:r})=>{try{await e,r.aborted||Ti(t)}catch(e){r.aborted||xi(t,e)}},wi=async({passThroughStream:e,stream:t,streams:r,ended:n,aborted:o,controller:{signal:i}})=>{try{await(0,ci.finished)(t,{signal:i,cleanup:!0,readable:!0,writable:!1}),r.has(t)&&n.add(t)}catch(n){if(i.aborted||!r.has(t))return;Di(n)?o.add(t):Ei(e,n)}},vi=async({stream:e,streams:t,ended:r,aborted:n,unpipeEvent:o,controller:{signal:i}})=>{if(await(0,Wo.once)(e,o,{signal:i}),!e.readable)return(0,Wo.once)(i,"abort",{signal:i});t.delete(e),r.delete(e),n.delete(e)},Si=e=>{e.writable&&e.end()},xi=(e,t)=>{Di(t)?Ti(e):Ei(e,t)},Di=e=>"ERR_STREAM_PREMATURE_CLOSE"===e?.code,Ti=e=>{(e.readable||e.writable)&&e.destroy()},Ei=(e,t)=>{e.destroyed||(e.once("error",Ii),e.destroy(t))},Ii=()=>{},Oi=(e,t)=>{const r=e.getMaxListeners();0!==r&&r!==Number.POSITIVE_INFINITY&&e.setMaxListeners(r+t)},Mi=2,Ni=1,Bi=(e,t,r)=>{const n=e.getMaxListeners();0!==n&&n!==Number.POSITIVE_INFINITY&&(e.setMaxListeners(n+t),(0,Wo.addAbortListener)(r,(()=>{e.setMaxListeners(e.getMaxListeners()-t)})))},$i=(e,t)=>{e.pipe(t),ji(e,t),Ai(e,t)},ji=async(e,t)=>{if(!de(e)&&!de(t)){try{await(0,ci.finished)(e,{cleanup:!0,readable:!0,writable:!1})}catch{}Ci(t)}},Ci=e=>{e.writable&&e.end()},Ai=async(e,t)=>{if(!de(e)&&!de(t)){try{await(0,ci.finished)(t,{cleanup:!0,readable:!1,writable:!0})}catch{}Ri(e)}},Ri=e=>{e.readable&&e.destroy()},Li=(e,t,r,n)=>{"output"===r?$i(e.stdio[n],t):$i(t,e.stdio[n]);const o=ki[n];void 0!==o&&(e[o]=t),e.stdio[n]=t},ki=["stdin","stdout","stderr"],Ui=({subprocess:e,stream:t,direction:r,fdNumber:n,pipeGroups:o,controller:i})=>{if(void 0===t)return;Pi(t,i);const[s,a]="output"===r?[t,e.stdio[n]]:[e.stdio[n],t],l=o.get(s)??[];o.set(s,[...l,a])},Pi=(e,{signal:t})=>{de(e)&&Bi(e,Fi,t)},Fi=2,Gi=[];Gi.push("SIGHUP","SIGINT","SIGTERM"),"win32"!==process.platform&&Gi.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),"linux"===process.platform&&Gi.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT");const Wi=e=>!!e&&"object"==typeof e&&"function"==typeof e.removeListener&&"function"==typeof e.emit&&"function"==typeof e.reallyExit&&"function"==typeof e.listeners&&"function"==typeof e.kill&&"number"==typeof e.pid&&"function"==typeof e.on,_i=Symbol.for("signal-exit emitter"),Vi=globalThis,zi=Object.defineProperty.bind(Object);class Hi{emitted={afterExit:!1,exit:!1};listeners={afterExit:[],exit:[]};count=0;id=Math.random();constructor(){if(Vi[_i])return Vi[_i];zi(Vi,_i,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(e,t){this.listeners[e].push(t)}removeListener(e,t){const r=this.listeners[e],n=r.indexOf(t);-1!==n&&(0===n&&1===r.length?r.length=0:r.splice(n,1))}emit(e,t,r){if(this.emitted[e])return!1;this.emitted[e]=!0;let n=!1;for(const o of this.listeners[e])n=!0===o(t,r)||n;return"exit"===e&&(n=this.emit("afterExit",t,r)||n),n}}class qi{}const Ki=globalThis.process,{onExit:Yi,load:Xi,unload:Qi}=(Zi=Wi(Ki)?new class extends qi{#p="win32"===Ki.platform?"SIGINT":"SIGHUP";#f=new Hi;#m;#b;#h;#g={};#y=!1;constructor(e){super(),this.#m=e,this.#g={};for(const t of Gi)this.#g[t]=()=>{const r=this.#m.listeners(t);let{count:n}=this.#f;const o=e;if("object"==typeof o.__signal_exit_emitter__&&"number"==typeof o.__signal_exit_emitter__.count&&(n+=o.__signal_exit_emitter__.count),r.length===n){this.unload();const r=this.#f.emit("exit",null,t),n="SIGHUP"===t?this.#p:t;r||e.kill(e.pid,n)}};this.#h=e.reallyExit,this.#b=e.emit}onExit(e,t){if(!Wi(this.#m))return()=>{};!1===this.#y&&this.load();const r=t?.alwaysLast?"afterExit":"exit";return this.#f.on(r,e),()=>{this.#f.removeListener(r,e),0===this.#f.listeners.exit.length&&0===this.#f.listeners.afterExit.length&&this.unload()}}load(){if(!this.#y){this.#y=!0,this.#f.count+=1;for(const e of Gi)try{const t=this.#g[e];t&&this.#m.on(e,t)}catch(e){}this.#m.emit=(e,...t)=>this.#w(e,...t),this.#m.reallyExit=e=>this.#v(e)}}unload(){this.#y&&(this.#y=!1,Gi.forEach((e=>{const t=this.#g[e];if(!t)throw new Error("Listener not defined for signal: "+e);try{this.#m.removeListener(e,t)}catch(e){}})),this.#m.emit=this.#b,this.#m.reallyExit=this.#h,this.#f.count-=1)}#v(e){return Wi(this.#m)?(this.#m.exitCode=e||0,this.#f.emit("exit",this.#m.exitCode,null),this.#h.call(this.#m,this.#m.exitCode)):0}#w(e,...t){const r=this.#b;if("exit"===e&&Wi(this.#m)){"number"==typeof t[0]&&(this.#m.exitCode=t[0]);const n=r.call(this.#m,e,...t);return this.#f.emit("exit",this.#m.exitCode,null),n}return r.call(this.#m,e,...t)}}(Ki):new class extends qi{onExit(){return()=>{}}load(){}unload(){}},{onExit:(e,t)=>Zi.onExit(e,t),load:()=>Zi.load(),unload:()=>Zi.unload()});var Zi;const Ji=(e,t,r,...n)=>{if(Array.isArray(r))return{destination:t(es,e)(r,...n),pipeOptions:e};if("string"==typeof r||r instanceof URL){if(Object.keys(e).length>0)throw new TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');const[o,i,s]=a(r,...n);return{destination:t(es)(o,i,s),pipeOptions:s}}if(nn.has(r)){if(Object.keys(e).length>0)throw new TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");return{destination:r,pipeOptions:n[0]}}throw new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${r}`)},es=({options:e})=>({options:{...e,stdin:"pipe",piped:!0}}),ts=({error:e,fileDescriptors:t,sourceOptions:r,startTime:n})=>Qt({error:e,command:rs,escapedCommand:rs,fileDescriptors:t,options:r,startTime:n,isSync:!1}),rs="source.pipe(destination)",ns=async e=>{const[{status:t,reason:r,value:n=r},{status:o,reason:i,value:s=i}]=await e;if(s.pipedFrom.includes(n)||s.pipedFrom.push(n),"rejected"===o)throw s;if("rejected"===t)throw n;return s},os=new WeakMap,is=(e,t)=>void 0===e?[]:[ss(e,t)],ss=async(e,{sourceStream:t,mergedStream:r,fileDescriptors:n,sourceOptions:o,startTime:i})=>{await(0,R.aborted)(e,t),await r.remove(t);const s=new Error("Pipe canceled by `unpipeSignal` option.");throw ts({error:s,fileDescriptors:n,sourceOptions:o,startTime:i})},as=(e,...t)=>{if(n(t[0]))return as.bind(void 0,{...e,boundOptions:{...e.boundOptions,...t[0]}});const{destination:r,...o}=(({source:e,sourcePromise:t,boundOptions:r,createNested:n},...o)=>{const i=te(),{destination:s,destinationStream:a,destinationError:l,from:c,unpipeSignal:d}=((e,t,r)=>{try{const{destination:n,pipeOptions:{from:o,to:i,unpipeSignal:s}={}}=Ji(e,t,...r);return{destination:n,destinationStream:tn(n,i),from:o,unpipeSignal:s}}catch(e){return{destinationError:e}}})(r,n,o),{sourceStream:u,sourceError:p}=((e,t)=>{try{return{sourceStream:rn(e,t)}}catch(e){return{sourceError:e}}})(e,c),{options:f,fileDescriptors:m}=nn.get(e);return{sourcePromise:t,sourceStream:u,sourceOptions:f,sourceError:p,destination:s,destinationStream:a,destinationError:l,unpipeSignal:d,fileDescriptors:m,startTime:i}})(e,...t),i=ls({...o,destination:r});return i.pipe=as.bind(void 0,{...e,source:r,sourcePromise:i,boundOptions:{}}),i},ls=async({sourcePromise:e,sourceStream:t,sourceOptions:r,sourceError:n,destination:o,destinationStream:i,destinationError:s,unpipeSignal:a,fileDescriptors:l,startTime:c})=>{const d=cs(e,o);(({sourceStream:e,sourceError:t,destinationStream:r,destinationError:n,fileDescriptors:o,sourceOptions:i,startTime:s})=>{const a=(({sourceStream:e,sourceError:t,destinationStream:r,destinationError:n})=>void 0!==t&&void 0!==n?n:void 0!==n?(Ri(e),n):void 0!==t?(Ci(r),t):void 0)({sourceStream:e,sourceError:t,destinationStream:r,destinationError:n});if(void 0!==a)throw ts({error:a,fileDescriptors:o,sourceOptions:i,startTime:s})})({sourceStream:t,sourceError:n,destinationStream:i,destinationError:s,fileDescriptors:l,sourceOptions:r,startTime:c});const u=new AbortController;try{const e=((e,t,r)=>{const n=os.has(t)?((e,t)=>{const r=os.get(t);return r.add(e),r})(e,t):((e,t)=>{const r=di([e]);return $i(r,t),os.set(t,r),r})(e,t);return Bi(e,2,r.signal),Bi(t,1,r.signal),(async e=>{try{await(0,ci.finished)(e,{cleanup:!0,readable:!1,writable:!0})}catch{}os.delete(e)})(t),n})(t,i,u);return await Promise.race([ns(d),...is(a,{sourceStream:t,mergedStream:e,sourceOptions:r,fileDescriptors:l,startTime:c})])}finally{u.abort()}},cs=(e,t)=>Promise.allSettled([e,t]),ds=e=>e,us=()=>{},ps=({contents:e})=>e,fs=e=>{throw new Error(`Streams in object mode are not supported: ${String(e)}`)},ms=e=>e.length,bs={init:()=>({contents:[]}),convertChunk:{string:ds,buffer:ds,arrayBuffer:ds,dataView:ds,typedArray:ds,others:ds},getSize:()=>1,truncateChunk:us,addChunk:(e,{contents:t})=>(t.push(e),t),getFinalChunk:us,finalize:ps},hs=new TextEncoder,gs=e=>new Uint8Array(e),ys=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),ws=e=>vs**Math.ceil(Math.log(e)/Math.log(vs)),vs=2,Ss=()=>"resize"in ArrayBuffer.prototype,xs={init:()=>({contents:new ArrayBuffer(0)}),convertChunk:{string:e=>hs.encode(e),buffer:gs,arrayBuffer:gs,dataView:ys,typedArray:ys,others:fs},getSize:ms,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t,length:r},n)=>{const o=Ss()?((e,t)=>{if(t<=e.maxByteLength)return e.resize(t),e;const r=new ArrayBuffer(t,{maxByteLength:ws(t)});return new Uint8Array(r).set(new Uint8Array(e),0),r})(t,n):((e,t)=>{if(t<=e.byteLength)return e;const r=new ArrayBuffer(ws(t));return new Uint8Array(r).set(new Uint8Array(e),0),r})(t,n);return new Uint8Array(o).set(e,r),o},getFinalChunk:us,finalize:({contents:e,length:t})=>Ss()?e:e.slice(0,t)},Ds=(e,{textDecoder:t})=>t.decode(e,{stream:!0}),Ts={init:()=>({contents:"",textDecoder:new TextDecoder}),convertChunk:{string:ds,buffer:Ds,arrayBuffer:Ds,dataView:Ds,typedArray:Ds,others:fs},getSize:ms,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t})=>t+e,getFinalChunk:({textDecoder:e})=>{const t=e.decode();return""===t?void 0:t},finalize:ps},Es=({subprocessStdout:e,subprocess:t,binary:r,shouldEncode:n,encoding:o,preserveNewlines:i})=>{const s=new AbortController;return Is(t,s),Ns({stream:e,controller:s,binary:r,shouldEncode:!e.readableObjectMode&&n,encoding:o,shouldSplit:!e.readableObjectMode,preserveNewlines:i})},Is=async(e,t)=>{try{await e}catch{}finally{t.abort()}},Os=({stream:e,onStreamEnd:t,lines:r,encoding:n,stripFinalNewline:o,allMixed:i})=>{const s=new AbortController;Ms(t,s,e);const a=e.readableObjectMode&&!i;return Ns({stream:e,controller:s,binary:"buffer"===n,shouldEncode:!a,encoding:n,shouldSplit:!a&&r,preserveNewlines:!o})},Ms=async(e,t,r)=>{try{await e}catch{r.destroy()}finally{t.abort()}},Ns=({stream:e,controller:t,binary:r,shouldEncode:n,encoding:o,shouldSplit:i,preserveNewlines:s})=>{const a=(0,Wo.on)(e,"data",{signal:t.signal,highWaterMark:$s,highWatermark:$s});return js({onStdoutChunk:a,controller:t,binary:r,shouldEncode:n,encoding:o,shouldSplit:i,preserveNewlines:s})},Bs=(0,Vn.getDefaultHighWaterMark)(!0),$s=Bs,js=async function*({onStdoutChunk:e,controller:t,binary:r,shouldEncode:n,encoding:o,shouldSplit:i,preserveNewlines:s}){const a=Cs({binary:r,shouldEncode:n,encoding:o,shouldSplit:i,preserveNewlines:s});try{for await(const[t]of e)yield*Do(t,a,0)}catch(e){if(!t.signal.aborted)throw e}finally{yield*To(a)}},Cs=({binary:e,shouldEncode:t,encoding:r,shouldSplit:n,preserveNewlines:o})=>[uo(e,r,!t),zn(e,o,!n,{})].filter(Boolean),As=async({stream:e,onStreamEnd:t,fdNumber:r,encoding:n,buffer:o,maxBuffer:i,lines:s,allMixed:a,stripFinalNewline:l,verboseInfo:c,streamInfo:{fileDescriptors:d}})=>{if(Co({stdioItems:d[r]?.stdioItems,encoding:n,verboseInfo:c,fdNumber:r})&&(async(e,t,r)=>{for await(const n of e)Lo(t)||ko(n,r)})(Os({stream:e,onStreamEnd:t,lines:!0,encoding:n,stripFinalNewline:!0,allMixed:a}),e,c),!o)return void await Rs(e);const u=_n(l,r),p=Os({stream:e,onStreamEnd:t,lines:s,encoding:n,stripFinalNewline:u,allMixed:a});return Ls({stream:e,iterable:p,fdNumber:r,encoding:n,maxBuffer:i,lines:s})},Rs=async e=>{await(0,$e.setImmediate)(),null===e.readableFlowing&&e.resume()},Ls=async({stream:e,stream:{readableObjectMode:t},iterable:r,fdNumber:n,encoding:o,maxBuffer:i,lines:s})=>{try{return t||s?await async function(e,t){return Ft(e,bs,t)}(r,{maxBuffer:i}):"buffer"===o?new Uint8Array(await async function(e,t){return Ft(e,xs,t)}(r,{maxBuffer:i})):await async function(e,t){return Ft(e,Ts,t)}(r,{maxBuffer:i})}catch(r){return Us((({error:e,stream:t,readableObjectMode:r,lines:n,encoding:o,fdNumber:i})=>{if(!(e instanceof Ht))throw e;if("all"===i)return e;const s=((e,t,r)=>e?"objects":t?"lines":"buffer"===r?"bytes":"characters")(r,n,o);throw e.maxBufferInfo={fdNumber:i,unit:s},t.destroy(),e})({error:r,stream:e,readableObjectMode:t,lines:s,encoding:o,fdNumber:n}))}},ks=async e=>{try{return await e}catch(e){return Us(e)}},Us=({bufferedData:e})=>{return t=e,"[object ArrayBuffer]"===d.call(t)?new Uint8Array(e):e;var t},Ps=async(e,t,r,{isSameDirection:n,stopOnExit:o=!1}={})=>{const i=Fs(e,r),s=new AbortController;try{await Promise.race([...o?[r.exitPromise]:[],(0,ci.finished)(e,{cleanup:!0,signal:s.signal})])}catch(e){i.stdinCleanedUp||_s(e,t,r,n)}finally{s.abort()}},Fs=(e,{originalStreams:[t],subprocess:r})=>{const n={stdinCleanedUp:!1};return e===t&&Gs(e,r,n),n},Gs=(e,t,r)=>{const{_destroy:n}=e;e._destroy=(...o)=>{Ws(t,r),n.call(e,...o)}},Ws=({exitCode:e,signalCode:t},r)=>{null===e&&null===t||(r.stdinCleanedUp=!0)},_s=(e,t,r,n)=>{if(!Vs(e,t,r,n))throw e},Vs=(e,t,r,n=!0)=>r.propagating?qs(e)||Hs(e):(r.propagating=!0,zs(r,t)===n?qs(e):Hs(e)),zs=({fileDescriptors:e},t)=>"all"!==t&&"input"===e[t].direction,Hs=e=>"ERR_STREAM_PREMATURE_CLOSE"===e?.code,qs=e=>"EPIPE"===e?.code,Ks=async({stream:e,fdNumber:t,encoding:r,buffer:n,maxBuffer:o,lines:i,allMixed:s,stripFinalNewline:a,verboseInfo:l,streamInfo:c})=>{if(!e)return;const d=Ps(e,t,c);if(zs(c,t))return void await d;const[u]=await Promise.all([As({stream:e,onStreamEnd:d,fdNumber:t,encoding:r,buffer:n,maxBuffer:o,lines:i,allMixed:s,stripFinalNewline:a,verboseInfo:l,streamInfo:c}),d]);return u},Ys=({stdout:e,stderr:t,all:r},[,n,o])=>{const i=n||o;return i?n?o?{stream:r,buffer:i}:{stream:e,buffer:i}:{stream:t,buffer:i}:{stream:r,buffer:i}},Xs=({all:e,stdout:t,stderr:r})=>e&&t&&r&&t.readableObjectMode!==r.readableObjectMode,Qs=(e,t,r)=>e.map(((e,n)=>e===t.stdio[n]?void 0:Ps(e,n,r))),Zs=(e,t)=>e.flatMap((({stdioItems:e},r)=>e.filter((({value:e,stream:t=e})=>Tt(t,{checkOpen:!1})&&!de(t))).map((({type:e,value:n,stream:o=n})=>Ps(o,r,t,{isSameDirection:jr.has(e),stopOnExit:"native"===e}))))),Js=async(e,{signal:t})=>{const[r]=await(0,Wo.once)(e,"error",{signal:t});throw r},ea=()=>{const e={},t=new Promise(((t,r)=>{Object.assign(e,{resolve:t,reject:r})}));return Object.assign(t,e)},ta=(e,t,r)=>{const n=e[r];n.has(t)||n.set(t,[]);const o=n.get(t),i=ea();return o.push(i),{resolve:i.resolve.bind(i),promises:o}},ra=async({resolve:e,promises:t},r)=>{e();const[n]=await Promise.race([Promise.allSettled([!0,r]),Promise.all([!1,...t])]);return!n},na=async e=>{if(void 0!==e)try{await oa(e)}catch{}},oa=async e=>{await(0,ci.finished)(e,{cleanup:!0,readable:!1,writable:!0})},ia=async e=>{await(0,ci.finished)(e,{cleanup:!0,readable:!0,writable:!1})},sa=async(e,t)=>{if(await e,t)throw t},aa=(e,t,r)=>{r&&!Hs(r)?e.destroy(r):t&&e.destroy()},la=({subprocess:e,concurrentStreams:t,encoding:r},{from:n,binary:o=!0,preserveNewlines:i=!0}={})=>{const s=o||tt.has(r),{subprocessStdout:a,waitReadableDestroy:l}=ca(e,n,t),{readableEncoding:c,readableObjectMode:d,readableHighWaterMark:u}=da(a,s),{read:p,onStdoutDataDone:f}=ua({subprocessStdout:a,subprocess:e,binary:s,encoding:r,preserveNewlines:i}),m=new Vn.Readable({read:p,destroy:(0,R.callbackify)(ma.bind(void 0,{subprocessStdout:a,subprocess:e,waitReadableDestroy:l})),highWaterMark:u,objectMode:d,encoding:c});return fa({subprocessStdout:a,onStdoutDataDone:f,readable:m,subprocess:e}),m},ca=(e,t,r)=>{const n=rn(e,t);return{subprocessStdout:n,waitReadableDestroy:ta(r,n,"readableDestroy")}},da=({readableEncoding:e,readableObjectMode:t,readableHighWaterMark:r},n)=>n?{readableEncoding:e,readableObjectMode:t,readableHighWaterMark:r}:{readableEncoding:e,readableObjectMode:!0,readableHighWaterMark:Bs},ua=({subprocessStdout:e,subprocess:t,binary:r,encoding:n,preserveNewlines:o})=>{const i=ea(),s=Es({subprocessStdout:e,subprocess:t,binary:r,shouldEncode:!r,encoding:n,preserveNewlines:o});return{read(){pa(this,s,i)},onStdoutDataDone:i}},pa=async(e,t,r)=>{try{const{value:n,done:o}=await t.next();o?r.resolve():e.push(n)}catch{}},fa=async({subprocessStdout:e,onStdoutDataDone:t,readable:r,subprocess:n,subprocessStdin:o})=>{try{await ia(e),await n,await na(o),await t,r.readable&&r.push(null)}catch(e){await na(o),ba(r,e)}},ma=async({subprocessStdout:e,subprocess:t,waitReadableDestroy:r},n)=>{await ra(r,t)&&(ba(e,n),await sa(t,n))},ba=(e,t)=>{aa(e,e.readable,t)},ha=({subprocess:e,concurrentStreams:t},{to:r}={})=>{const{subprocessStdin:n,waitWritableFinal:o,waitWritableDestroy:i}=ga(e,r,t),s=new Vn.Writable({...ya(n,e,o),destroy:(0,R.callbackify)(xa.bind(void 0,{subprocessStdin:n,subprocess:e,waitWritableFinal:o,waitWritableDestroy:i})),highWaterMark:n.writableHighWaterMark,objectMode:n.writableObjectMode});return Sa(n,s),s},ga=(e,t,r)=>{const n=tn(e,t);return{subprocessStdin:n,waitWritableFinal:ta(r,n,"writableFinal"),waitWritableDestroy:ta(r,n,"writableDestroy")}},ya=(e,t,r)=>({write:wa.bind(void 0,e),final:(0,R.callbackify)(va.bind(void 0,e,t,r))}),wa=(e,t,r,n)=>{e.write(t,r)?n():e.once("drain",n)},va=async(e,t,r)=>{await ra(r,t)&&(e.writable&&e.end(),await t)},Sa=async(e,t,r)=>{try{await oa(e),t.writable&&t.end()}catch(e){await(async e=>{if(void 0!==e)try{await ia(e)}catch{}})(r),Da(t,e)}},xa=async({subprocessStdin:e,subprocess:t,waitWritableFinal:r,waitWritableDestroy:n},o)=>{await ra(r,t),await ra(n,t)&&(Da(e,o),await sa(t,o))},Da=(e,t)=>{aa(e,e.writable,t)},Ta=({subprocess:e,concurrentStreams:t,encoding:r},{from:n,to:o,binary:i=!0,preserveNewlines:s=!0}={})=>{const a=i||tt.has(r),{subprocessStdout:l,waitReadableDestroy:c}=ca(e,n,t),{subprocessStdin:d,waitWritableFinal:u,waitWritableDestroy:p}=ga(e,o,t),{readableEncoding:f,readableObjectMode:m,readableHighWaterMark:b}=da(l,a),{read:h,onStdoutDataDone:g}=ua({subprocessStdout:l,subprocess:e,binary:a,encoding:r,preserveNewlines:s}),y=new Vn.Duplex({read:h,...ya(d,e,u),destroy:(0,R.callbackify)(Ea.bind(void 0,{subprocessStdout:l,subprocessStdin:d,subprocess:e,waitReadableDestroy:c,waitWritableFinal:u,waitWritableDestroy:p})),readableHighWaterMark:b,writableHighWaterMark:d.writableHighWaterMark,readableObjectMode:m,writableObjectMode:d.writableObjectMode,encoding:f});return fa({subprocessStdout:l,onStdoutDataDone:g,readable:y,subprocess:e,subprocessStdin:d}),Sa(d,y,l),y},Ea=async({subprocessStdout:e,subprocessStdin:t,subprocess:r,waitReadableDestroy:n,waitWritableFinal:o,waitWritableDestroy:i},s)=>{await Promise.all([ma({subprocessStdout:e,subprocess:r,waitReadableDestroy:n},s),xa({subprocessStdin:t,subprocess:r,waitWritableFinal:o,waitWritableDestroy:i},s)])},Ia=(e,t,{from:r,binary:n=!1,preserveNewlines:o=!1}={})=>{const i=n||tt.has(t),s=rn(e,r),a=Es({subprocessStdout:s,subprocess:e,binary:i,shouldEncode:!0,encoding:t,preserveNewlines:o});return Oa(a,s,e)},Oa=async function*(e,t,r){try{yield*e}finally{t.readable&&t.destroy(),await r}},Ma=(e,{encoding:t})=>{const r={readableDestroy:new WeakMap,writableFinal:new WeakMap,writableDestroy:new WeakMap};e.readable=la.bind(void 0,{subprocess:e,concurrentStreams:r,encoding:t}),e.writable=ha.bind(void 0,{subprocess:e,concurrentStreams:r}),e.duplex=Ta.bind(void 0,{subprocess:e,concurrentStreams:r,encoding:t}),e.iterable=Ia.bind(void 0,e,t),e[Symbol.asyncIterator]=Ia.bind(void 0,e,t,{})},Na=(async()=>{})().constructor.prototype,Ba=["then","catch","finally"].map((e=>[e,Reflect.getOwnPropertyDescriptor(Na,e)])),$a=(e,t,r)=>{const{command:n,escapedCommand:o,startTime:i,verboseInfo:s}=Ie(e,t,r);try{const{file:a,commandArguments:l,options:c}=st(e,t,r),d=ja(c),u=((e,t)=>Tn(li,e,0,!1))(d);return{file:a,commandArguments:l,command:n,escapedCommand:o,startTime:i,verboseInfo:s,options:d,fileDescriptors:u}}catch(e){throw or(e,i,s),e}},ja=({timeout:e,signal:t,cancelSignal:r,...n})=>{if(void 0!==t)throw new TypeError('The "signal" option has been renamed to "cancelSignal" instead.');return{...n,timeoutDuration:e,signal:r}},Ca=({file:e,commandArguments:t,options:r,startTime:n,verboseInfo:o,command:i,escapedCommand:s,fileDescriptors:a})=>{let c;try{c=(0,l.spawn)(e,t,r)}catch(e){return(({error:e,command:t,escapedCommand:r,fileDescriptors:n,options:o,startTime:i,verboseInfo:s})=>{Ln(n);const a=new l.ChildProcess;((e,t)=>{const r=ti(),n=ti(),o=ti(),i=Array.from({length:t.length-3},ti),s=ti(),a=[r,n,o,...i];Object.assign(e,{stdin:r,stdout:n,stderr:o,all:s,stdio:a})})(a,n),Object.assign(a,{readable:ri,writable:ni,duplex:oi});const c=Qt({error:e,command:t,escapedCommand:r,fileDescriptors:n,options:o,startTime:i,isSync:!1});return{subprocess:a,promise:ii(c,s,o)}})({error:e,command:i,escapedCommand:s,fileDescriptors:a,options:r,startTime:n,verboseInfo:o})}const d=new AbortController;(0,Wo.setMaxListeners)(Number.POSITIVE_INFINITY,d.signal);const u=[...c.stdio];((e,t,r)=>{const n=new Map;for(const[o,{stdioItems:i,direction:s}]of Object.entries(t)){for(const{stream:t}of i.filter((({type:e})=>jr.has(e))))Li(e,t,s,o);for(const{stream:t}of i.filter((({type:e})=>!jr.has(e))))Ui({subprocess:e,stream:t,direction:s,fdNumber:o,pipeGroups:n,controller:r})}for(const[e,t]of n.entries()){const r=1===t.length?t[0]:di(t);$i(r,e)}})(c,a,d),((e,{cleanup:t,detached:r},{signal:n})=>{if(!t||r)return;const o=Yi((()=>{e.kill()}));(0,Wo.addAbortListener)(n,(()=>{o()}))})(c,r,d);const p=ea();return c.kill=qe.bind(void 0,{kill:c.kill.bind(c),options:r,onInternalError:p,controller:d}),c.all=(({stdout:e,stderr:t},{all:r})=>r&&(e||t)?di([e,t].filter(Boolean)):void 0)(c,r),Ma(c,r),{subprocess:c,promise:Aa({subprocess:c,options:r,startTime:n,verboseInfo:o,fileDescriptors:a,originalStreams:u,command:i,escapedCommand:s,onInternalError:p,controller:d})}},Aa=async({subprocess:e,options:t,startTime:r,verboseInfo:n,fileDescriptors:o,originalStreams:i,command:s,escapedCommand:a,onInternalError:l,controller:c})=>{const d={timedOut:!1},[u,[p,f],m,b]=await(async({subprocess:e,options:{encoding:t,buffer:r,maxBuffer:n,lines:o,timeoutDuration:i,stripFinalNewline:s},context:a,verboseInfo:l,fileDescriptors:c,originalStreams:d,onInternalError:u,controller:p})=>{const f=(async e=>{const[t,r]=await Promise.allSettled([(0,Wo.once)(e,"spawn"),(0,Wo.once)(e,"exit")]);return"rejected"===t.status?[]:"rejected"===r.status?_o(e):r.value})(e),m={originalStreams:d,fileDescriptors:c,subprocess:e,exitPromise:f,propagating:!1},b=(({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:o,stripFinalNewline:i,verboseInfo:s,streamInfo:a})=>e.stdio.map(((e,l)=>Ks({stream:e,fdNumber:l,encoding:t,buffer:r[l],maxBuffer:n[l],lines:o[l],allMixed:!1,stripFinalNewline:i,verboseInfo:s,streamInfo:a}))))({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:o,stripFinalNewline:s,verboseInfo:l,streamInfo:m}),h=(({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:o,stripFinalNewline:i,verboseInfo:s,streamInfo:a})=>Ks({...Ys(e,r),fdNumber:"all",encoding:t,maxBuffer:n[1]+n[2],lines:o[1]||o[2],allMixed:Xs(e),stripFinalNewline:i,verboseInfo:s,streamInfo:a}))({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:o,stripFinalNewline:s,verboseInfo:l,streamInfo:m}),g=Qs(d,e,m),y=Zs(c,m);try{return await Promise.race([Promise.all([{},Vo(f),Promise.all(b),h,...g,...y]),u,Js(e,p),...Ze(e,i,a,p)])}catch(e){return Promise.all([{error:e},f,Promise.all(b.map((e=>ks(e)))),ks(h),Promise.allSettled(g),Promise.allSettled(y)])}})({subprocess:e,options:t,context:d,verboseInfo:n,fileDescriptors:o,originalStreams:i,onInternalError:l,controller:c});c.abort(),l.resolve();const h=m.map(((e,r)=>Wn(e,t,r))),g=Wn(b,t,"all"),y=Ra({errorInfo:u,exitCode:p,signal:f,stdio:h,all:g,context:d,options:t,command:s,escapedCommand:a,startTime:r});return lr(y,n,t)},Ra=({errorInfo:e,exitCode:t,signal:r,stdio:n,all:o,context:i,options:s,command:a,escapedCommand:l,startTime:c})=>"error"in e?Zt({error:e.error,command:a,escapedCommand:l,timedOut:i.timedOut,isCanceled:!0===s.signal?.aborted,isMaxBuffer:e.error instanceof Ht,exitCode:t,signal:r,stdio:n,all:o,options:s,startTime:c,isSync:!1}):Xt({command:a,escapedCommand:l,stdio:n,all:o,options:s,startTime:c}),La=(e,t)=>{const r=Object.fromEntries(Object.entries(t).map((([t,r])=>[t,ka(t,e[t],r)])));return{...e,...r}},ka=(e,t,r)=>Ua.has(e)&&n(t)&&n(r)?{...t,...r}:r,Ua=new Set(["env",...Ee]),Pa=(e,t,r,n)=>{const o=(e,t,n)=>Pa(e,t,r,n),i=(...i)=>Fa({mapArguments:e,deepOptions:r,boundOptions:t,setBoundExeca:n,createNested:o},...i);return void 0!==n&&n(i,o,t),i},Fa=({mapArguments:e,deepOptions:t={},boundOptions:r={},setBoundExeca:o,createNested:i},s,...a)=>{if(n(s))return i(e,La(r,s),o);const{file:l,commandArguments:c,options:d,isSync:u}=Ga({mapArguments:e,firstArgument:s,nextArguments:a,deepOptions:t,boundOptions:r});return u?((e,t,r)=>{const{file:n,commandArguments:o,command:i,escapedCommand:s,startTime:a,verboseInfo:l,options:c,fileDescriptors:d}=((e,t,r)=>{const{command:n,escapedCommand:o,startTime:i,verboseInfo:s}=Ie(e,t,r);try{const a=Ko(r),{file:l,commandArguments:c,options:d}=st(e,t,a);Yo(d);const u=((e,t)=>Tn(Gn,e,0,!0))(d);return{file:l,commandArguments:c,command:n,escapedCommand:o,startTime:i,verboseInfo:s,options:d,fileDescriptors:u}}catch(e){throw or(e,i,s),e}})(e,t,r),u=Qo({file:n,commandArguments:o,options:c,command:i,escapedCommand:s,verboseInfo:l,fileDescriptors:d,startTime:a});return lr(u,l,c)})(l,c,d):((e,t,r,n)=>{const{file:o,commandArguments:i,command:s,escapedCommand:a,startTime:l,verboseInfo:c,options:d,fileDescriptors:u}=$a(e,t,r),{subprocess:p,promise:f}=Ca({file:o,commandArguments:i,options:d,startTime:l,verboseInfo:c,command:s,escapedCommand:a,fileDescriptors:u});return p.pipe=as.bind(void 0,{source:p,sourcePromise:f,boundOptions:{},createNested:n}),((e,t)=>{for(const[r,n]of Ba){const o=n.value.bind(t);Reflect.defineProperty(e,r,{...n,value:o})}})(p,f),nn.set(p,{options:d,fileDescriptors:u}),p})(l,c,d,i)},Ga=({mapArguments:e,firstArgument:t,nextArguments:r,deepOptions:n,boundOptions:o})=>{const i=(s=t,Array.isArray(s)&&Array.isArray(s.raw)?((e,t)=>{let r=[];for(const[n,o]of e.entries())r=S({templates:e,expressions:t,tokens:r,index:n,template:o});if(0===r.length)throw new TypeError("Template script must not be empty");const[n,...o]=r;return[n,o,{}]})(t,r):[t,...r]);var s;const[l,c,d]=a(...i),u=La(La(n,o),d),{file:p=l,commandArguments:f=c,options:m=u,isSync:b=!1}=e({file:l,commandArguments:c,options:u});return{file:p,commandArguments:f,options:m,isSync:b}},Wa=(e,t)=>{if(t.length>0)throw new TypeError(`The command and its arguments must be passed as a single string: ${e} ${t}.`);const r=[];for(const t of e.trim().split(_a)){const e=r.at(-1);e&&e.endsWith("\\")?r[r.length-1]=`${e.slice(0,-1)} ${t}`:r.push(t)}const[n,...o]=r;return{file:n,commandArguments:o}},_a=/ +/g,Va=({options:e})=>({...za(e),isSync:!0}),za=e=>({options:{...Ha(e),...e}}),Ha=({input:e,inputFile:t,stdio:r})=>void 0===e&&void 0===t&&void 0===r?{stdin:"inherit"}:{},qa=Pa((()=>({})));Pa((()=>({isSync:!0}))),Pa((({file:e,commandArguments:t})=>Wa(e,t))),Pa((({file:e,commandArguments:t})=>({...Wa(e,t),isSync:!0}))),Pa((({options:e})=>{if(!1===e.node)throw new TypeError('The "node" option cannot be false with `execaNode()`.');return{options:{...e,node:!0}}})),Pa((({options:e})=>za(e)),{},{preferLocal:!0},((e,t,r)=>{e.sync=t(Va,r),e.s=e.sync}))}};
//# sourceMappingURL=495.main.js.map