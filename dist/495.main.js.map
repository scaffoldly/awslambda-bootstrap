{"version":3,"file":"495.main.js","mappings":"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","sources":["webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/lib/enoent.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/lib/parse.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/lib/util/escape.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/lib/util/readShebang.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/lib/util/resolveCommand.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/node_modules/isexe/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/node_modules/isexe/mode.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/node_modules/isexe/windows.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/cross-spawn/node_modules/which/which.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/path-key/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/shebang-command/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/shebang-regex/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/is-plain-obj/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/file-url.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/parameters.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/utils/uint-array.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/template.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/yoctocolors/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/verbose/info.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/figures/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/is-unicode-supported/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/verbose/log.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/return/duration.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/escape.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/utils/standard-stream.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/specific.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/command.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/verbose/start.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/npm-run-path/node_modules/path-key/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/npm-run-path/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/return/final-error.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/terminate/signal.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/terminate/kill.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/terminate/timeout.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/encoding-option.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/cwd.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/options.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/node.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/human-signals/build/src/realtime.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/human-signals/build/src/core.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/human-signals/build/src/signals.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/human-signals/build/src/main.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/strip-final-newline/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/is-stream/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/@sec-ant/readable-stream/dist/ponyfill/asyncIterator.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/get-stream/source/stream.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/get-stream/source/contents.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/max-buffer.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/return/message.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/return/result.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/parse-ms/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/pretty-ms/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/verbose/error.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/verbose/complete.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/return/reject.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/type.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/object-mode.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/normalize.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/direction.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/stdio-option.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/arguments/fd-options.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/native.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/input-option.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/duplicate.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/handle.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/handle-sync.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/strip-newline.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/split.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/validate.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/encoding-transform.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/run-async.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/run-sync.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/transform/generator.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/input-sync.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/verbose/output.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/output-sync.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/resolve/exit-async.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/resolve/exit-sync.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/main-sync.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/resolve/all-sync.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/return/early-error.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/stdio/handle-async.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/@sindresorhus/merge-streams/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/utils/max-listeners.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/pipeline.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/output-async.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/signal-exit/dist/mjs/signals.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/signal-exit/dist/mjs/index.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/terminate/cleanup.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/pipe/pipe-arguments.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/pipe/throw.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/pipe/sequence.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/pipe/streaming.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/pipe/abort.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/pipe/setup.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/get-stream/source/utils.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/get-stream/source/array.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/get-stream/source/array-buffer.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/get-stream/source/string.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/iterate.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/io/contents.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/resolve/wait-stream.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/resolve/stdio.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/resolve/all-async.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/resolve/wait-subprocess.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/utils/deferred.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/convert/concurrent.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/convert/shared.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/convert/readable.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/convert/writable.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/convert/duplex.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/convert/iterable.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/convert/add.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/promise.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/main-async.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/bind.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/create.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/command.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/lib/methods/script.js","webpack://@scaffoldly/awslambda-bootstrap/./node_modules/execa/index.js"],"sourcesContent":["'use strict';\n\nconst cp = require('child_process');\nconst parse = require('./lib/parse');\nconst enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nfunction spawnSync(command, args, options) {\n    // Parse the arguments\n    const parsed = parse(command, args, options);\n\n    // Spawn the child process\n    const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);\n\n    // Analyze if the command does not exist, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);\n\n    return result;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports.sync = spawnSync;\n\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n","'use strict';\n\nconst isWin = process.platform === 'win32';\n\nfunction notFoundError(original, syscall) {\n    return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {\n        code: 'ENOENT',\n        errno: 'ENOENT',\n        syscall: `${syscall} ${original.command}`,\n        path: original.command,\n        spawnargs: original.args,\n    });\n}\n\nfunction hookChildProcess(cp, parsed) {\n    if (!isWin) {\n        return;\n    }\n\n    const originalEmit = cp.emit;\n\n    cp.emit = function (name, arg1) {\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            const err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments); // eslint-disable-line prefer-rest-params\n    };\n}\n\nfunction verifyENOENT(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawn');\n    }\n\n    return null;\n}\n\nfunction verifyENOENTSync(status, parsed) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, 'spawnSync');\n    }\n\n    return null;\n}\n\nmodule.exports = {\n    hookChildProcess,\n    verifyENOENT,\n    verifyENOENTSync,\n    notFoundError,\n};\n","'use strict';\n\nconst path = require('path');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parsed : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n","'use strict';\n\n// See http://www.robvanderwoude.com/escapechars.php\nconst metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;\n\nfunction escapeCommand(arg) {\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    return arg;\n}\n\nfunction escapeArgument(arg, doubleEscapeMetaChars) {\n    // Convert to string\n    arg = `${arg}`;\n\n    // Algorithm below is based on https://qntm.org/cmd\n\n    // Sequence of backslashes followed by a double quote:\n    // double up all the backslashes and escape the double quote\n    arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n    // Sequence of backslashes followed by the end of the string\n    // (which will become a double quote later):\n    // double up all the backslashes\n    arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n    // All other backslashes occur literally\n\n    // Quote the whole thing:\n    arg = `\"${arg}\"`;\n\n    // Escape meta chars\n    arg = arg.replace(metaCharsRegExp, '^$1');\n\n    // Double escape meta chars if necessary\n    if (doubleEscapeMetaChars) {\n        arg = arg.replace(metaCharsRegExp, '^$1');\n    }\n\n    return arg;\n}\n\nmodule.exports.command = escapeCommand;\nmodule.exports.argument = escapeArgument;\n","'use strict';\n\nconst fs = require('fs');\nconst shebangCommand = require('shebang-command');\n\nfunction readShebang(command) {\n    // Read the first 150 bytes from the file\n    const size = 150;\n    const buffer = Buffer.alloc(size);\n\n    let fd;\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, size, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* Empty */ }\n\n    // Attempt to extract shebang (null is returned if not a shebang)\n    return shebangCommand(buffer.toString());\n}\n\nmodule.exports = readShebang;\n","'use strict';\n\nconst path = require('path');\nconst which = require('which');\nconst getPathKey = require('path-key');\n\nfunction resolveCommandAttempt(parsed, withoutPathExt) {\n    const env = parsed.options.env || process.env;\n    const cwd = process.cwd();\n    const hasCustomCwd = parsed.options.cwd != null;\n    // Worker threads do not have process.chdir()\n    const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;\n\n    // If a custom `cwd` was specified, we need to change the process cwd\n    // because `which` will do stat calls but does not support a custom cwd\n    if (shouldSwitchCwd) {\n        try {\n            process.chdir(parsed.options.cwd);\n        } catch (err) {\n            /* Empty */\n        }\n    }\n\n    let resolved;\n\n    try {\n        resolved = which.sync(parsed.command, {\n            path: env[getPathKey({ env })],\n            pathExt: withoutPathExt ? path.delimiter : undefined,\n        });\n    } catch (e) {\n        /* Empty */\n    } finally {\n        if (shouldSwitchCwd) {\n            process.chdir(cwd);\n        }\n    }\n\n    // If we successfully resolved, ensure that an absolute path is returned\n    // Note that when a custom `cwd` was used, we need to resolve to an absolute path based on it\n    if (resolved) {\n        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);\n    }\n\n    return resolved;\n}\n\nfunction resolveCommand(parsed) {\n    return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);\n}\n\nmodule.exports = resolveCommand;\n","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n","const isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nconst path = require('path')\nconst COLON = isWindows ? ';' : ':'\nconst isexe = require('isexe')\n\nconst getNotFoundError = (cmd) =>\n  Object.assign(new Error(`not found: ${cmd}`), { code: 'ENOENT' })\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? ['']\n    : (\n      [\n        // windows always checks the cwd first\n        ...(isWindows ? [process.cwd()] : []),\n        ...(opt.path || process.env.PATH ||\n          /* istanbul ignore next: very unusual */ '').split(colon),\n      ]\n    )\n  const pathExtExe = isWindows\n    ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'\n    : ''\n  const pathExt = isWindows ? pathExtExe.split(colon) : ['']\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe,\n  }\n}\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (!opt)\n    opt = {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length)\n      return opt.all && found.length ? resolve(found)\n        : reject(getNotFoundError(cmd))\n\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    resolve(subStep(p, i, 0))\n  })\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length)\n      return resolve(step(i + 1))\n    const ext = pathExt[ii]\n    isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {\n      if (!er && is) {\n        if (opt.all)\n          found.push(p + ext)\n        else\n          return resolve(p + ext)\n      }\n      return resolve(subStep(p, i, ii + 1))\n    })\n  })\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0)\n}\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {}\n\n  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt)\n  const found = []\n\n  for (let i = 0; i < pathEnv.length; i ++) {\n    const ppRaw = pathEnv[i]\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw\n\n    const pCmd = path.join(pathPart, cmd)\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd\n      : pCmd\n\n    for (let j = 0; j < pathExt.length; j ++) {\n      const cur = p + pathExt[j]\n      try {\n        const is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n\nmodule.exports = which\nwhich.sync = whichSync\n","'use strict';\n\nconst pathKey = (options = {}) => {\n\tconst environment = options.env || process.env;\n\tconst platform = options.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(environment).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n};\n\nmodule.exports = pathKey;\n// TODO: Remove this for the next major release\nmodule.exports.default = pathKey;\n","'use strict';\nconst shebangRegex = require('shebang-regex');\n\nmodule.exports = (string = '') => {\n\tconst match = string.match(shebangRegex);\n\n\tif (!match) {\n\t\treturn null;\n\t}\n\n\tconst [path, argument] = match[0].replace(/#! ?/, '').split(' ');\n\tconst binary = path.split('/').pop();\n\n\tif (binary === 'env') {\n\t\treturn argument;\n\t}\n\n\treturn argument ? `${binary} ${argument}` : binary;\n};\n","'use strict';\nmodule.exports = /^#!(.*)/;\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","import {fileURLToPath} from 'node:url';\n\n// Allow some arguments/options to be either a file path string or a file URL\nexport const safeNormalizeFileUrl = (file, name) => {\n\tconst fileString = normalizeFileUrl(file);\n\n\tif (typeof fileString !== 'string') {\n\t\tthrow new TypeError(`${name} must be a string or a file URL: ${fileString}.`);\n\t}\n\n\treturn fileString;\n};\n\n// Same but also allows other values, e.g. `boolean` for the `shell` option\nexport const normalizeFileUrl = file => file instanceof URL ? fileURLToPath(file) : file;\n","import isPlainObject from 'is-plain-obj';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// The command `arguments` and `options` are both optional.\n// This also does basic validation on them and on the command file.\nexport const normalizeParameters = (rawFile, rawArguments = [], rawOptions = {}) => {\n\tconst filePath = safeNormalizeFileUrl(rawFile, 'First argument');\n\tconst [commandArguments, options] = isPlainObject(rawArguments)\n\t\t? [[], rawArguments]\n\t\t: [rawArguments, rawOptions];\n\n\tif (!Array.isArray(commandArguments)) {\n\t\tthrow new TypeError(`Second argument must be either an array of arguments or an options object: ${commandArguments}`);\n\t}\n\n\tif (commandArguments.some(commandArgument => typeof commandArgument === 'object' && commandArgument !== null)) {\n\t\tthrow new TypeError(`Second argument must be an array of strings: ${commandArguments}`);\n\t}\n\n\tconst normalizedArguments = commandArguments.map(String);\n\tconst nullByteArgument = normalizedArguments.find(normalizedArgument => normalizedArgument.includes('\\0'));\n\tif (nullByteArgument !== undefined) {\n\t\tthrow new TypeError(`Arguments cannot contain null bytes (\"\\\\0\"): ${nullByteArgument}`);\n\t}\n\n\tif (!isPlainObject(options)) {\n\t\tthrow new TypeError(`Last argument must be an options object: ${options}`);\n\t}\n\n\treturn [filePath, normalizedArguments, options];\n};\n","import {StringDecoder} from 'node:string_decoder';\n\nconst {toString: objectToString} = Object.prototype;\n\nexport const isArrayBuffer = value => objectToString.call(value) === '[object ArrayBuffer]';\n\n// Is either Uint8Array or Buffer\nexport const isUint8Array = value => objectToString.call(value) === '[object Uint8Array]';\n\nexport const bufferToUint8Array = buffer => new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n\nconst textEncoder = new TextEncoder();\nconst stringToUint8Array = string => textEncoder.encode(string);\n\nconst textDecoder = new TextDecoder();\nexport const uint8ArrayToString = uint8Array => textDecoder.decode(uint8Array);\n\nexport const joinToString = (uint8ArraysOrStrings, encoding) => {\n\tconst strings = uint8ArraysToStrings(uint8ArraysOrStrings, encoding);\n\treturn strings.join('');\n};\n\nconst uint8ArraysToStrings = (uint8ArraysOrStrings, encoding) => {\n\tif (encoding === 'utf8' && uint8ArraysOrStrings.every(uint8ArrayOrString => typeof uint8ArrayOrString === 'string')) {\n\t\treturn uint8ArraysOrStrings;\n\t}\n\n\tconst decoder = new StringDecoder(encoding);\n\tconst strings = uint8ArraysOrStrings\n\t\t.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t\t\t? stringToUint8Array(uint8ArrayOrString)\n\t\t\t: uint8ArrayOrString)\n\t\t.map(uint8Array => decoder.write(uint8Array));\n\tconst finalString = decoder.end();\n\treturn finalString === '' ? strings : [...strings, finalString];\n};\n\nexport const joinToUint8Array = uint8ArraysOrStrings => {\n\tif (uint8ArraysOrStrings.length === 1 && isUint8Array(uint8ArraysOrStrings[0])) {\n\t\treturn uint8ArraysOrStrings[0];\n\t}\n\n\treturn concatUint8Arrays(stringsToUint8Arrays(uint8ArraysOrStrings));\n};\n\nconst stringsToUint8Arrays = uint8ArraysOrStrings => uint8ArraysOrStrings.map(uint8ArrayOrString => typeof uint8ArrayOrString === 'string'\n\t? stringToUint8Array(uint8ArrayOrString)\n\t: uint8ArrayOrString);\n\nexport const concatUint8Arrays = uint8Arrays => {\n\tconst result = new Uint8Array(getJoinLength(uint8Arrays));\n\n\tlet index = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tresult.set(uint8Array, index);\n\t\tindex += uint8Array.length;\n\t}\n\n\treturn result;\n};\n\nconst getJoinLength = uint8Arrays => {\n\tlet joinLength = 0;\n\tfor (const uint8Array of uint8Arrays) {\n\t\tjoinLength += uint8Array.length;\n\t}\n\n\treturn joinLength;\n};\n","import {ChildProcess} from 'node:child_process';\nimport isPlainObject from 'is-plain-obj';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\n\n// Check whether the template string syntax is being used\nexport const isTemplateString = templates => Array.isArray(templates) && Array.isArray(templates.raw);\n\n// Convert execa`file ...commandArguments` to execa(file, commandArguments)\nexport const parseTemplates = (templates, expressions) => {\n\tlet tokens = [];\n\n\tfor (const [index, template] of templates.entries()) {\n\t\ttokens = parseTemplate({\n\t\t\ttemplates,\n\t\t\texpressions,\n\t\t\ttokens,\n\t\t\tindex,\n\t\t\ttemplate,\n\t\t});\n\t}\n\n\tif (tokens.length === 0) {\n\t\tthrow new TypeError('Template script must not be empty');\n\t}\n\n\tconst [file, ...commandArguments] = tokens;\n\treturn [file, commandArguments, {}];\n};\n\nconst parseTemplate = ({templates, expressions, tokens, index, template}) => {\n\tif (template === undefined) {\n\t\tthrow new TypeError(`Invalid backslash sequence: ${templates.raw[index]}`);\n\t}\n\n\tconst {nextTokens, leadingWhitespaces, trailingWhitespaces} = splitByWhitespaces(template, templates.raw[index]);\n\tconst newTokens = concatTokens(tokens, nextTokens, leadingWhitespaces);\n\n\tif (index === expressions.length) {\n\t\treturn newTokens;\n\t}\n\n\tconst expression = expressions[index];\n\tconst expressionTokens = Array.isArray(expression)\n\t\t? expression.map(expression => parseExpression(expression))\n\t\t: [parseExpression(expression)];\n\treturn concatTokens(newTokens, expressionTokens, trailingWhitespaces);\n};\n\n// Like `string.split(/[ \\t\\r\\n]+/)` except newlines and tabs are:\n//  - ignored when input as a backslash sequence like: `echo foo\\n bar`\n//  - not ignored when input directly\n// The only way to distinguish those in JavaScript is to use a tagged template and compare:\n//  - the first array argument, which does not escape backslash sequences\n//  - its `raw` property, which escapes them\nconst splitByWhitespaces = (template, rawTemplate) => {\n\tif (rawTemplate.length === 0) {\n\t\treturn {nextTokens: [], leadingWhitespaces: false, trailingWhitespaces: false};\n\t}\n\n\tconst nextTokens = [];\n\tlet templateStart = 0;\n\tconst leadingWhitespaces = DELIMITERS.has(rawTemplate[0]);\n\n\tfor (\n\t\tlet templateIndex = 0, rawIndex = 0;\n\t\ttemplateIndex < template.length;\n\t\ttemplateIndex += 1, rawIndex += 1\n\t) {\n\t\tconst rawCharacter = rawTemplate[rawIndex];\n\t\tif (DELIMITERS.has(rawCharacter)) {\n\t\t\tif (templateStart !== templateIndex) {\n\t\t\t\tnextTokens.push(template.slice(templateStart, templateIndex));\n\t\t\t}\n\n\t\t\ttemplateStart = templateIndex + 1;\n\t\t} else if (rawCharacter === '\\\\') {\n\t\t\tconst nextRawCharacter = rawTemplate[rawIndex + 1];\n\t\t\tif (nextRawCharacter === 'u' && rawTemplate[rawIndex + 2] === '{') {\n\t\t\t\trawIndex = rawTemplate.indexOf('}', rawIndex + 3);\n\t\t\t} else {\n\t\t\t\trawIndex += ESCAPE_LENGTH[nextRawCharacter] ?? 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst trailingWhitespaces = templateStart === template.length;\n\tif (!trailingWhitespaces) {\n\t\tnextTokens.push(template.slice(templateStart));\n\t}\n\n\treturn {nextTokens, leadingWhitespaces, trailingWhitespaces};\n};\n\nconst DELIMITERS = new Set([' ', '\\t', '\\r', '\\n']);\n\n// Number of characters in backslash escape sequences: \\0 \\xXX or \\uXXXX\n// \\cX is allowed in RegExps but not in strings\n// Octal sequences are not allowed in strict mode\nconst ESCAPE_LENGTH = {x: 3, u: 5};\n\nconst concatTokens = (tokens, nextTokens, isSeparated) => isSeparated\n\t|| tokens.length === 0\n\t|| nextTokens.length === 0\n\t? [...tokens, ...nextTokens]\n\t: [\n\t\t...tokens.slice(0, -1),\n\t\t`${tokens.at(-1)}${nextTokens[0]}`,\n\t\t...nextTokens.slice(1),\n\t];\n\n// Handle `${expression}` inside the template string syntax\nconst parseExpression = expression => {\n\tconst typeOfExpression = typeof expression;\n\n\tif (typeOfExpression === 'string') {\n\t\treturn expression;\n\t}\n\n\tif (typeOfExpression === 'number') {\n\t\treturn String(expression);\n\t}\n\n\tif (isPlainObject(expression) && ('stdout' in expression || 'isMaxBuffer' in expression)) {\n\t\treturn getSubprocessResult(expression);\n\t}\n\n\tif (expression instanceof ChildProcess || Object.prototype.toString.call(expression) === '[object Promise]') {\n\t\t// eslint-disable-next-line no-template-curly-in-string\n\t\tthrow new TypeError('Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeOfExpression}\" in template expression`);\n};\n\nconst getSubprocessResult = ({stdout}) => {\n\tif (typeof stdout === 'string') {\n\t\treturn stdout;\n\t}\n\n\tif (isUint8Array(stdout)) {\n\t\treturn uint8ArrayToString(stdout);\n\t}\n\n\tif (stdout === undefined) {\n\t\tthrow new TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\\' \"stdout\" option.');\n\t}\n\n\tthrow new TypeError(`Unexpected \"${typeof stdout}\" stdout in template expression`);\n};\n","import tty from 'node:tty';\n\n// eslint-disable-next-line no-warning-comments\n// TODO: Use a better method when it's added to Node.js (https://github.com/nodejs/node/pull/40240)\nconst hasColors = tty.WriteStream.prototype.hasColors();\n\nconst format = (open, close) => {\n\tif (!hasColors) {\n\t\treturn input => input;\n\t}\n\n\tconst openCode = `\\u001B[${open}m`;\n\tconst closeCode = `\\u001B[${close}m`;\n\n\treturn input => {\n\t\tconst string = input + ''; // eslint-disable-line no-implicit-coercion -- This is faster.\n\t\tlet index = string.indexOf(closeCode);\n\n\t\tif (index === -1) {\n\t\t\t// Note: Intentionally not using string interpolation for performance reasons.\n\t\t\treturn openCode + string + closeCode;\n\t\t}\n\n\t\t// Handle nested colors.\n\n\t\t// We could have done this, but it's too slow (as of Node.js 22).\n\t\t// return openCode + string.replaceAll(closeCode, openCode) + closeCode;\n\n\t\tlet result = openCode;\n\t\tlet lastIndex = 0;\n\n\t\twhile (index !== -1) {\n\t\t\tresult += string.slice(lastIndex, index) + openCode;\n\t\t\tlastIndex = index + closeCode.length;\n\t\t\tindex = string.indexOf(closeCode, lastIndex);\n\t\t}\n\n\t\tresult += string.slice(lastIndex) + closeCode;\n\n\t\treturn result;\n\t};\n};\n\nexport const reset = format(0, 0);\nexport const bold = format(1, 22);\nexport const dim = format(2, 22);\nexport const italic = format(3, 23);\nexport const underline = format(4, 24);\nexport const overline = format(53, 55);\nexport const inverse = format(7, 27);\nexport const hidden = format(8, 28);\nexport const strikethrough = format(9, 29);\n\nexport const black = format(30, 39);\nexport const red = format(31, 39);\nexport const green = format(32, 39);\nexport const yellow = format(33, 39);\nexport const blue = format(34, 39);\nexport const magenta = format(35, 39);\nexport const cyan = format(36, 39);\nexport const white = format(37, 39);\nexport const gray = format(90, 39);\n\nexport const bgBlack = format(40, 49);\nexport const bgRed = format(41, 49);\nexport const bgGreen = format(42, 49);\nexport const bgYellow = format(43, 49);\nexport const bgBlue = format(44, 49);\nexport const bgMagenta = format(45, 49);\nexport const bgCyan = format(46, 49);\nexport const bgWhite = format(47, 49);\nexport const bgGray = format(100, 49);\n\nexport const redBright = format(91, 39);\nexport const greenBright = format(92, 39);\nexport const yellowBright = format(93, 39);\nexport const blueBright = format(94, 39);\nexport const magentaBright = format(95, 39);\nexport const cyanBright = format(96, 39);\nexport const whiteBright = format(97, 39);\n\nexport const bgRedBright = format(101, 49);\nexport const bgGreenBright = format(102, 49);\nexport const bgYellowBright = format(103, 49);\nexport const bgBlueBright = format(104, 49);\nexport const bgMagentaBright = format(105, 49);\nexport const bgCyanBright = format(106, 49);\nexport const bgWhiteBright = format(107, 49);\n","import {debuglog} from 'node:util';\n\n// Default value for the `verbose` option\nexport const verboseDefault = debuglog('execa').enabled ? 'full' : 'none';\n\n// Information computed before spawning, used by the `verbose` option\nexport const getVerboseInfo = verbose => {\n\tconst verboseId = isVerbose(verbose) ? VERBOSE_ID++ : undefined;\n\tvalidateVerbose(verbose);\n\treturn {verbose, verboseId};\n};\n\n// Prepending the `pid` is useful when multiple commands print their output at the same time.\n// However, we cannot use the real PID since this is not available with `child_process.spawnSync()`.\n// Also, we cannot use the real PID if we want to print it before `child_process.spawn()` is run.\n// As a pro, it is shorter than a normal PID and never re-uses the same id.\n// As a con, it cannot be used to send signals.\nlet VERBOSE_ID = 0n;\n\n// The `verbose` option can have different values for `stdout`/`stderr`\nexport const isVerbose = verbose => verbose.some(fdVerbose => fdVerbose !== 'none');\n\nconst validateVerbose = verbose => {\n\tfor (const verboseItem of verbose) {\n\t\tif (verboseItem === false) {\n\t\t\tthrow new TypeError('The \"verbose: false\" option was renamed to \"verbose: \\'none\\'\".');\n\t\t}\n\n\t\tif (verboseItem === true) {\n\t\t\tthrow new TypeError('The \"verbose: true\" option was renamed to \"verbose: \\'short\\'\".');\n\t\t}\n\n\t\tif (!VERBOSE_VALUES.has(verboseItem)) {\n\t\t\tconst allowedValues = [...VERBOSE_VALUES].map(allowedValue => `'${allowedValue}'`).join(', ');\n\t\t\tthrow new TypeError(`The \"verbose\" option must not be ${verboseItem}. Allowed values are: ${allowedValues}.`);\n\t\t}\n\t}\n};\n\nconst VERBOSE_VALUES = new Set(['none', 'short', 'full']);\n","import isUnicodeSupported from 'is-unicode-supported';\n\nconst common = {\n\tcircleQuestionMark: '(?)',\n\tquestionMarkPrefix: '(?)',\n\tsquare: '█',\n\tsquareDarkShade: '▓',\n\tsquareMediumShade: '▒',\n\tsquareLightShade: '░',\n\tsquareTop: '▀',\n\tsquareBottom: '▄',\n\tsquareLeft: '▌',\n\tsquareRight: '▐',\n\tsquareCenter: '■',\n\tbullet: '●',\n\tdot: '․',\n\tellipsis: '…',\n\tpointerSmall: '›',\n\ttriangleUp: '▲',\n\ttriangleUpSmall: '▴',\n\ttriangleDown: '▼',\n\ttriangleDownSmall: '▾',\n\ttriangleLeftSmall: '◂',\n\ttriangleRightSmall: '▸',\n\thome: '⌂',\n\theart: '♥',\n\tmusicNote: '♪',\n\tmusicNoteBeamed: '♫',\n\tarrowUp: '↑',\n\tarrowDown: '↓',\n\tarrowLeft: '←',\n\tarrowRight: '→',\n\tarrowLeftRight: '↔',\n\tarrowUpDown: '↕',\n\talmostEqual: '≈',\n\tnotEqual: '≠',\n\tlessOrEqual: '≤',\n\tgreaterOrEqual: '≥',\n\tidentical: '≡',\n\tinfinity: '∞',\n\tsubscriptZero: '₀',\n\tsubscriptOne: '₁',\n\tsubscriptTwo: '₂',\n\tsubscriptThree: '₃',\n\tsubscriptFour: '₄',\n\tsubscriptFive: '₅',\n\tsubscriptSix: '₆',\n\tsubscriptSeven: '₇',\n\tsubscriptEight: '₈',\n\tsubscriptNine: '₉',\n\toneHalf: '½',\n\toneThird: '⅓',\n\toneQuarter: '¼',\n\toneFifth: '⅕',\n\toneSixth: '⅙',\n\toneEighth: '⅛',\n\ttwoThirds: '⅔',\n\ttwoFifths: '⅖',\n\tthreeQuarters: '¾',\n\tthreeFifths: '⅗',\n\tthreeEighths: '⅜',\n\tfourFifths: '⅘',\n\tfiveSixths: '⅚',\n\tfiveEighths: '⅝',\n\tsevenEighths: '⅞',\n\tline: '─',\n\tlineBold: '━',\n\tlineDouble: '═',\n\tlineDashed0: '┄',\n\tlineDashed1: '┅',\n\tlineDashed2: '┈',\n\tlineDashed3: '┉',\n\tlineDashed4: '╌',\n\tlineDashed5: '╍',\n\tlineDashed6: '╴',\n\tlineDashed7: '╶',\n\tlineDashed8: '╸',\n\tlineDashed9: '╺',\n\tlineDashed10: '╼',\n\tlineDashed11: '╾',\n\tlineDashed12: '−',\n\tlineDashed13: '–',\n\tlineDashed14: '‐',\n\tlineDashed15: '⁃',\n\tlineVertical: '│',\n\tlineVerticalBold: '┃',\n\tlineVerticalDouble: '║',\n\tlineVerticalDashed0: '┆',\n\tlineVerticalDashed1: '┇',\n\tlineVerticalDashed2: '┊',\n\tlineVerticalDashed3: '┋',\n\tlineVerticalDashed4: '╎',\n\tlineVerticalDashed5: '╏',\n\tlineVerticalDashed6: '╵',\n\tlineVerticalDashed7: '╷',\n\tlineVerticalDashed8: '╹',\n\tlineVerticalDashed9: '╻',\n\tlineVerticalDashed10: '╽',\n\tlineVerticalDashed11: '╿',\n\tlineDownLeft: '┐',\n\tlineDownLeftArc: '╮',\n\tlineDownBoldLeftBold: '┓',\n\tlineDownBoldLeft: '┒',\n\tlineDownLeftBold: '┑',\n\tlineDownDoubleLeftDouble: '╗',\n\tlineDownDoubleLeft: '╖',\n\tlineDownLeftDouble: '╕',\n\tlineDownRight: '┌',\n\tlineDownRightArc: '╭',\n\tlineDownBoldRightBold: '┏',\n\tlineDownBoldRight: '┎',\n\tlineDownRightBold: '┍',\n\tlineDownDoubleRightDouble: '╔',\n\tlineDownDoubleRight: '╓',\n\tlineDownRightDouble: '╒',\n\tlineUpLeft: '┘',\n\tlineUpLeftArc: '╯',\n\tlineUpBoldLeftBold: '┛',\n\tlineUpBoldLeft: '┚',\n\tlineUpLeftBold: '┙',\n\tlineUpDoubleLeftDouble: '╝',\n\tlineUpDoubleLeft: '╜',\n\tlineUpLeftDouble: '╛',\n\tlineUpRight: '└',\n\tlineUpRightArc: '╰',\n\tlineUpBoldRightBold: '┗',\n\tlineUpBoldRight: '┖',\n\tlineUpRightBold: '┕',\n\tlineUpDoubleRightDouble: '╚',\n\tlineUpDoubleRight: '╙',\n\tlineUpRightDouble: '╘',\n\tlineUpDownLeft: '┤',\n\tlineUpBoldDownBoldLeftBold: '┫',\n\tlineUpBoldDownBoldLeft: '┨',\n\tlineUpDownLeftBold: '┥',\n\tlineUpBoldDownLeftBold: '┩',\n\tlineUpDownBoldLeftBold: '┪',\n\tlineUpDownBoldLeft: '┧',\n\tlineUpBoldDownLeft: '┦',\n\tlineUpDoubleDownDoubleLeftDouble: '╣',\n\tlineUpDoubleDownDoubleLeft: '╢',\n\tlineUpDownLeftDouble: '╡',\n\tlineUpDownRight: '├',\n\tlineUpBoldDownBoldRightBold: '┣',\n\tlineUpBoldDownBoldRight: '┠',\n\tlineUpDownRightBold: '┝',\n\tlineUpBoldDownRightBold: '┡',\n\tlineUpDownBoldRightBold: '┢',\n\tlineUpDownBoldRight: '┟',\n\tlineUpBoldDownRight: '┞',\n\tlineUpDoubleDownDoubleRightDouble: '╠',\n\tlineUpDoubleDownDoubleRight: '╟',\n\tlineUpDownRightDouble: '╞',\n\tlineDownLeftRight: '┬',\n\tlineDownBoldLeftBoldRightBold: '┳',\n\tlineDownLeftBoldRightBold: '┯',\n\tlineDownBoldLeftRight: '┰',\n\tlineDownBoldLeftBoldRight: '┱',\n\tlineDownBoldLeftRightBold: '┲',\n\tlineDownLeftRightBold: '┮',\n\tlineDownLeftBoldRight: '┭',\n\tlineDownDoubleLeftDoubleRightDouble: '╦',\n\tlineDownDoubleLeftRight: '╥',\n\tlineDownLeftDoubleRightDouble: '╤',\n\tlineUpLeftRight: '┴',\n\tlineUpBoldLeftBoldRightBold: '┻',\n\tlineUpLeftBoldRightBold: '┷',\n\tlineUpBoldLeftRight: '┸',\n\tlineUpBoldLeftBoldRight: '┹',\n\tlineUpBoldLeftRightBold: '┺',\n\tlineUpLeftRightBold: '┶',\n\tlineUpLeftBoldRight: '┵',\n\tlineUpDoubleLeftDoubleRightDouble: '╩',\n\tlineUpDoubleLeftRight: '╨',\n\tlineUpLeftDoubleRightDouble: '╧',\n\tlineUpDownLeftRight: '┼',\n\tlineUpBoldDownBoldLeftBoldRightBold: '╋',\n\tlineUpDownBoldLeftBoldRightBold: '╈',\n\tlineUpBoldDownLeftBoldRightBold: '╇',\n\tlineUpBoldDownBoldLeftRightBold: '╊',\n\tlineUpBoldDownBoldLeftBoldRight: '╉',\n\tlineUpBoldDownLeftRight: '╀',\n\tlineUpDownBoldLeftRight: '╁',\n\tlineUpDownLeftBoldRight: '┽',\n\tlineUpDownLeftRightBold: '┾',\n\tlineUpBoldDownBoldLeftRight: '╂',\n\tlineUpDownLeftBoldRightBold: '┿',\n\tlineUpBoldDownLeftBoldRight: '╃',\n\tlineUpBoldDownLeftRightBold: '╄',\n\tlineUpDownBoldLeftBoldRight: '╅',\n\tlineUpDownBoldLeftRightBold: '╆',\n\tlineUpDoubleDownDoubleLeftDoubleRightDouble: '╬',\n\tlineUpDoubleDownDoubleLeftRight: '╫',\n\tlineUpDownLeftDoubleRightDouble: '╪',\n\tlineCross: '╳',\n\tlineBackslash: '╲',\n\tlineSlash: '╱',\n};\n\nconst specialMainSymbols = {\n\ttick: '✔',\n\tinfo: 'ℹ',\n\twarning: '⚠',\n\tcross: '✘',\n\tsquareSmall: '◻',\n\tsquareSmallFilled: '◼',\n\tcircle: '◯',\n\tcircleFilled: '◉',\n\tcircleDotted: '◌',\n\tcircleDouble: '◎',\n\tcircleCircle: 'ⓞ',\n\tcircleCross: 'ⓧ',\n\tcirclePipe: 'Ⓘ',\n\tradioOn: '◉',\n\tradioOff: '◯',\n\tcheckboxOn: '☒',\n\tcheckboxOff: '☐',\n\tcheckboxCircleOn: 'ⓧ',\n\tcheckboxCircleOff: 'Ⓘ',\n\tpointer: '❯',\n\ttriangleUpOutline: '△',\n\ttriangleLeft: '◀',\n\ttriangleRight: '▶',\n\tlozenge: '◆',\n\tlozengeOutline: '◇',\n\thamburger: '☰',\n\tsmiley: '㋡',\n\tmustache: '෴',\n\tstar: '★',\n\tplay: '▶',\n\tnodejs: '⬢',\n\toneSeventh: '⅐',\n\toneNinth: '⅑',\n\toneTenth: '⅒',\n};\n\nconst specialFallbackSymbols = {\n\ttick: '√',\n\tinfo: 'i',\n\twarning: '‼',\n\tcross: '×',\n\tsquareSmall: '□',\n\tsquareSmallFilled: '■',\n\tcircle: '( )',\n\tcircleFilled: '(*)',\n\tcircleDotted: '( )',\n\tcircleDouble: '( )',\n\tcircleCircle: '(○)',\n\tcircleCross: '(×)',\n\tcirclePipe: '(│)',\n\tradioOn: '(*)',\n\tradioOff: '( )',\n\tcheckboxOn: '[×]',\n\tcheckboxOff: '[ ]',\n\tcheckboxCircleOn: '(×)',\n\tcheckboxCircleOff: '( )',\n\tpointer: '>',\n\ttriangleUpOutline: '∆',\n\ttriangleLeft: '◄',\n\ttriangleRight: '►',\n\tlozenge: '♦',\n\tlozengeOutline: '◊',\n\thamburger: '≡',\n\tsmiley: '☺',\n\tmustache: '┌─┐',\n\tstar: '✶',\n\tplay: '►',\n\tnodejs: '♦',\n\toneSeventh: '1/7',\n\toneNinth: '1/9',\n\toneTenth: '1/10',\n};\n\nexport const mainSymbols = {...common, ...specialMainSymbols};\nexport const fallbackSymbols = {...common, ...specialFallbackSymbols};\n\nconst shouldUseMain = isUnicodeSupported();\nconst figures = shouldUseMain ? mainSymbols : fallbackSymbols;\nexport default figures;\n\nconst replacements = Object.entries(specialMainSymbols);\n\n// On terminals which do not support Unicode symbols, substitute them to other symbols\nexport const replaceSymbols = (string, {useFallback = !shouldUseMain} = {}) => {\n\tif (useFallback) {\n\t\tfor (const [key, mainSymbol] of replacements) {\n\t\t\tstring = string.replaceAll(mainSymbol, fallbackSymbols[key]);\n\t\t}\n\t}\n\n\treturn string;\n};\n","import process from 'node:process';\n\nexport default function isUnicodeSupported() {\n\tif (process.platform !== 'win32') {\n\t\treturn process.env.TERM !== 'linux'; // Linux console (kernel)\n\t}\n\n\treturn Boolean(process.env.WT_SESSION) // Windows Terminal\n\t\t|| Boolean(process.env.TERMINUS_SUBLIME) // Terminus (<0.2.27)\n\t\t|| process.env.ConEmuTask === '{cmd::Cmder}' // ConEmu and cmder\n\t\t|| process.env.TERM_PROGRAM === 'Terminus-Sublime'\n\t\t|| process.env.TERM_PROGRAM === 'vscode'\n\t\t|| process.env.TERM === 'xterm-256color'\n\t\t|| process.env.TERM === 'alacritty'\n\t\t|| process.env.TERMINAL_EMULATOR === 'JetBrains-JediTerm';\n}\n","import {writeFileSync} from 'node:fs';\nimport figures from 'figures';\nimport {gray} from 'yoctocolors';\n\n// Write synchronously to ensure lines are properly ordered and not interleaved with `stdout`\nexport const verboseLog = (string, verboseId, icon, color) => {\n\tconst prefixedLines = addPrefix(string, verboseId, icon, color);\n\twriteFileSync(STDERR_FD, `${prefixedLines}\\n`);\n};\n\nconst STDERR_FD = 2;\n\nconst addPrefix = (string, verboseId, icon, color) => string.includes('\\n')\n\t? string\n\t\t.split('\\n')\n\t\t.map(line => addPrefixToLine(line, verboseId, icon, color))\n\t\t.join('\\n')\n\t: addPrefixToLine(string, verboseId, icon, color);\n\nconst addPrefixToLine = (line, verboseId, icon, color = identity) => [\n\tgray(`[${getTimestamp()}]`),\n\tgray(`[${verboseId}]`),\n\tcolor(ICONS[icon]),\n\tcolor(line),\n].join(' ');\n\nconst identity = string => string;\n\n// Prepending the timestamp allows debugging the slow paths of a subprocess\nconst getTimestamp = () => {\n\tconst date = new Date();\n\treturn `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;\n};\n\nconst padField = (field, padding) => String(field).padStart(padding, '0');\n\nconst ICONS = {\n\tcommand: '$',\n\tpipedCommand: '|',\n\toutput: ' ',\n\terror: figures.cross,\n\twarning: figures.warning,\n\tsuccess: figures.tick,\n};\n","import {hrtime} from 'node:process';\n\n// Start counting time before spawning the subprocess\nexport const getStartTime = () => hrtime.bigint();\n\n// Compute duration after the subprocess ended.\n// Printed by the `verbose` option.\nexport const getDurationMs = startTime => Number(hrtime.bigint() - startTime) / 1e6;\n","import {platform} from 'node:process';\nimport {stripVTControlCharacters} from 'node:util';\n\n// Compute `result.command` and `result.escapedCommand`\nexport const joinCommand = (filePath, rawArguments) => {\n\tconst fileAndArguments = [filePath, ...rawArguments];\n\tconst command = fileAndArguments.join(' ');\n\tconst escapedCommand = fileAndArguments\n\t\t.map(fileAndArgument => quoteString(escapeControlCharacters(fileAndArgument)))\n\t\t.join(' ');\n\treturn {command, escapedCommand};\n};\n\n// Remove ANSI sequences and escape control characters and newlines\nexport const escapeLines = lines => stripVTControlCharacters(lines)\n\t.split('\\n')\n\t.map(line => escapeControlCharacters(line))\n\t.join('\\n');\n\nconst escapeControlCharacters = line => line.replaceAll(SPECIAL_CHAR_REGEXP, character => escapeControlCharacter(character));\n\nconst escapeControlCharacter = character => {\n\tconst commonEscape = COMMON_ESCAPES[character];\n\tif (commonEscape !== undefined) {\n\t\treturn commonEscape;\n\t}\n\n\tconst codepoint = character.codePointAt(0);\n\tconst codepointHex = codepoint.toString(16);\n\treturn codepoint <= ASTRAL_START\n\t\t? `\\\\u${codepointHex.padStart(4, '0')}`\n\t\t: `\\\\U${codepointHex}`;\n};\n\n// Characters that would create issues when printed are escaped using the \\u or \\U notation.\n// Those include control characters and newlines.\n// The \\u and \\U notation is Bash specific, but there is no way to do this in a shell-agnostic way.\n// Some shells do not even have a way to print those characters in an escaped fashion.\n// Therefore, we prioritize printing those safely, instead of allowing those to be copy-pasted.\n// List of Unicode character categories: https://www.fileformat.info/info/unicode/category/index.htm\nconst SPECIAL_CHAR_REGEXP = /\\p{Separator}|\\p{Other}/gu;\n\n// Accepted by $'...' in Bash.\n// Exclude \\a \\e \\v which are accepted in Bash but not in JavaScript (except \\v) and JSON.\nconst COMMON_ESCAPES = {\n\t' ': ' ',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t',\n};\n\n// Up until that codepoint, \\u notation can be used instead of \\U\nconst ASTRAL_START = 65_535;\n\n// Some characters are shell-specific, i.e. need to be escaped when the command is copy-pasted then run.\n// Escaping is shell-specific. We cannot know which shell is used: `process.platform` detection is not enough.\n// For example, Windows users could be using `cmd.exe`, Powershell or Bash for Windows which all use different escaping.\n// We use '...' on Unix, which is POSIX shell compliant and escape all characters but ' so this is fairly safe.\n// On Windows, we assume cmd.exe is used and escape with \"...\", which also works with Powershell.\nconst quoteString = escapedArgument => {\n\tif (NO_ESCAPE_REGEXP.test(escapedArgument)) {\n\t\treturn escapedArgument;\n\t}\n\n\treturn platform === 'win32'\n\t\t? `\"${escapedArgument.replaceAll('\"', '\"\"')}\"`\n\t\t: `'${escapedArgument.replaceAll('\\'', '\\'\\\\\\'\\'')}'`;\n};\n\nconst NO_ESCAPE_REGEXP = /^[\\w./-]+$/;\n","import process from 'node:process';\n\nexport const isStandardStream = stream => STANDARD_STREAMS.includes(stream);\nexport const STANDARD_STREAMS = [process.stdin, process.stdout, process.stderr];\nexport const STANDARD_STREAMS_ALIASES = ['stdin', 'stdout', 'stderr'];\nexport const getStreamName = fdNumber => STANDARD_STREAMS_ALIASES[fdNumber] ?? `stdio[${fdNumber}]`;\n","import isPlainObject from 'is-plain-obj';\nimport {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\nimport {verboseDefault} from '../verbose/info.js';\n\n// Some options can have different values for `stdout`/`stderr`/`fd3`.\n// This normalizes those to array of values.\n// For example, `{verbose: {stdout: 'none', stderr: 'full'}}` becomes `{verbose: ['none', 'none', 'full']}`\nexport const normalizeFdSpecificOptions = options => {\n\tconst optionsCopy = {...options};\n\n\tfor (const optionName of FD_SPECIFIC_OPTIONS) {\n\t\toptionsCopy[optionName] = normalizeFdSpecificOption(options, optionName);\n\t}\n\n\treturn optionsCopy;\n};\n\nexport const normalizeFdSpecificOption = (options, optionName) => {\n\tconst optionBaseArray = Array.from({length: getStdioLength(options)});\n\tconst optionArray = normalizeFdSpecificValue(options[optionName], optionBaseArray, optionName);\n\treturn addDefaultValue(optionArray, optionName);\n};\n\nconst getStdioLength = ({stdio}) => Array.isArray(stdio)\n\t? Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length)\n\t: STANDARD_STREAMS_ALIASES.length;\n\nconst normalizeFdSpecificValue = (optionValue, optionArray, optionName) => isPlainObject(optionValue)\n\t? normalizeOptionObject(optionValue, optionArray, optionName)\n\t: optionArray.fill(optionValue);\n\nconst normalizeOptionObject = (optionValue, optionArray, optionName) => {\n\tfor (const fdName of Object.keys(optionValue).sort(compareFdName)) {\n\t\tfor (const fdNumber of parseFdName(fdName, optionName, optionArray)) {\n\t\t\toptionArray[fdNumber] = optionValue[fdName];\n\t\t}\n\t}\n\n\treturn optionArray;\n};\n\n// Ensure priority order when setting both `stdout`/`stderr`, `fd1`/`fd2`, and `all`\nconst compareFdName = (fdNameA, fdNameB) => getFdNameOrder(fdNameA) < getFdNameOrder(fdNameB) ? 1 : -1;\n\nconst getFdNameOrder = fdName => {\n\tif (fdName === 'stdout' || fdName === 'stderr') {\n\t\treturn 0;\n\t}\n\n\treturn fdName === 'all' ? 2 : 1;\n};\n\nconst parseFdName = (fdName, optionName, optionArray) => {\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber === undefined || fdNumber === 0) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid.\nIt must be \"${optionName}.stdout\", \"${optionName}.stderr\", \"${optionName}.all\", or \"${optionName}.fd3\", \"${optionName}.fd4\" (and so on).`);\n\t}\n\n\tif (fdNumber >= optionArray.length) {\n\t\tthrow new TypeError(`\"${optionName}.${fdName}\" is invalid: that file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\treturn fdNumber === 'all' ? [1, 2] : [fdNumber];\n};\n\n// Use the same syntax for fd-specific options and the `from`/`to` options\nexport const parseFd = fdName => {\n\tif (fdName === 'all') {\n\t\treturn fdName;\n\t}\n\n\tif (STANDARD_STREAMS_ALIASES.includes(fdName)) {\n\t\treturn STANDARD_STREAMS_ALIASES.indexOf(fdName);\n\t}\n\n\tconst regexpResult = FD_REGEXP.exec(fdName);\n\tif (regexpResult !== null) {\n\t\treturn Number(regexpResult[1]);\n\t}\n};\n\nconst FD_REGEXP = /^fd(\\d+)$/;\n\nconst addDefaultValue = (optionArray, optionName) => optionArray.map(optionValue => optionValue === undefined\n\t? DEFAULT_OPTIONS[optionName]\n\t: optionValue);\n\nconst DEFAULT_OPTIONS = {\n\tlines: false,\n\tbuffer: true,\n\tmaxBuffer: 1000 * 1000 * 100,\n\tverbose: verboseDefault,\n\tstripFinalNewline: true,\n};\n\n// List of options which can have different values for `stdout`/`stderr`\nexport const FD_SPECIFIC_OPTIONS = ['lines', 'buffer', 'maxBuffer', 'verbose', 'stripFinalNewline'];\n","import {logCommand} from '../verbose/start.js';\nimport {getVerboseInfo} from '../verbose/info.js';\nimport {getStartTime} from '../return/duration.js';\nimport {joinCommand} from './escape.js';\nimport {normalizeFdSpecificOption} from './specific.js';\n\n// Compute `result.command`, `result.escapedCommand` and `verbose`-related information\nexport const handleCommand = (filePath, rawArguments, rawOptions) => {\n\tconst startTime = getStartTime();\n\tconst {command, escapedCommand} = joinCommand(filePath, rawArguments);\n\tconst verboseInfo = getVerboseInfo(normalizeFdSpecificOption(rawOptions, 'verbose'));\n\tlogCommand(escapedCommand, verboseInfo, rawOptions);\n\treturn {\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\tverboseInfo,\n\t};\n};\n","import {bold} from 'yoctocolors';\nimport {isVerbose} from './info.js';\nimport {verboseLog} from './log.js';\n\n// When `verbose` is `short|full`, print each command\nexport const logCommand = (escapedCommand, {verbose, verboseId}, {piped = false}) => {\n\tif (!isVerbose(verbose)) {\n\t\treturn;\n\t}\n\n\tconst icon = piped ? 'pipedCommand' : 'command';\n\tverboseLog(escapedCommand, verboseId, icon, bold);\n};\n","export default function pathKey(options = {}) {\n\tconst {\n\t\tenv = process.env,\n\t\tplatform = process.platform\n\t} = options;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(env).reverse().find(key => key.toUpperCase() === 'PATH') || 'Path';\n}\n","import process from 'node:process';\nimport path from 'node:path';\nimport {fileURLToPath} from 'node:url';\nimport pathKey from 'path-key';\n\nexport const npmRunPath = ({\n\tcwd = process.cwd(),\n\tpath: pathOption = process.env[pathKey()],\n\tpreferLocal = true,\n\texecPath = process.execPath,\n\taddExecPath = true,\n} = {}) => {\n\tconst cwdString = cwd instanceof URL ? fileURLToPath(cwd) : cwd;\n\tconst cwdPath = path.resolve(cwdString);\n\tconst result = [];\n\n\tif (preferLocal) {\n\t\tapplyPreferLocal(result, cwdPath);\n\t}\n\n\tif (addExecPath) {\n\t\tapplyExecPath(result, execPath, cwdPath);\n\t}\n\n\treturn [...result, pathOption].join(path.delimiter);\n};\n\nconst applyPreferLocal = (result, cwdPath) => {\n\tlet previous;\n\n\twhile (previous !== cwdPath) {\n\t\tresult.push(path.join(cwdPath, 'node_modules/.bin'));\n\t\tprevious = cwdPath;\n\t\tcwdPath = path.resolve(cwdPath, '..');\n\t}\n};\n\n// Ensure the running `node` binary is used\nconst applyExecPath = (result, execPath, cwdPath) => {\n\tconst execPathString = execPath instanceof URL ? fileURLToPath(execPath) : execPath;\n\tresult.push(path.resolve(cwdPath, execPathString, '..'));\n};\n\nexport const npmRunPathEnv = ({env = process.env, ...options} = {}) => {\n\tenv = {...env};\n\n\tconst pathName = pathKey({env});\n\toptions.path = env[pathName];\n\tenv[pathName] = npmRunPath(options);\n\n\treturn env;\n};\n","// When the subprocess fails, this is the error instance being returned.\n// If another error instance is being thrown, it is kept as `error.cause`.\nexport const getFinalError = (originalError, message, isSync) => {\n\tconst ErrorClass = isSync ? ExecaSyncError : ExecaError;\n\tconst options = originalError instanceof DiscardedError ? {} : {cause: originalError};\n\treturn new ErrorClass(message, options);\n};\n\n// Indicates that the error is used only to interrupt control flow, but not in the return value\nexport class DiscardedError extends Error {}\n\n// Proper way to set `error.name`: it should be inherited and non-enumerable\nconst setErrorName = (ErrorClass, value) => {\n\tObject.defineProperty(ErrorClass.prototype, 'name', {\n\t\tvalue,\n\t\twritable: true,\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t});\n\tObject.defineProperty(ErrorClass.prototype, execaErrorSymbol, {\n\t\tvalue: true,\n\t\twritable: false,\n\t\tenumerable: false,\n\t\tconfigurable: false,\n\t});\n};\n\n// Unlike `instanceof`, this works across realms\nexport const isExecaError = error => isErrorInstance(error) && execaErrorSymbol in error;\n\nconst execaErrorSymbol = Symbol('isExecaError');\n\nexport const isErrorInstance = value => Object.prototype.toString.call(value) === '[object Error]';\n\n// We use two different Error classes for async/sync methods since they have slightly different shape and types\nexport class ExecaError extends Error {}\nsetErrorName(ExecaError, ExecaError.name);\n\nexport class ExecaSyncError extends Error {}\nsetErrorName(ExecaSyncError, ExecaSyncError.name);\n","import {constants} from 'node:os';\n\n// Normalize signals for comparison purpose.\n// Also validate the signal exists.\nexport const normalizeKillSignal = killSignal => {\n\tconst optionName = 'option `killSignal`';\n\tif (killSignal === 0) {\n\t\tthrow new TypeError(`Invalid ${optionName}: 0 cannot be used.`);\n\t}\n\n\treturn normalizeSignal(killSignal, optionName);\n};\n\nexport const normalizeSignalArgument = signal => signal === 0\n\t? signal\n\t: normalizeSignal(signal, '`subprocess.kill()`\\'s argument');\n\nconst normalizeSignal = (signalNameOrInteger, optionName) => {\n\tif (Number.isInteger(signalNameOrInteger)) {\n\t\treturn normalizeSignalInteger(signalNameOrInteger, optionName);\n\t}\n\n\tif (typeof signalNameOrInteger === 'string') {\n\t\treturn normalizeSignalName(signalNameOrInteger, optionName);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${String(signalNameOrInteger)}: it must be a string or an integer.\\n${getAvailableSignals()}`);\n};\n\nconst normalizeSignalInteger = (signalInteger, optionName) => {\n\tif (signalsIntegerToName.has(signalInteger)) {\n\t\treturn signalsIntegerToName.get(signalInteger);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} ${signalInteger}: this signal integer does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getSignalsIntegerToName = () => new Map(Object.entries(constants.signals)\n\t.reverse()\n\t.map(([signalName, signalInteger]) => [signalInteger, signalName]));\n\nconst signalsIntegerToName = getSignalsIntegerToName();\n\nconst normalizeSignalName = (signalName, optionName) => {\n\tif (signalName in constants.signals) {\n\t\treturn signalName;\n\t}\n\n\tif (signalName.toUpperCase() in constants.signals) {\n\t\tthrow new TypeError(`Invalid ${optionName} '${signalName}': please rename it to '${signalName.toUpperCase()}'.`);\n\t}\n\n\tthrow new TypeError(`Invalid ${optionName} '${signalName}': this signal name does not exist.\\n${getAvailableSignals()}`);\n};\n\nconst getAvailableSignals = () => `Available signal names: ${getAvailableSignalNames()}.\nAvailable signal numbers: ${getAvailableSignalIntegers()}.`;\n\nconst getAvailableSignalNames = () => Object.keys(constants.signals)\n\t.sort()\n\t.map(signalName => `'${signalName}'`)\n\t.join(', ');\n\nconst getAvailableSignalIntegers = () => [...new Set(Object.values(constants.signals)\n\t.sort((signalInteger, signalIntegerTwo) => signalInteger - signalIntegerTwo))]\n\t.join(', ');\n","import {setTimeout} from 'node:timers/promises';\nimport {isErrorInstance} from '../return/final-error.js';\nimport {normalizeSignalArgument} from './signal.js';\n\n// Normalize the `forceKillAfterDelay` option\nexport const normalizeForceKillAfterDelay = forceKillAfterDelay => {\n\tif (forceKillAfterDelay === false) {\n\t\treturn forceKillAfterDelay;\n\t}\n\n\tif (forceKillAfterDelay === true) {\n\t\treturn DEFAULT_FORCE_KILL_TIMEOUT;\n\t}\n\n\tif (!Number.isFinite(forceKillAfterDelay) || forceKillAfterDelay < 0) {\n\t\tthrow new TypeError(`Expected the \\`forceKillAfterDelay\\` option to be a non-negative integer, got \\`${forceKillAfterDelay}\\` (${typeof forceKillAfterDelay})`);\n\t}\n\n\treturn forceKillAfterDelay;\n};\n\nconst DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;\n\n// Monkey-patches `subprocess.kill()` to add `forceKillAfterDelay` behavior and `.kill(error)`\nexport const subprocessKill = (\n\t{kill, options: {forceKillAfterDelay, killSignal}, onInternalError, controller},\n\tsignalOrError,\n\terrorArgument,\n) => {\n\tconst {signal, error} = parseKillArguments(signalOrError, errorArgument, killSignal);\n\temitKillError(error, onInternalError);\n\tconst killResult = kill(signal);\n\tsetKillTimeout({\n\t\tkill,\n\t\tsignal,\n\t\tforceKillAfterDelay,\n\t\tkillSignal,\n\t\tkillResult,\n\t\tcontroller,\n\t});\n\treturn killResult;\n};\n\nconst parseKillArguments = (signalOrError, errorArgument, killSignal) => {\n\tconst [signal = killSignal, error] = isErrorInstance(signalOrError)\n\t\t? [undefined, signalOrError]\n\t\t: [signalOrError, errorArgument];\n\n\tif (typeof signal !== 'string' && !Number.isInteger(signal)) {\n\t\tthrow new TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(signal)}`);\n\t}\n\n\tif (error !== undefined && !isErrorInstance(error)) {\n\t\tthrow new TypeError(`The second argument is optional. If specified, it must be an error instance: ${error}`);\n\t}\n\n\treturn {signal: normalizeSignalArgument(signal), error};\n};\n\n// Fails right away when calling `subprocess.kill(error)`.\n// Does not wait for actual signal termination.\n// Uses a deferred promise instead of the `error` event on the subprocess, as this is less intrusive.\nconst emitKillError = (error, onInternalError) => {\n\tif (error !== undefined) {\n\t\tonInternalError.reject(error);\n\t}\n};\n\nconst setKillTimeout = async ({kill, signal, forceKillAfterDelay, killSignal, killResult, controller}) => {\n\tif (!shouldForceKill(signal, forceKillAfterDelay, killSignal, killResult)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait setTimeout(forceKillAfterDelay, undefined, {signal: controller.signal});\n\t\tkill('SIGKILL');\n\t} catch {}\n};\n\nconst shouldForceKill = (signal, forceKillAfterDelay, killSignal, killResult) => signal === killSignal\n\t&& forceKillAfterDelay !== false\n\t&& killResult;\n","import {setTimeout} from 'node:timers/promises';\nimport {DiscardedError} from '../return/final-error.js';\n\n// Validate `timeout` option\nexport const validateTimeout = ({timeout}) => {\n\tif (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {\n\t\tthrow new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);\n\t}\n};\n\n// Fails when the `timeout` option is exceeded\nexport const throwOnTimeout = (subprocess, timeout, context, controller) => timeout === 0 || timeout === undefined\n\t? []\n\t: [killAfterTimeout(subprocess, timeout, context, controller)];\n\nconst killAfterTimeout = async (subprocess, timeout, context, {signal}) => {\n\tawait setTimeout(timeout, undefined, {signal});\n\tcontext.timedOut = true;\n\tsubprocess.kill();\n\tthrow new DiscardedError();\n};\n","// Validate `encoding` option\nexport const validateEncoding = ({encoding}) => {\n\tif (ENCODINGS.has(encoding)) {\n\t\treturn;\n\t}\n\n\tconst correctEncoding = getCorrectEncoding(encoding);\n\tif (correctEncoding !== undefined) {\n\t\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to ${serializeEncoding(correctEncoding)}.`);\n\t}\n\n\tconst correctEncodings = [...ENCODINGS].map(correctEncoding => serializeEncoding(correctEncoding)).join(', ');\n\tthrow new TypeError(`Invalid option \\`encoding: ${serializeEncoding(encoding)}\\`.\nPlease rename it to one of: ${correctEncodings}.`);\n};\n\nconst TEXT_ENCODINGS = new Set(['utf8', 'utf16le']);\nexport const BINARY_ENCODINGS = new Set(['buffer', 'hex', 'base64', 'base64url', 'latin1', 'ascii']);\nconst ENCODINGS = new Set([...TEXT_ENCODINGS, ...BINARY_ENCODINGS]);\n\nconst getCorrectEncoding = encoding => {\n\tif (encoding === null) {\n\t\treturn 'buffer';\n\t}\n\n\tif (typeof encoding !== 'string') {\n\t\treturn;\n\t}\n\n\tconst lowerEncoding = encoding.toLowerCase();\n\tif (lowerEncoding in ENCODING_ALIASES) {\n\t\treturn ENCODING_ALIASES[lowerEncoding];\n\t}\n\n\tif (ENCODINGS.has(lowerEncoding)) {\n\t\treturn lowerEncoding;\n\t}\n};\n\nconst ENCODING_ALIASES = {\n\t// eslint-disable-next-line unicorn/text-encoding-identifier-case\n\t'utf-8': 'utf8',\n\t'utf-16le': 'utf16le',\n\t'ucs-2': 'utf16le',\n\tucs2: 'utf16le',\n\tbinary: 'latin1',\n};\n\nconst serializeEncoding = encoding => typeof encoding === 'string' ? `\"${encoding}\"` : String(encoding);\n","import {statSync} from 'node:fs';\nimport {resolve} from 'node:path';\nimport process from 'node:process';\nimport {safeNormalizeFileUrl} from './file-url.js';\n\n// Normalize `cwd` option\nexport const normalizeCwd = (cwd = getDefaultCwd()) => {\n\tconst cwdString = safeNormalizeFileUrl(cwd, 'The \"cwd\" option');\n\treturn resolve(cwdString);\n};\n\nconst getDefaultCwd = () => {\n\ttry {\n\t\treturn process.cwd();\n\t} catch (error) {\n\t\terror.message = `The current directory does not exist.\\n${error.message}`;\n\t\tthrow error;\n\t}\n};\n\n// When `cwd` option has an invalid value, provide with a better error message\nexport const fixCwdError = (originalMessage, cwd) => {\n\tif (cwd === getDefaultCwd()) {\n\t\treturn originalMessage;\n\t}\n\n\tlet cwdStat;\n\ttry {\n\t\tcwdStat = statSync(cwd);\n\t} catch (error) {\n\t\treturn `The \"cwd\" option is invalid: ${cwd}.\\n${error.message}\\n${originalMessage}`;\n\t}\n\n\tif (!cwdStat.isDirectory()) {\n\t\treturn `The \"cwd\" option is not a directory: ${cwd}.\\n${originalMessage}`;\n\t}\n\n\treturn originalMessage;\n};\n","import {basename} from 'node:path';\nimport process from 'node:process';\nimport crossSpawn from 'cross-spawn';\nimport {npmRunPathEnv} from 'npm-run-path';\nimport {normalizeForceKillAfterDelay} from '../terminate/kill.js';\nimport {normalizeKillSignal} from '../terminate/signal.js';\nimport {validateTimeout} from '../terminate/timeout.js';\nimport {handleNodeOption} from '../methods/node.js';\nimport {validateEncoding, BINARY_ENCODINGS} from './encoding-option.js';\nimport {normalizeCwd} from './cwd.js';\nimport {normalizeFileUrl} from './file-url.js';\nimport {normalizeFdSpecificOptions} from './specific.js';\n\n// Normalize the options object, and sometimes also the file paths and arguments.\n// Applies default values, validate allowed options, normalize them.\nexport const normalizeOptions = (filePath, rawArguments, rawOptions) => {\n\trawOptions.cwd = normalizeCwd(rawOptions.cwd);\n\tconst [processedFile, processedArguments, processedOptions] = handleNodeOption(filePath, rawArguments, rawOptions);\n\n\tconst {command: file, args: commandArguments, options: initialOptions} = crossSpawn._parse(processedFile, processedArguments, processedOptions);\n\n\tconst fdOptions = normalizeFdSpecificOptions(initialOptions);\n\tconst options = addDefaultOptions(fdOptions);\n\tvalidateTimeout(options);\n\tvalidateEncoding(options);\n\toptions.shell = normalizeFileUrl(options.shell);\n\toptions.env = getEnv(options);\n\toptions.killSignal = normalizeKillSignal(options.killSignal);\n\toptions.forceKillAfterDelay = normalizeForceKillAfterDelay(options.forceKillAfterDelay);\n\toptions.lines = options.lines.map((lines, fdNumber) => lines && !BINARY_ENCODINGS.has(options.encoding) && options.buffer[fdNumber]);\n\n\tif (process.platform === 'win32' && basename(file, '.exe') === 'cmd') {\n\t\t// #116\n\t\tcommandArguments.unshift('/q');\n\t}\n\n\treturn {file, commandArguments, options};\n};\n\nconst addDefaultOptions = ({\n\textendEnv = true,\n\tpreferLocal = false,\n\tcwd,\n\tlocalDir: localDirectory = cwd,\n\tencoding = 'utf8',\n\treject = true,\n\tcleanup = true,\n\tall = false,\n\twindowsHide = true,\n\tkillSignal = 'SIGTERM',\n\tforceKillAfterDelay = true,\n\tipc = false,\n\tserialization = 'advanced',\n\t...options\n}) => ({\n\t...options,\n\textendEnv,\n\tpreferLocal,\n\tcwd,\n\tlocalDirectory,\n\tencoding,\n\treject,\n\tcleanup,\n\tall,\n\twindowsHide,\n\tkillSignal,\n\tforceKillAfterDelay,\n\tipc,\n\tserialization,\n});\n\nconst getEnv = ({env: envOption, extendEnv, preferLocal, node, localDirectory, nodePath}) => {\n\tconst env = extendEnv ? {...process.env, ...envOption} : envOption;\n\n\tif (preferLocal || node) {\n\t\treturn npmRunPathEnv({\n\t\t\tenv,\n\t\t\tcwd: localDirectory,\n\t\t\texecPath: nodePath,\n\t\t\tpreferLocal,\n\t\t\taddExecPath: node,\n\t\t});\n\t}\n\n\treturn env;\n};\n","import {execPath, execArgv} from 'node:process';\nimport {basename, resolve} from 'node:path';\nimport {safeNormalizeFileUrl} from '../arguments/file-url.js';\n\n// `execaNode()` is a shortcut for `execa(..., {node: true})`\nexport const mapNode = ({options}) => {\n\tif (options.node === false) {\n\t\tthrow new TypeError('The \"node\" option cannot be false with `execaNode()`.');\n\t}\n\n\treturn {options: {...options, node: true}};\n};\n\n// Applies the `node: true` option, and the related `nodePath`/`nodeOptions` options.\n// Modifies the file commands/arguments to ensure the same Node binary and flags are re-used.\n// Also adds `ipc: true` and `shell: false`.\nexport const handleNodeOption = (file, commandArguments, {\n\tnode: shouldHandleNode = false,\n\tnodePath = execPath,\n\tnodeOptions = execArgv.filter(nodeOption => !nodeOption.startsWith('--inspect')),\n\tcwd,\n\texecPath: formerNodePath,\n\t...options\n}) => {\n\tif (formerNodePath !== undefined) {\n\t\tthrow new TypeError('The \"execPath\" option has been removed. Please use the \"nodePath\" option instead.');\n\t}\n\n\tconst normalizedNodePath = safeNormalizeFileUrl(nodePath, 'The \"nodePath\" option');\n\tconst resolvedNodePath = resolve(cwd, normalizedNodePath);\n\tconst newOptions = {\n\t\t...options,\n\t\tnodePath: resolvedNodePath,\n\t\tnode: shouldHandleNode,\n\t\tcwd,\n\t};\n\n\tif (!shouldHandleNode) {\n\t\treturn [file, commandArguments, newOptions];\n\t}\n\n\tif (basename(file, '.exe') === 'node') {\n\t\tthrow new TypeError('When the \"node\" option is true, the first argument does not need to be \"node\".');\n\t}\n\n\treturn [\n\t\tresolvedNodePath,\n\t\t[...nodeOptions, file, ...commandArguments],\n\t\t{ipc: true, ...newOptions, shell: false},\n\t];\n};\n","\nexport const getRealtimeSignals=()=>{\nconst length=SIGRTMAX-SIGRTMIN+1;\nreturn Array.from({length},getRealtimeSignal)\n};\n\nconst getRealtimeSignal=(value,index)=>({\nname:`SIGRT${index+1}`,\nnumber:SIGRTMIN+index,\naction:\"terminate\",\ndescription:\"Application-specific signal (realtime)\",\nstandard:\"posix\"\n});\n\nconst SIGRTMIN=34;\nexport const SIGRTMAX=64;","\n\nexport const SIGNALS=[\n{\nname:\"SIGHUP\",\nnumber:1,\naction:\"terminate\",\ndescription:\"Terminal closed\",\nstandard:\"posix\"\n},\n{\nname:\"SIGINT\",\nnumber:2,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-C\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGQUIT\",\nnumber:3,\naction:\"core\",\ndescription:\"User interruption with CTRL-\\\\\",\nstandard:\"posix\"\n},\n{\nname:\"SIGILL\",\nnumber:4,\naction:\"core\",\ndescription:\"Invalid machine instruction\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGTRAP\",\nnumber:5,\naction:\"core\",\ndescription:\"Debugger breakpoint\",\nstandard:\"posix\"\n},\n{\nname:\"SIGABRT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGIOT\",\nnumber:6,\naction:\"core\",\ndescription:\"Aborted\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGBUS\",\nnumber:7,\naction:\"core\",\ndescription:\n\"Bus error due to misaligned, non-existing address or paging error\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGEMT\",\nnumber:7,\naction:\"terminate\",\ndescription:\"Command should be emulated but is not implemented\",\nstandard:\"other\"\n},\n{\nname:\"SIGFPE\",\nnumber:8,\naction:\"core\",\ndescription:\"Floating point arithmetic error\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGKILL\",\nnumber:9,\naction:\"terminate\",\ndescription:\"Forced termination\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGUSR1\",\nnumber:10,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGSEGV\",\nnumber:11,\naction:\"core\",\ndescription:\"Segmentation fault\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGUSR2\",\nnumber:12,\naction:\"terminate\",\ndescription:\"Application-specific signal\",\nstandard:\"posix\"\n},\n{\nname:\"SIGPIPE\",\nnumber:13,\naction:\"terminate\",\ndescription:\"Broken pipe or socket\",\nstandard:\"posix\"\n},\n{\nname:\"SIGALRM\",\nnumber:14,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTERM\",\nnumber:15,\naction:\"terminate\",\ndescription:\"Termination\",\nstandard:\"ansi\"\n},\n{\nname:\"SIGSTKFLT\",\nnumber:16,\naction:\"terminate\",\ndescription:\"Stack is empty or overflowed\",\nstandard:\"other\"\n},\n{\nname:\"SIGCHLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"posix\"\n},\n{\nname:\"SIGCLD\",\nnumber:17,\naction:\"ignore\",\ndescription:\"Child process terminated, paused or unpaused\",\nstandard:\"other\"\n},\n{\nname:\"SIGCONT\",\nnumber:18,\naction:\"unpause\",\ndescription:\"Unpaused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGSTOP\",\nnumber:19,\naction:\"pause\",\ndescription:\"Paused\",\nstandard:\"posix\",\nforced:true\n},\n{\nname:\"SIGTSTP\",\nnumber:20,\naction:\"pause\",\ndescription:\"Paused using CTRL-Z or \\\"suspend\\\"\",\nstandard:\"posix\"\n},\n{\nname:\"SIGTTIN\",\nnumber:21,\naction:\"pause\",\ndescription:\"Background process cannot read terminal input\",\nstandard:\"posix\"\n},\n{\nname:\"SIGBREAK\",\nnumber:21,\naction:\"terminate\",\ndescription:\"User interruption with CTRL-BREAK\",\nstandard:\"other\"\n},\n{\nname:\"SIGTTOU\",\nnumber:22,\naction:\"pause\",\ndescription:\"Background process cannot write to terminal output\",\nstandard:\"posix\"\n},\n{\nname:\"SIGURG\",\nnumber:23,\naction:\"ignore\",\ndescription:\"Socket received out-of-band data\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXCPU\",\nnumber:24,\naction:\"core\",\ndescription:\"Process timed out\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGXFSZ\",\nnumber:25,\naction:\"core\",\ndescription:\"File too big\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGVTALRM\",\nnumber:26,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGPROF\",\nnumber:27,\naction:\"terminate\",\ndescription:\"Timeout or timer\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGWINCH\",\nnumber:28,\naction:\"ignore\",\ndescription:\"Terminal window size changed\",\nstandard:\"bsd\"\n},\n{\nname:\"SIGIO\",\nnumber:29,\naction:\"terminate\",\ndescription:\"I/O is available\",\nstandard:\"other\"\n},\n{\nname:\"SIGPOLL\",\nnumber:29,\naction:\"terminate\",\ndescription:\"Watched event\",\nstandard:\"other\"\n},\n{\nname:\"SIGINFO\",\nnumber:29,\naction:\"ignore\",\ndescription:\"Request for process information\",\nstandard:\"other\"\n},\n{\nname:\"SIGPWR\",\nnumber:30,\naction:\"terminate\",\ndescription:\"Device running out of power\",\nstandard:\"systemv\"\n},\n{\nname:\"SIGSYS\",\nnumber:31,\naction:\"core\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n},\n{\nname:\"SIGUNUSED\",\nnumber:31,\naction:\"terminate\",\ndescription:\"Invalid system call\",\nstandard:\"other\"\n}];","import{constants}from\"node:os\";\n\nimport{SIGNALS}from\"./core.js\";\nimport{getRealtimeSignals}from\"./realtime.js\";\n\n\n\nexport const getSignals=()=>{\nconst realtimeSignals=getRealtimeSignals();\nconst signals=[...SIGNALS,...realtimeSignals].map(normalizeSignal);\nreturn signals\n};\n\n\n\n\n\n\n\nconst normalizeSignal=({\nname,\nnumber:defaultNumber,\ndescription,\naction,\nforced=false,\nstandard\n})=>{\nconst{\nsignals:{[name]:constantSignal}\n}=constants;\nconst supported=constantSignal!==undefined;\nconst number=supported?constantSignal:defaultNumber;\nreturn{name,number,description,supported,action,forced,standard}\n};","import{constants}from\"node:os\";\n\nimport{SIGRTMAX}from\"./realtime.js\";\nimport{getSignals}from\"./signals.js\";\n\n\n\nconst getSignalsByName=()=>{\nconst signals=getSignals();\nreturn Object.fromEntries(signals.map(getSignalByName))\n};\n\nconst getSignalByName=({\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n})=>[name,{name,number,description,supported,action,forced,standard}];\n\nexport const signalsByName=getSignalsByName();\n\n\n\n\nconst getSignalsByNumber=()=>{\nconst signals=getSignals();\nconst length=SIGRTMAX+1;\nconst signalsA=Array.from({length},(value,number)=>\ngetSignalByNumber(number,signals)\n);\nreturn Object.assign({},...signalsA)\n};\n\nconst getSignalByNumber=(number,signals)=>{\nconst signal=findSignalByNumber(number,signals);\n\nif(signal===undefined){\nreturn{}\n}\n\nconst{name,description,supported,action,forced,standard}=signal;\nreturn{\n[number]:{\nname,\nnumber,\ndescription,\nsupported,\naction,\nforced,\nstandard\n}\n}\n};\n\n\n\nconst findSignalByNumber=(number,signals)=>{\nconst signal=signals.find(({name})=>constants.signals[name]===number);\n\nif(signal!==undefined){\nreturn signal\n}\n\nreturn signals.find((signalA)=>signalA.number===number)\n};\n\nexport const signalsByNumber=getSignalsByNumber();","export default function stripFinalNewline(input) {\n\tif (typeof input === 'string') {\n\t\treturn stripFinalNewlineString(input);\n\t}\n\n\tif (!(ArrayBuffer.isView(input) && input.BYTES_PER_ELEMENT === 1)) {\n\t\tthrow new Error('Input must be a string or a Uint8Array');\n\t}\n\n\treturn stripFinalNewlineBinary(input);\n}\n\nconst stripFinalNewlineString = input =>\n\tinput.at(-1) === LF\n\t\t? input.slice(0, input.at(-2) === CR ? -2 : -1)\n\t\t: input;\n\nconst stripFinalNewlineBinary = input =>\n\tinput.at(-1) === LF_BINARY\n\t\t? input.subarray(0, input.at(-2) === CR_BINARY ? -2 : -1)\n\t\t: input;\n\nconst LF = '\\n';\nconst LF_BINARY = LF.codePointAt(0);\nconst CR = '\\r';\nconst CR_BINARY = CR.codePointAt(0);\n","export function isStream(stream, {checkOpen = true} = {}) {\n\treturn stream !== null\n\t\t&& typeof stream === 'object'\n\t\t&& (stream.writable || stream.readable || !checkOpen || (stream.writable === undefined && stream.readable === undefined))\n\t\t&& typeof stream.pipe === 'function';\n}\n\nexport function isWritableStream(stream, {checkOpen = true} = {}) {\n\treturn isStream(stream, {checkOpen})\n\t\t&& (stream.writable || !checkOpen)\n\t\t&& typeof stream.write === 'function'\n\t\t&& typeof stream.end === 'function'\n\t\t&& typeof stream.writable === 'boolean'\n\t\t&& typeof stream.writableObjectMode === 'boolean'\n\t\t&& typeof stream.destroy === 'function'\n\t\t&& typeof stream.destroyed === 'boolean';\n}\n\nexport function isReadableStream(stream, {checkOpen = true} = {}) {\n\treturn isStream(stream, {checkOpen})\n\t\t&& (stream.readable || !checkOpen)\n\t\t&& typeof stream.read === 'function'\n\t\t&& typeof stream.readable === 'boolean'\n\t\t&& typeof stream.readableObjectMode === 'boolean'\n\t\t&& typeof stream.destroy === 'function'\n\t\t&& typeof stream.destroyed === 'boolean';\n}\n\nexport function isDuplexStream(stream, options) {\n\treturn isWritableStream(stream, options)\n\t\t&& isReadableStream(stream, options);\n}\n\nexport function isTransformStream(stream, options) {\n\treturn isDuplexStream(stream, options)\n\t\t&& typeof stream._transform === 'function';\n}\n","const a = Object.getPrototypeOf(\n  Object.getPrototypeOf(\n    /* istanbul ignore next */\n    async function* () {\n    }\n  ).prototype\n);\nclass c {\n  #t;\n  #n;\n  #r = !1;\n  #e = void 0;\n  constructor(e, t) {\n    this.#t = e, this.#n = t;\n  }\n  next() {\n    const e = () => this.#s();\n    return this.#e = this.#e ? this.#e.then(e, e) : e(), this.#e;\n  }\n  return(e) {\n    const t = () => this.#i(e);\n    return this.#e ? this.#e.then(t, t) : t();\n  }\n  async #s() {\n    if (this.#r)\n      return {\n        done: !0,\n        value: void 0\n      };\n    let e;\n    try {\n      e = await this.#t.read();\n    } catch (t) {\n      throw this.#e = void 0, this.#r = !0, this.#t.releaseLock(), t;\n    }\n    return e.done && (this.#e = void 0, this.#r = !0, this.#t.releaseLock()), e;\n  }\n  async #i(e) {\n    if (this.#r)\n      return {\n        done: !0,\n        value: e\n      };\n    if (this.#r = !0, !this.#n) {\n      const t = this.#t.cancel(e);\n      return this.#t.releaseLock(), await t, {\n        done: !0,\n        value: e\n      };\n    }\n    return this.#t.releaseLock(), {\n      done: !0,\n      value: e\n    };\n  }\n}\nconst n = Symbol();\nfunction i() {\n  return this[n].next();\n}\nObject.defineProperty(i, \"name\", { value: \"next\" });\nfunction o(r) {\n  return this[n].return(r);\n}\nObject.defineProperty(o, \"name\", { value: \"return\" });\nconst u = Object.create(a, {\n  next: {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: i\n  },\n  return: {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: o\n  }\n});\nfunction h({ preventCancel: r = !1 } = {}) {\n  const e = this.getReader(), t = new c(\n    e,\n    r\n  ), s = Object.create(u);\n  return s[n] = t, s;\n}\nexport {\n  h as asyncIterator\n};\n","import {isReadableStream} from 'is-stream';\nimport {asyncIterator} from '@sec-ant/readable-stream/ponyfill';\n\nexport const getAsyncIterable = stream => {\n\tif (isReadableStream(stream, {checkOpen: false}) && nodeImports.on !== undefined) {\n\t\treturn getStreamIterable(stream);\n\t}\n\n\tif (typeof stream?.[Symbol.asyncIterator] === 'function') {\n\t\treturn stream;\n\t}\n\n\t// `ReadableStream[Symbol.asyncIterator]` support is missing in multiple browsers, so we ponyfill it\n\tif (toString.call(stream) === '[object ReadableStream]') {\n\t\treturn asyncIterator.call(stream);\n\t}\n\n\tthrow new TypeError('The first argument must be a Readable, a ReadableStream, or an async iterable.');\n};\n\nconst {toString} = Object.prototype;\n\n// The default iterable for Node.js streams does not allow for multiple readers at once, so we re-implement it\nconst getStreamIterable = async function * (stream) {\n\tconst controller = new AbortController();\n\tconst state = {};\n\thandleStreamEnd(stream, controller, state);\n\n\ttry {\n\t\tfor await (const [chunk] of nodeImports.on(stream, 'data', {signal: controller.signal})) {\n\t\t\tyield chunk;\n\t\t}\n\t} catch (error) {\n\t\t// Stream failure, for example due to `stream.destroy(error)`\n\t\tif (state.error !== undefined) {\n\t\t\tthrow state.error;\n\t\t// `error` event directly emitted on stream\n\t\t} else if (!controller.signal.aborted) {\n\t\t\tthrow error;\n\t\t// Otherwise, stream completed successfully\n\t\t}\n\t\t// The `finally` block also runs when the caller throws, for example due to the `maxBuffer` option\n\t} finally {\n\t\tstream.destroy();\n\t}\n};\n\nconst handleStreamEnd = async (stream, controller, state) => {\n\ttry {\n\t\tawait nodeImports.finished(stream, {\n\t\t\tcleanup: true,\n\t\t\treadable: true,\n\t\t\twritable: false,\n\t\t\terror: false,\n\t\t});\n\t} catch (error) {\n\t\tstate.error = error;\n\t} finally {\n\t\tcontroller.abort();\n\t}\n};\n\n// Loaded by the Node entrypoint, but not by the browser one.\n// This prevents using dynamic imports.\nexport const nodeImports = {};\n","import {getAsyncIterable} from './stream.js';\n\nexport const getStreamContents = async (stream, {init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize}, {maxBuffer = Number.POSITIVE_INFINITY} = {}) => {\n\tconst asyncIterable = getAsyncIterable(stream);\n\n\tconst state = init();\n\tstate.length = 0;\n\n\ttry {\n\t\tfor await (const chunk of asyncIterable) {\n\t\t\tconst chunkType = getChunkType(chunk);\n\t\t\tconst convertedChunk = convertChunk[chunkType](chunk, state);\n\t\t\tappendChunk({\n\t\t\t\tconvertedChunk,\n\t\t\t\tstate,\n\t\t\t\tgetSize,\n\t\t\t\ttruncateChunk,\n\t\t\t\taddChunk,\n\t\t\t\tmaxBuffer,\n\t\t\t});\n\t\t}\n\n\t\tappendFinalChunk({\n\t\t\tstate,\n\t\t\tconvertChunk,\n\t\t\tgetSize,\n\t\t\ttruncateChunk,\n\t\t\taddChunk,\n\t\t\tgetFinalChunk,\n\t\t\tmaxBuffer,\n\t\t});\n\t\treturn finalize(state);\n\t} catch (error) {\n\t\tconst normalizedError = typeof error === 'object' && error !== null ? error : new Error(error);\n\t\tnormalizedError.bufferedData = finalize(state);\n\t\tthrow normalizedError;\n\t}\n};\n\nconst appendFinalChunk = ({state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer}) => {\n\tconst convertedChunk = getFinalChunk(state);\n\tif (convertedChunk !== undefined) {\n\t\tappendChunk({\n\t\t\tconvertedChunk,\n\t\t\tstate,\n\t\t\tgetSize,\n\t\t\ttruncateChunk,\n\t\t\taddChunk,\n\t\t\tmaxBuffer,\n\t\t});\n\t}\n};\n\nconst appendChunk = ({convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer}) => {\n\tconst chunkSize = getSize(convertedChunk);\n\tconst newLength = state.length + chunkSize;\n\n\tif (newLength <= maxBuffer) {\n\t\taddNewChunk(convertedChunk, state, addChunk, newLength);\n\t\treturn;\n\t}\n\n\tconst truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);\n\n\tif (truncatedChunk !== undefined) {\n\t\taddNewChunk(truncatedChunk, state, addChunk, maxBuffer);\n\t}\n\n\tthrow new MaxBufferError();\n};\n\nconst addNewChunk = (convertedChunk, state, addChunk, newLength) => {\n\tstate.contents = addChunk(convertedChunk, state, newLength);\n\tstate.length = newLength;\n};\n\nconst getChunkType = chunk => {\n\tconst typeOfChunk = typeof chunk;\n\n\tif (typeOfChunk === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (typeOfChunk !== 'object' || chunk === null) {\n\t\treturn 'others';\n\t}\n\n\tif (globalThis.Buffer?.isBuffer(chunk)) {\n\t\treturn 'buffer';\n\t}\n\n\tconst prototypeName = objectToString.call(chunk);\n\n\tif (prototypeName === '[object ArrayBuffer]') {\n\t\treturn 'arrayBuffer';\n\t}\n\n\tif (prototypeName === '[object DataView]') {\n\t\treturn 'dataView';\n\t}\n\n\tif (\n\t\tNumber.isInteger(chunk.byteLength)\n\t\t&& Number.isInteger(chunk.byteOffset)\n\t\t&& objectToString.call(chunk.buffer) === '[object ArrayBuffer]'\n\t) {\n\t\treturn 'typedArray';\n\t}\n\n\treturn 'others';\n};\n\nconst {toString: objectToString} = Object.prototype;\n\nexport class MaxBufferError extends Error {\n\tname = 'MaxBufferError';\n\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t}\n}\n","import {MaxBufferError} from 'get-stream';\nimport {getStreamName} from '../utils/standard-stream.js';\n\n// When the `maxBuffer` option is hit, a MaxBufferError is thrown.\n// The stream is aborted, then specific information is kept for the error message.\nexport const handleMaxBuffer = ({error, stream, readableObjectMode, lines, encoding, fdNumber}) => {\n\tif (!(error instanceof MaxBufferError)) {\n\t\tthrow error;\n\t}\n\n\tif (fdNumber === 'all') {\n\t\treturn error;\n\t}\n\n\tconst unit = getMaxBufferUnit(readableObjectMode, lines, encoding);\n\terror.maxBufferInfo = {fdNumber, unit};\n\tstream.destroy();\n\tthrow error;\n};\n\nconst getMaxBufferUnit = (readableObjectMode, lines, encoding) => {\n\tif (readableObjectMode) {\n\t\treturn 'objects';\n\t}\n\n\tif (lines) {\n\t\treturn 'lines';\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn 'bytes';\n\t}\n\n\treturn 'characters';\n};\n\n// Error message when `maxBuffer` is hit\nexport const getMaxBufferMessage = (error, maxBuffer) => {\n\tconst {streamName, threshold, unit} = getMaxBufferInfo(error, maxBuffer);\n\treturn `Command's ${streamName} was larger than ${threshold} ${unit}`;\n};\n\nconst getMaxBufferInfo = (error, maxBuffer) => {\n\tif (error?.maxBufferInfo === undefined) {\n\t\treturn {streamName: 'output', threshold: maxBuffer[1], unit: 'bytes'};\n\t}\n\n\tconst {maxBufferInfo: {fdNumber, unit}} = error;\n\tdelete error.maxBufferInfo;\n\treturn {streamName: getStreamName(fdNumber), threshold: maxBuffer[fdNumber], unit};\n};\n\n// The only way to apply `maxBuffer` with `spawnSync()` is to use the native `maxBuffer` option Node.js provides.\n// However, this has multiple limitations, and cannot behave the exact same way as the async behavior.\n// When the `maxBuffer` is hit, a `ENOBUFS` error is thrown.\nexport const isMaxBufferSync = (resultError, output, maxBuffer) => resultError?.code === 'ENOBUFS'\n\t&& output !== null\n\t&& output.some(result => result !== null && result.length > getMaxBufferSync(maxBuffer));\n\n// When `maxBuffer` is hit, ensure the result is truncated\nexport const truncateMaxBufferSync = (result, isMaxBuffer, maxBuffer) => {\n\tif (!isMaxBuffer) {\n\t\treturn result;\n\t}\n\n\tconst maxBufferValue = getMaxBufferSync(maxBuffer);\n\treturn result.length > maxBufferValue ? result.slice(0, maxBufferValue) : result;\n};\n\n// `spawnSync()` does not allow differentiating `maxBuffer` per file descriptor, so we always use `stdout`\nexport const getMaxBufferSync = ([, stdoutMaxBuffer]) => stdoutMaxBuffer;\n","import stripFinalNewline from 'strip-final-newline';\nimport {isUint8Array, uint8ArrayToString} from '../utils/uint-array.js';\nimport {fixCwdError} from '../arguments/cwd.js';\nimport {escapeLines} from '../arguments/escape.js';\nimport {getMaxBufferMessage} from '../io/max-buffer.js';\nimport {DiscardedError, isExecaError} from './final-error.js';\n\n// Computes `error.message`, `error.shortMessage` and `error.originalMessage`\nexport const createMessages = ({\n\tstdio,\n\tall,\n\toriginalError,\n\tsignal,\n\tsignalDescription,\n\texitCode,\n\tescapedCommand,\n\ttimedOut,\n\tisCanceled,\n\tisMaxBuffer,\n\tmaxBuffer,\n\ttimeout,\n\tcwd,\n}) => {\n\tconst errorCode = originalError?.code;\n\tconst prefix = getErrorPrefix({\n\t\toriginalError,\n\t\ttimedOut,\n\t\ttimeout,\n\t\tisMaxBuffer,\n\t\tmaxBuffer,\n\t\terrorCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tisCanceled,\n\t});\n\tconst originalMessage = getOriginalMessage(originalError, cwd);\n\tconst suffix = originalMessage === undefined ? '' : `\\n${originalMessage}`;\n\tconst shortMessage = `${prefix}: ${escapedCommand}${suffix}`;\n\tconst messageStdio = all === undefined ? [stdio[2], stdio[1]] : [all];\n\tconst message = [shortMessage, ...messageStdio, ...stdio.slice(3)]\n\t\t.map(messagePart => escapeLines(stripFinalNewline(serializeMessagePart(messagePart))))\n\t\t.filter(Boolean)\n\t\t.join('\\n\\n');\n\treturn {originalMessage, shortMessage, message};\n};\n\nconst getErrorPrefix = ({originalError, timedOut, timeout, isMaxBuffer, maxBuffer, errorCode, signal, signalDescription, exitCode, isCanceled}) => {\n\tif (timedOut) {\n\t\treturn `Command timed out after ${timeout} milliseconds`;\n\t}\n\n\tif (isCanceled) {\n\t\treturn 'Command was canceled';\n\t}\n\n\tif (isMaxBuffer) {\n\t\treturn getMaxBufferMessage(originalError, maxBuffer);\n\t}\n\n\tif (errorCode !== undefined) {\n\t\treturn `Command failed with ${errorCode}`;\n\t}\n\n\tif (signal !== undefined) {\n\t\treturn `Command was killed with ${signal} (${signalDescription})`;\n\t}\n\n\tif (exitCode !== undefined) {\n\t\treturn `Command failed with exit code ${exitCode}`;\n\t}\n\n\treturn 'Command failed';\n};\n\nconst getOriginalMessage = (originalError, cwd) => {\n\tif (originalError instanceof DiscardedError) {\n\t\treturn;\n\t}\n\n\tconst originalMessage = isExecaError(originalError)\n\t\t? originalError.originalMessage\n\t\t: String(originalError?.message ?? originalError);\n\tconst escapedOriginalMessage = escapeLines(fixCwdError(originalMessage, cwd));\n\treturn escapedOriginalMessage === '' ? undefined : escapedOriginalMessage;\n};\n\nconst serializeMessagePart = messagePart => Array.isArray(messagePart)\n\t? messagePart.map(messageItem => stripFinalNewline(serializeMessageItem(messageItem))).filter(Boolean).join('\\n')\n\t: serializeMessageItem(messagePart);\n\nconst serializeMessageItem = messageItem => {\n\tif (typeof messageItem === 'string') {\n\t\treturn messageItem;\n\t}\n\n\tif (isUint8Array(messageItem)) {\n\t\treturn uint8ArrayToString(messageItem);\n\t}\n\n\treturn '';\n};\n","import {signalsByName} from 'human-signals';\nimport {getDurationMs} from './duration.js';\nimport {getFinalError} from './final-error.js';\nimport {createMessages} from './message.js';\n\n// Object returned on subprocess success\nexport const makeSuccessResult = ({\n\tcommand,\n\tescapedCommand,\n\tstdio,\n\tall,\n\toptions: {cwd},\n\tstartTime,\n}) => omitUndefinedProperties({\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: false,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisTerminated: false,\n\tisMaxBuffer: false,\n\texitCode: 0,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tpipedFrom: [],\n});\n\n// Object returned on subprocess failure before spawning\nexport const makeEarlyError = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tfileDescriptors,\n\toptions,\n\tstartTime,\n\tisSync,\n}) => makeError({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut: false,\n\tisCanceled: false,\n\tisMaxBuffer: false,\n\tstdio: Array.from({length: fileDescriptors.length}),\n\toptions,\n\tisSync,\n});\n\n// Object returned on subprocess failure\nexport const makeError = ({\n\terror: originalError,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisMaxBuffer,\n\texitCode: rawExitCode,\n\tsignal: rawSignal,\n\tstdio,\n\tall,\n\toptions: {timeoutDuration, timeout = timeoutDuration, cwd, maxBuffer},\n\tisSync,\n}) => {\n\tconst {exitCode, signal, signalDescription} = normalizeExitPayload(rawExitCode, rawSignal);\n\tconst {originalMessage, shortMessage, message} = createMessages({\n\t\tstdio,\n\t\tall,\n\t\toriginalError,\n\t\tsignal,\n\t\tsignalDescription,\n\t\texitCode,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisMaxBuffer,\n\t\tmaxBuffer,\n\t\ttimeout,\n\t\tcwd,\n\t});\n\tconst error = getFinalError(originalError, message, isSync);\n\tObject.assign(error, getErrorProperties({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t\ttimedOut,\n\t\tisCanceled,\n\t\tisMaxBuffer,\n\t\texitCode,\n\t\tsignal,\n\t\tsignalDescription,\n\t\tstdio,\n\t\tall,\n\t\tcwd,\n\t\toriginalMessage,\n\t\tshortMessage,\n\t}));\n\treturn error;\n};\n\nconst getErrorProperties = ({\n\terror,\n\tcommand,\n\tescapedCommand,\n\tstartTime,\n\ttimedOut,\n\tisCanceled,\n\tisMaxBuffer,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tstdio,\n\tall,\n\tcwd,\n\toriginalMessage,\n\tshortMessage,\n}) => omitUndefinedProperties({\n\tshortMessage,\n\toriginalMessage,\n\tcommand,\n\tescapedCommand,\n\tcwd,\n\tdurationMs: getDurationMs(startTime),\n\tfailed: true,\n\ttimedOut,\n\tisCanceled,\n\tisTerminated: signal !== undefined,\n\tisMaxBuffer,\n\texitCode,\n\tsignal,\n\tsignalDescription,\n\tcode: error.cause?.code,\n\tstdout: stdio[1],\n\tstderr: stdio[2],\n\tall,\n\tstdio,\n\tpipedFrom: [],\n});\n\nconst omitUndefinedProperties = result => Object.fromEntries(Object.entries(result).filter(([, value]) => value !== undefined));\n\n// `signal` and `exitCode` emitted on `subprocess.on('exit')` event can be `null`.\n// We normalize them to `undefined`\nconst normalizeExitPayload = (rawExitCode, rawSignal) => {\n\tconst exitCode = rawExitCode === null ? undefined : rawExitCode;\n\tconst signal = rawSignal === null ? undefined : rawSignal;\n\tconst signalDescription = signal === undefined ? undefined : signalsByName[rawSignal].description;\n\treturn {exitCode, signal, signalDescription};\n};\n","const toZeroIfInfinity = value => Number.isFinite(value) ? value : 0;\n\nfunction parseNumber(milliseconds) {\n\treturn {\n\t\tdays: Math.trunc(milliseconds / 86_400_000),\n\t\thours: Math.trunc(milliseconds / 3_600_000 % 24),\n\t\tminutes: Math.trunc(milliseconds / 60_000 % 60),\n\t\tseconds: Math.trunc(milliseconds / 1000 % 60),\n\t\tmilliseconds: Math.trunc(milliseconds % 1000),\n\t\tmicroseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1000) % 1000),\n\t\tnanoseconds: Math.trunc(toZeroIfInfinity(milliseconds * 1e6) % 1000),\n\t};\n}\n\nfunction parseBigint(milliseconds) {\n\treturn {\n\t\tdays: milliseconds / 86_400_000n,\n\t\thours: milliseconds / 3_600_000n % 24n,\n\t\tminutes: milliseconds / 60_000n % 60n,\n\t\tseconds: milliseconds / 1000n % 60n,\n\t\tmilliseconds: milliseconds % 1000n,\n\t\tmicroseconds: 0n,\n\t\tnanoseconds: 0n,\n\t};\n}\n\nexport default function parseMilliseconds(milliseconds) {\n\tswitch (typeof milliseconds) {\n\t\tcase 'number': {\n\t\t\tif (Number.isFinite(milliseconds)) {\n\t\t\t\treturn parseNumber(milliseconds);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'bigint': {\n\t\t\treturn parseBigint(milliseconds);\n\t\t}\n\n\t\t// No default\n\t}\n\n\tthrow new TypeError('Expected a finite number or bigint');\n}\n","import parseMilliseconds from 'parse-ms';\n\nconst isZero = value => value === 0 || value === 0n;\nconst pluralize = (word, count) => (count === 1 || count === 1n) ? word : `${word}s`;\n\nconst SECOND_ROUNDING_EPSILON = 0.000_000_1;\nconst ONE_DAY_IN_MILLISECONDS = 24n * 60n * 60n * 1000n;\n\nexport default function prettyMilliseconds(milliseconds, options) {\n\tconst isBigInt = typeof milliseconds === 'bigint';\n\tif (!isBigInt && !Number.isFinite(milliseconds)) {\n\t\tthrow new TypeError('Expected a finite number or bigint');\n\t}\n\n\toptions = {...options};\n\n\tif (options.colonNotation) {\n\t\toptions.compact = false;\n\t\toptions.formatSubMilliseconds = false;\n\t\toptions.separateMilliseconds = false;\n\t\toptions.verbose = false;\n\t}\n\n\tif (options.compact) {\n\t\toptions.unitCount = 1;\n\t\toptions.secondsDecimalDigits = 0;\n\t\toptions.millisecondsDecimalDigits = 0;\n\t}\n\n\tlet result = [];\n\n\tconst floorDecimals = (value, decimalDigits) => {\n\t\tconst flooredInterimValue = Math.floor((value * (10 ** decimalDigits)) + SECOND_ROUNDING_EPSILON);\n\t\tconst flooredValue = Math.round(flooredInterimValue) / (10 ** decimalDigits);\n\t\treturn flooredValue.toFixed(decimalDigits);\n\t};\n\n\tconst add = (value, long, short, valueString) => {\n\t\tif (\n\t\t\t(result.length === 0 || !options.colonNotation)\n\t\t\t&& isZero(value)\n\t\t\t&& !(options.colonNotation && short === 'm')) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalueString = valueString ?? String(value);\n\t\tif (options.colonNotation) {\n\t\t\tconst wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;\n\t\t\tconst minLength = result.length > 0 ? 2 : 1;\n\t\t\tvalueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;\n\t\t} else {\n\t\t\tvalueString += options.verbose ? ' ' + pluralize(long, value) : short;\n\t\t}\n\n\t\tresult.push(valueString);\n\t};\n\n\tconst parsed = parseMilliseconds(milliseconds);\n\tconst days = BigInt(parsed.days);\n\n\tadd(days / 365n, 'year', 'y');\n\tadd(days % 365n, 'day', 'd');\n\tadd(Number(parsed.hours), 'hour', 'h');\n\tadd(Number(parsed.minutes), 'minute', 'm');\n\n\tif (\n\t\toptions.separateMilliseconds\n\t\t|| options.formatSubMilliseconds\n\t\t|| (!options.colonNotation && milliseconds < 1000)\n\t) {\n\t\tconst seconds = Number(parsed.seconds);\n\t\tconst milliseconds = Number(parsed.milliseconds);\n\t\tconst microseconds = Number(parsed.microseconds);\n\t\tconst nanoseconds = Number(parsed.nanoseconds);\n\n\t\tadd(seconds, 'second', 's');\n\n\t\tif (options.formatSubMilliseconds) {\n\t\t\tadd(milliseconds, 'millisecond', 'ms');\n\t\t\tadd(microseconds, 'microsecond', 'µs');\n\t\t\tadd(nanoseconds, 'nanosecond', 'ns');\n\t\t} else {\n\t\t\tconst millisecondsAndBelow\n\t\t\t\t= milliseconds\n\t\t\t\t+ (microseconds / 1000)\n\t\t\t\t+ (nanoseconds / 1e6);\n\n\t\t\tconst millisecondsDecimalDigits\n\t\t\t\t= typeof options.millisecondsDecimalDigits === 'number'\n\t\t\t\t\t? options.millisecondsDecimalDigits\n\t\t\t\t\t: 0;\n\n\t\t\tconst roundedMilliseconds = millisecondsAndBelow >= 1\n\t\t\t\t? Math.round(millisecondsAndBelow)\n\t\t\t\t: Math.ceil(millisecondsAndBelow);\n\n\t\t\tconst millisecondsString = millisecondsDecimalDigits\n\t\t\t\t? millisecondsAndBelow.toFixed(millisecondsDecimalDigits)\n\t\t\t\t: roundedMilliseconds;\n\n\t\t\tadd(\n\t\t\t\tNumber.parseFloat(millisecondsString),\n\t\t\t\t'millisecond',\n\t\t\t\t'ms',\n\t\t\t\tmillisecondsString,\n\t\t\t);\n\t\t}\n\t} else {\n\t\tconst seconds = (\n\t\t\t(isBigInt ? Number(milliseconds % ONE_DAY_IN_MILLISECONDS) : milliseconds)\n\t\t\t/ 1000\n\t\t) % 60;\n\t\tconst secondsDecimalDigits\n\t\t\t= typeof options.secondsDecimalDigits === 'number'\n\t\t\t\t? options.secondsDecimalDigits\n\t\t\t\t: 1;\n\t\tconst secondsFixed = floorDecimals(seconds, secondsDecimalDigits);\n\t\tconst secondsString = options.keepDecimalsOnWholeSeconds\n\t\t\t? secondsFixed\n\t\t\t: secondsFixed.replace(/\\.0+$/, '');\n\t\tadd(Number.parseFloat(secondsString), 'second', 's', secondsString);\n\t}\n\n\tif (result.length === 0) {\n\t\treturn '0' + (options.verbose ? ' milliseconds' : 'ms');\n\t}\n\n\tconst separator = options.colonNotation ? ':' : ' ';\n\tif (typeof options.unitCount === 'number') {\n\t\tresult = result.slice(0, Math.max(options.unitCount, 1));\n\t}\n\n\treturn result.join(separator);\n}\n","import {redBright, yellowBright} from 'yoctocolors';\nimport {verboseLog} from './log.js';\n\n// When `verbose` is `short|full`, print each command's error when it fails\nexport const logError = ({message, failed, reject, verboseId, icon}) => {\n\tif (!failed) {\n\t\treturn;\n\t}\n\n\tconst color = reject ? redBright : yellowBright;\n\tverboseLog(message, verboseId, icon, color);\n};\n","import prettyMs from 'pretty-ms';\nimport {gray} from 'yoctocolors';\nimport {escapeLines} from '../arguments/escape.js';\nimport {getDurationMs} from '../return/duration.js';\nimport {isVerbose} from './info.js';\nimport {verboseLog} from './log.js';\nimport {logError} from './error.js';\n\n// When `verbose` is `short|full`, print each command's completion, duration and error\nexport const logFinalResult = ({shortMessage, failed, durationMs}, reject, verboseInfo) => {\n\tlogResult({\n\t\tmessage: shortMessage,\n\t\tfailed,\n\t\treject,\n\t\tdurationMs,\n\t\tverboseInfo,\n\t});\n};\n\n// Same but for early validation errors\nexport const logEarlyResult = (error, startTime, verboseInfo) => {\n\tlogResult({\n\t\tmessage: escapeLines(String(error)),\n\t\tfailed: true,\n\t\treject: true,\n\t\tdurationMs: getDurationMs(startTime),\n\t\tverboseInfo,\n\t});\n};\n\nconst logResult = ({message, failed, reject, durationMs, verboseInfo: {verbose, verboseId}}) => {\n\tif (!isVerbose(verbose)) {\n\t\treturn;\n\t}\n\n\tconst icon = getIcon(failed, reject);\n\tlogError({\n\t\tmessage,\n\t\tfailed,\n\t\treject,\n\t\tverboseId,\n\t\ticon,\n\t});\n\tlogDuration(durationMs, verboseId, icon);\n};\n\nconst logDuration = (durationMs, verboseId, icon) => {\n\tconst durationMessage = `(done in ${prettyMs(durationMs)})`;\n\tverboseLog(durationMessage, verboseId, icon, gray);\n};\n\nconst getIcon = (failed, reject) => {\n\tif (!failed) {\n\t\treturn 'success';\n\t}\n\n\treturn reject ? 'error' : 'warning';\n};\n","import {logFinalResult} from '../verbose/complete.js';\n\n// Applies the `reject` option.\n// Also print the final log line with `verbose`.\nexport const handleResult = (result, verboseInfo, {reject}) => {\n\tlogFinalResult(result, reject, verboseInfo);\n\n\tif (result.failed && reject) {\n\t\tthrow result;\n\t}\n\n\treturn result;\n};\n","import {isStream as isNodeStream, isDuplexStream} from 'is-stream';\nimport isPlainObj from 'is-plain-obj';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// The `stdin`/`stdout`/`stderr` option can be of many types. This detects it.\nexport const getStdioItemType = (value, optionName) => {\n\tif (isAsyncGenerator(value)) {\n\t\treturn 'asyncGenerator';\n\t}\n\n\tif (isSyncGenerator(value)) {\n\t\treturn 'generator';\n\t}\n\n\tif (isUrl(value)) {\n\t\treturn 'fileUrl';\n\t}\n\n\tif (isFilePathObject(value)) {\n\t\treturn 'filePath';\n\t}\n\n\tif (isWebStream(value)) {\n\t\treturn 'webStream';\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn 'native';\n\t}\n\n\tif (isUint8Array(value)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tif (isAsyncIterableObject(value)) {\n\t\treturn 'asyncIterable';\n\t}\n\n\tif (isIterableObject(value)) {\n\t\treturn 'iterable';\n\t}\n\n\tif (isTransformStream(value)) {\n\t\treturn getTransformStreamType({transform: value}, optionName);\n\t}\n\n\tif (isTransformOptions(value)) {\n\t\treturn getTransformObjectType(value, optionName);\n\t}\n\n\treturn 'native';\n};\n\nconst getTransformObjectType = (value, optionName) => {\n\tif (isDuplexStream(value.transform, {checkOpen: false})) {\n\t\treturn getDuplexType(value, optionName);\n\t}\n\n\tif (isTransformStream(value.transform)) {\n\t\treturn getTransformStreamType(value, optionName);\n\t}\n\n\treturn getGeneratorObjectType(value, optionName);\n};\n\nconst getDuplexType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'Duplex stream');\n\treturn 'duplex';\n};\n\nconst getTransformStreamType = (value, optionName) => {\n\tvalidateNonGeneratorType(value, optionName, 'web TransformStream');\n\treturn 'webTransform';\n};\n\nconst validateNonGeneratorType = ({final, binary, objectMode}, optionName, typeName) => {\n\tcheckUndefinedOption(final, `${optionName}.final`, typeName);\n\tcheckUndefinedOption(binary, `${optionName}.binary`, typeName);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n};\n\nconst checkUndefinedOption = (value, optionName, typeName) => {\n\tif (value !== undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option can only be defined when using a generator, not a ${typeName}.`);\n\t}\n};\n\nconst getGeneratorObjectType = ({transform, final, binary, objectMode}, optionName) => {\n\tif (transform !== undefined && !isGenerator(transform)) {\n\t\tthrow new TypeError(`The \\`${optionName}.transform\\` option must be a generator, a Duplex stream or a web TransformStream.`);\n\t}\n\n\tif (isDuplexStream(final, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a Duplex stream.`);\n\t}\n\n\tif (isTransformStream(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must not be a web TransformStream.`);\n\t}\n\n\tif (final !== undefined && !isGenerator(final)) {\n\t\tthrow new TypeError(`The \\`${optionName}.final\\` option must be a generator.`);\n\t}\n\n\tcheckBooleanOption(binary, `${optionName}.binary`);\n\tcheckBooleanOption(objectMode, `${optionName}.objectMode`);\n\n\treturn isAsyncGenerator(transform) || isAsyncGenerator(final) ? 'asyncGenerator' : 'generator';\n};\n\nconst checkBooleanOption = (value, optionName) => {\n\tif (value !== undefined && typeof value !== 'boolean') {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must use a boolean.`);\n\t}\n};\n\nconst isGenerator = value => isAsyncGenerator(value) || isSyncGenerator(value);\nexport const isAsyncGenerator = value => Object.prototype.toString.call(value) === '[object AsyncGeneratorFunction]';\nconst isSyncGenerator = value => Object.prototype.toString.call(value) === '[object GeneratorFunction]';\nconst isTransformOptions = value => isPlainObj(value)\n\t&& (value.transform !== undefined || value.final !== undefined);\n\nexport const isUrl = value => Object.prototype.toString.call(value) === '[object URL]';\nexport const isRegularUrl = value => isUrl(value) && value.protocol !== 'file:';\n\nconst isFilePathObject = value => isPlainObj(value)\n\t&& Object.keys(value).length === 1\n\t&& isFilePathString(value.file);\nexport const isFilePathString = file => typeof file === 'string';\n\nexport const isUnknownStdioString = (type, value) => type === 'native'\n\t&& typeof value === 'string'\n\t&& !KNOWN_STDIO_STRINGS.has(value);\nconst KNOWN_STDIO_STRINGS = new Set(['ipc', 'ignore', 'inherit', 'overlapped', 'pipe']);\n\nconst isReadableStream = value => Object.prototype.toString.call(value) === '[object ReadableStream]';\nexport const isWritableStream = value => Object.prototype.toString.call(value) === '[object WritableStream]';\nconst isWebStream = value => isReadableStream(value) || isWritableStream(value);\nconst isTransformStream = value => isReadableStream(value?.readable) && isWritableStream(value?.writable);\n\nconst isAsyncIterableObject = value => isObject(value) && typeof value[Symbol.asyncIterator] === 'function';\nconst isIterableObject = value => isObject(value) && typeof value[Symbol.iterator] === 'function';\nconst isObject = value => typeof value === 'object' && value !== null;\n\n// Types which modify `subprocess.std*`\nexport const TRANSFORM_TYPES = new Set(['generator', 'asyncGenerator', 'duplex', 'webTransform']);\n// Types which write to a file or a file descriptor\nexport const FILE_TYPES = new Set(['fileUrl', 'filePath', 'fileNumber']);\n// When two file descriptors of this type share the same target, we need to do some special logic\nexport const SPECIAL_DUPLICATE_TYPES_SYNC = new Set(['fileUrl', 'filePath']);\nexport const SPECIAL_DUPLICATE_TYPES = new Set([...SPECIAL_DUPLICATE_TYPES_SYNC, 'webStream', 'nodeStream']);\n// Do not allow two file descriptors of this type sharing the same target\nexport const FORBID_DUPLICATE_TYPES = new Set(['webTransform', 'duplex']);\n\n// Convert types to human-friendly strings for error messages\nexport const TYPE_TO_MESSAGE = {\n\tgenerator: 'a generator',\n\tasyncGenerator: 'an async generator',\n\tfileUrl: 'a file URL',\n\tfilePath: 'a file path string',\n\tfileNumber: 'a file descriptor number',\n\twebStream: 'a web stream',\n\tnodeStream: 'a Node.js stream',\n\twebTransform: 'a web TransformStream',\n\tduplex: 'a Duplex stream',\n\tnative: 'any value',\n\titerable: 'an iterable',\n\tasyncIterable: 'an async iterable',\n\tstring: 'a string',\n\tuint8Array: 'a Uint8Array',\n};\n","import {TRANSFORM_TYPES} from '../stdio/type.js';\n\n/*\nRetrieve the `objectMode`s of a single transform.\n`objectMode` determines the return value's type, i.e. the `readableObjectMode`.\nThe chunk argument's type is based on the previous generator's return value, i.e. the `writableObjectMode` is based on the previous `readableObjectMode`.\nThe last input's generator is read by `subprocess.stdin` which:\n- should not be in `objectMode` for performance reasons.\n- can only be strings, Buffers and Uint8Arrays.\nTherefore its `readableObjectMode` must be `false`.\nThe same applies to the first output's generator's `writableObjectMode`.\n*/\nexport const getTransformObjectModes = (objectMode, index, newTransforms, direction) => direction === 'output'\n\t? getOutputObjectModes(objectMode, index, newTransforms)\n\t: getInputObjectModes(objectMode, index, newTransforms);\n\nconst getOutputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index !== 0 && newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = objectMode ?? writableObjectMode;\n\treturn {writableObjectMode, readableObjectMode};\n};\n\nconst getInputObjectModes = (objectMode, index, newTransforms) => {\n\tconst writableObjectMode = index === 0\n\t\t? objectMode === true\n\t\t: newTransforms[index - 1].value.readableObjectMode;\n\tconst readableObjectMode = index !== newTransforms.length - 1 && (objectMode ?? writableObjectMode);\n\treturn {writableObjectMode, readableObjectMode};\n};\n\n// Retrieve the `objectMode` of a file descriptor, e.g. `stdout` or `stderr`\nexport const getFdObjectMode = (stdioItems, direction) => {\n\tconst lastTransform = stdioItems.findLast(({type}) => TRANSFORM_TYPES.has(type));\n\tif (lastTransform === undefined) {\n\t\treturn false;\n\t}\n\n\treturn direction === 'input'\n\t\t? lastTransform.value.writableObjectMode\n\t\t: lastTransform.value.readableObjectMode;\n};\n","import isPlainObj from 'is-plain-obj';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getTransformObjectModes} from './object-mode.js';\n\n// Transforms generators/duplex/TransformStream can have multiple shapes.\n// This normalizes it and applies default values.\nexport const normalizeTransforms = (stdioItems, optionName, direction, options) => [\n\t...stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type)),\n\t...getTransforms(stdioItems, optionName, direction, options),\n];\n\nconst getTransforms = (stdioItems, optionName, direction, {encoding}) => {\n\tconst transforms = stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type));\n\tconst newTransforms = Array.from({length: transforms.length});\n\n\tfor (const [index, stdioItem] of Object.entries(transforms)) {\n\t\tnewTransforms[index] = normalizeTransform({\n\t\t\tstdioItem,\n\t\t\tindex: Number(index),\n\t\t\tnewTransforms,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t\tencoding,\n\t\t});\n\t}\n\n\treturn sortTransforms(newTransforms, direction);\n};\n\nconst normalizeTransform = ({stdioItem, stdioItem: {type}, index, newTransforms, optionName, direction, encoding}) => {\n\tif (type === 'duplex') {\n\t\treturn normalizeDuplex({stdioItem, optionName});\n\t}\n\n\tif (type === 'webTransform') {\n\t\treturn normalizeTransformStream({\n\t\t\tstdioItem,\n\t\t\tindex,\n\t\t\tnewTransforms,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\treturn normalizeGenerator({\n\t\tstdioItem,\n\t\tindex,\n\t\tnewTransforms,\n\t\tdirection,\n\t\tencoding,\n\t});\n};\n\nconst normalizeDuplex = ({\n\tstdioItem,\n\tstdioItem: {\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\ttransform: {writableObjectMode, readableObjectMode},\n\t\t\tobjectMode = readableObjectMode,\n\t\t},\n\t},\n\toptionName,\n}) => {\n\tif (objectMode && !readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option can only be \\`true\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\tif (!objectMode && readableObjectMode) {\n\t\tthrow new TypeError(`The \\`${optionName}.objectMode\\` option cannot be \\`false\\` if \\`new Duplex({objectMode: true})\\` is used.`);\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t};\n};\n\nconst normalizeTransformStream = ({stdioItem, stdioItem: {value}, index, newTransforms, direction}) => {\n\tconst {transform, objectMode} = isPlainObj(value) ? value : {transform: value};\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn ({\n\t\t...stdioItem,\n\t\tvalue: {transform, writableObjectMode, readableObjectMode},\n\t});\n};\n\nconst normalizeGenerator = ({stdioItem, stdioItem: {value}, index, newTransforms, direction, encoding}) => {\n\tconst {\n\t\ttransform,\n\t\tfinal,\n\t\tbinary: binaryOption = false,\n\t\tpreserveNewlines = false,\n\t\tobjectMode,\n\t} = isPlainObj(value) ? value : {transform: value};\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {writableObjectMode, readableObjectMode} = getTransformObjectModes(objectMode, index, newTransforms, direction);\n\treturn {\n\t\t...stdioItem,\n\t\tvalue: {\n\t\t\ttransform,\n\t\t\tfinal,\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\twritableObjectMode,\n\t\t\treadableObjectMode,\n\t\t},\n\t};\n};\n\nconst sortTransforms = (newTransforms, direction) => direction === 'input' ? newTransforms.reverse() : newTransforms;\n","import process from 'node:process';\nimport {\n\tisStream as isNodeStream,\n\tisReadableStream as isNodeReadableStream,\n\tisWritableStream as isNodeWritableStream,\n} from 'is-stream';\nimport {isWritableStream} from './type.js';\n\n// For `stdio[fdNumber]` beyond stdin/stdout/stderr, we need to guess whether the value passed is intended for inputs or outputs.\n// This allows us to know whether to pipe _into_ or _from_ the stream.\n// When `stdio[fdNumber]` is a single value, this guess is fairly straightforward.\n// However, when it is an array instead, we also need to make sure the different values are not incompatible with each other.\nexport const getStreamDirection = (stdioItems, fdNumber, optionName) => {\n\tconst directions = stdioItems.map(stdioItem => getStdioItemDirection(stdioItem, fdNumber));\n\n\tif (directions.includes('input') && directions.includes('output')) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an array of both readable and writable values.`);\n\t}\n\n\treturn directions.find(Boolean) ?? DEFAULT_DIRECTION;\n};\n\nconst getStdioItemDirection = ({type, value}, fdNumber) => KNOWN_DIRECTIONS[fdNumber] ?? guessStreamDirection[type](value);\n\n// `stdin`/`stdout`/`stderr` have a known direction\nconst KNOWN_DIRECTIONS = ['input', 'output', 'output'];\n\nconst anyDirection = () => undefined;\nconst alwaysInput = () => 'input';\n\n// `string` can only be added through the `input` option, i.e. does not need to be handled here\nconst guessStreamDirection = {\n\tgenerator: anyDirection,\n\tasyncGenerator: anyDirection,\n\tfileUrl: anyDirection,\n\tfilePath: anyDirection,\n\titerable: alwaysInput,\n\tasyncIterable: alwaysInput,\n\tuint8Array: alwaysInput,\n\twebStream: value => isWritableStream(value) ? 'output' : 'input',\n\tnodeStream(value) {\n\t\tif (!isNodeReadableStream(value, {checkOpen: false})) {\n\t\t\treturn 'output';\n\t\t}\n\n\t\treturn isNodeWritableStream(value, {checkOpen: false}) ? undefined : 'input';\n\t},\n\twebTransform: anyDirection,\n\tduplex: anyDirection,\n\tnative(value) {\n\t\tconst standardStreamDirection = getStandardStreamDirection(value);\n\t\tif (standardStreamDirection !== undefined) {\n\t\t\treturn standardStreamDirection;\n\t\t}\n\n\t\tif (isNodeStream(value, {checkOpen: false})) {\n\t\t\treturn guessStreamDirection.nodeStream(value);\n\t\t}\n\t},\n};\n\nconst getStandardStreamDirection = value => {\n\tif ([0, process.stdin].includes(value)) {\n\t\treturn 'input';\n\t}\n\n\tif ([1, 2, process.stdout, process.stderr].includes(value)) {\n\t\treturn 'output';\n\t}\n};\n\n// When ambiguous, we initially keep the direction as `undefined`.\n// This allows arrays of `stdio` values to resolve the ambiguity.\n// For example, `stdio[3]: DuplexStream` is ambiguous, but `stdio[3]: [DuplexStream, WritableStream]` is not.\n// When the ambiguity remains, we default to `output` since it is the most common use case for additional file descriptors.\nconst DEFAULT_DIRECTION = 'output';\n","import {STANDARD_STREAMS_ALIASES} from '../utils/standard-stream.js';\n\n// Add support for `stdin`/`stdout`/`stderr` as an alias for `stdio`.\n// Also normalize the `stdio` option.\nexport const normalizeStdioOption = ({stdio, ipc, buffer, verbose, ...options}, isSync) => {\n\tconst stdioArray = getStdioArray(stdio, options).map((stdioOption, fdNumber) => addDefaultValue(stdioOption, fdNumber));\n\treturn isSync ? normalizeStdioSync(stdioArray, buffer, verbose) : normalizeStdioAsync(stdioArray, ipc);\n};\n\nconst getStdioArray = (stdio, options) => {\n\tif (stdio === undefined) {\n\t\treturn STANDARD_STREAMS_ALIASES.map(alias => options[alias]);\n\t}\n\n\tif (hasAlias(options)) {\n\t\tthrow new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${STANDARD_STREAMS_ALIASES.map(alias => `\\`${alias}\\``).join(', ')}`);\n\t}\n\n\tif (typeof stdio === 'string') {\n\t\treturn [stdio, stdio, stdio];\n\t}\n\n\tif (!Array.isArray(stdio)) {\n\t\tthrow new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);\n\t}\n\n\tconst length = Math.max(stdio.length, STANDARD_STREAMS_ALIASES.length);\n\treturn Array.from({length}, (_, fdNumber) => stdio[fdNumber]);\n};\n\nconst hasAlias = options => STANDARD_STREAMS_ALIASES.some(alias => options[alias] !== undefined);\n\nconst addDefaultValue = (stdioOption, fdNumber) => {\n\tif (Array.isArray(stdioOption)) {\n\t\treturn stdioOption.map(item => addDefaultValue(item, fdNumber));\n\t}\n\n\tif (stdioOption === null || stdioOption === undefined) {\n\t\treturn fdNumber >= STANDARD_STREAMS_ALIASES.length ? 'ignore' : 'pipe';\n\t}\n\n\treturn stdioOption;\n};\n\n// Using `buffer: false` with synchronous methods implies `stdout`/`stderr`: `ignore`.\n// Unless the output is needed, e.g. due to `verbose: 'full'` or to redirecting to a file.\nconst normalizeStdioSync = (stdioArray, buffer, verbose) => stdioArray.map((stdioOption, fdNumber) =>\n\t!buffer[fdNumber]\n\t&& fdNumber !== 0\n\t&& verbose[fdNumber] !== 'full'\n\t&& isOutputPipeOnly(stdioOption)\n\t\t? 'ignore'\n\t\t: stdioOption);\n\nconst isOutputPipeOnly = stdioOption => stdioOption === 'pipe'\n\t|| (Array.isArray(stdioOption) && stdioOption.every(item => item === 'pipe'));\n\n// The `ipc` option adds an `ipc` item to the `stdio` option\nconst normalizeStdioAsync = (stdioArray, ipc) => ipc && !stdioArray.includes('ipc')\n\t? [...stdioArray, 'ipc']\n\t: stdioArray;\n","import {parseFd} from './specific.js';\n\n// Retrieve stream targeted by the `to` option\nexport const getToStream = (destination, to = 'stdin') => {\n\tconst isWritable = true;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(destination);\n\tconst fdNumber = getFdNumber(fileDescriptors, to, isWritable);\n\tconst destinationStream = destination.stdio[fdNumber];\n\n\tif (destinationStream === null) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, to, options, isWritable));\n\t}\n\n\treturn destinationStream;\n};\n\n// Retrieve stream targeted by the `from` option\nexport const getFromStream = (source, from = 'stdout') => {\n\tconst isWritable = false;\n\tconst {options, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\tconst fdNumber = getFdNumber(fileDescriptors, from, isWritable);\n\tconst sourceStream = fdNumber === 'all' ? source.all : source.stdio[fdNumber];\n\n\tif (sourceStream === null || sourceStream === undefined) {\n\t\tthrow new TypeError(getInvalidStdioOptionMessage(fdNumber, from, options, isWritable));\n\t}\n\n\treturn sourceStream;\n};\n\n// Keeps track of the options passed to each Execa call\nexport const SUBPROCESS_OPTIONS = new WeakMap();\n\nconst getFdNumber = (fileDescriptors, fdName, isWritable) => {\n\tconst fdNumber = parseFdNumber(fdName, isWritable);\n\tvalidateFdNumber(fdNumber, fdName, isWritable, fileDescriptors);\n\treturn fdNumber;\n};\n\nconst parseFdNumber = (fdName, isWritable) => {\n\tconst fdNumber = parseFd(fdName);\n\tif (fdNumber !== undefined) {\n\t\treturn fdNumber;\n\t}\n\n\tconst {validOptions, defaultValue} = isWritable\n\t\t? {validOptions: '\"stdin\"', defaultValue: 'stdin'}\n\t\t: {validOptions: '\"stdout\", \"stderr\", \"all\"', defaultValue: 'stdout'};\n\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be \"${fdName}\".\nIt must be ${validOptions} or \"fd3\", \"fd4\" (and so on).\nIt is optional and defaults to \"${defaultValue}\".`);\n};\n\nconst validateFdNumber = (fdNumber, fdName, isWritable, fileDescriptors) => {\n\tconst fileDescriptor = fileDescriptors[getUsedDescriptor(fdNumber)];\n\tif (fileDescriptor === undefined) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. That file descriptor does not exist.\nPlease set the \"stdio\" option to ensure that file descriptor exists.`);\n\t}\n\n\tif (fileDescriptor.direction === 'input' && !isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a readable stream, not writable.`);\n\t}\n\n\tif (fileDescriptor.direction !== 'input' && isWritable) {\n\t\tthrow new TypeError(`\"${getOptionName(isWritable)}\" must not be ${fdName}. It must be a writable stream, not readable.`);\n\t}\n};\n\nconst getInvalidStdioOptionMessage = (fdNumber, fdName, options, isWritable) => {\n\tif (fdNumber === 'all' && !options.all) {\n\t\treturn 'The \"all\" option must be true to use \"from: \\'all\\'\".';\n\t}\n\n\tconst {optionName, optionValue} = getInvalidStdioOption(fdNumber, options);\n\treturn `The \"${optionName}: ${serializeOptionValue(optionValue)}\" option is incompatible with using \"${getOptionName(isWritable)}: ${serializeOptionValue(fdName)}\".\nPlease set this option with \"pipe\" instead.`;\n};\n\nconst getInvalidStdioOption = (fdNumber, {stdin, stdout, stderr, stdio}) => {\n\tconst usedDescriptor = getUsedDescriptor(fdNumber);\n\n\tif (usedDescriptor === 0 && stdin !== undefined) {\n\t\treturn {optionName: 'stdin', optionValue: stdin};\n\t}\n\n\tif (usedDescriptor === 1 && stdout !== undefined) {\n\t\treturn {optionName: 'stdout', optionValue: stdout};\n\t}\n\n\tif (usedDescriptor === 2 && stderr !== undefined) {\n\t\treturn {optionName: 'stderr', optionValue: stderr};\n\t}\n\n\treturn {optionName: `stdio[${usedDescriptor}]`, optionValue: stdio[usedDescriptor]};\n};\n\nconst getUsedDescriptor = fdNumber => fdNumber === 'all' ? 1 : fdNumber;\n\nconst getOptionName = isWritable => isWritable ? 'to' : 'from';\n\nexport const serializeOptionValue = value => {\n\tif (typeof value === 'string') {\n\t\treturn `'${value}'`;\n\t}\n\n\treturn typeof value === 'number' ? `${value}` : 'Stream';\n};\n","import {readFileSync} from 'node:fs';\nimport tty from 'node:tty';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {STANDARD_STREAMS} from '../utils/standard-stream.js';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {serializeOptionValue} from '../arguments/fd-options.js';\n\n// When we use multiple `stdio` values for the same streams, we pass 'pipe' to `child_process.spawn()`.\n// We then emulate the piping done by core Node.js.\n// To do so, we transform the following values:\n//  - Node.js streams are marked as `type: nodeStream`\n//  - 'inherit' becomes `process.stdin|stdout|stderr`\n//  - any file descriptor integer becomes `process.stdio[fdNumber]`\n// All of the above transformations tell Execa to perform manual piping.\nexport const handleNativeStream = ({stdioItem, stdioItem: {type}, isStdioArray, fdNumber, direction, isSync}) => {\n\tif (!isStdioArray || type !== 'native') {\n\t\treturn stdioItem;\n\t}\n\n\treturn isSync\n\t\t? handleNativeStreamSync({stdioItem, fdNumber, direction})\n\t\t: handleNativeStreamAsync({stdioItem, fdNumber});\n};\n\n// Synchronous methods use a different logic.\n// 'inherit', file descriptors and process.std* are handled by readFileSync()/writeFileSync().\nconst handleNativeStreamSync = ({stdioItem, stdioItem: {value, optionName}, fdNumber, direction}) => {\n\tconst targetFd = getTargetFd({\n\t\tvalue,\n\t\toptionName,\n\t\tfdNumber,\n\t\tdirection,\n\t});\n\tif (targetFd !== undefined) {\n\t\treturn targetFd;\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\tthrow new TypeError(`The \\`${optionName}: Stream\\` option cannot both be an array and include a stream with synchronous methods.`);\n\t}\n\n\treturn stdioItem;\n};\n\nconst getTargetFd = ({value, optionName, fdNumber, direction}) => {\n\tconst targetFdNumber = getTargetFdNumber(value, fdNumber);\n\tif (targetFdNumber === undefined) {\n\t\treturn;\n\t}\n\n\tif (direction === 'output') {\n\t\treturn {type: 'fileNumber', value: targetFdNumber, optionName};\n\t}\n\n\tif (tty.isatty(targetFdNumber)) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${serializeOptionValue(value)}\\` option is invalid: it cannot be a TTY with synchronous methods.`);\n\t}\n\n\treturn {type: 'uint8Array', value: bufferToUint8Array(readFileSync(targetFdNumber)), optionName};\n};\n\nconst getTargetFdNumber = (value, fdNumber) => {\n\tif (value === 'inherit') {\n\t\treturn fdNumber;\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn value;\n\t}\n\n\tconst standardStreamIndex = STANDARD_STREAMS.indexOf(value);\n\tif (standardStreamIndex !== -1) {\n\t\treturn standardStreamIndex;\n\t}\n};\n\nconst handleNativeStreamAsync = ({stdioItem, stdioItem: {value, optionName}, fdNumber}) => {\n\tif (value === 'inherit') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(fdNumber, value, optionName), optionName};\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn {type: 'nodeStream', value: getStandardStream(value, value, optionName), optionName};\n\t}\n\n\tif (isNodeStream(value, {checkOpen: false})) {\n\t\treturn {type: 'nodeStream', value, optionName};\n\t}\n\n\treturn stdioItem;\n};\n\n// Node.js does not allow to easily retrieve file descriptors beyond stdin/stdout/stderr as streams.\n//  - `fs.createReadStream()`/`fs.createWriteStream()` with the `fd` option do not work with character devices that use blocking reads/writes (such as interactive TTYs).\n//  - Using a TCP `Socket` would work but be rather complex to implement.\n// Since this is an edge case, we simply throw an error message.\n// See https://github.com/sindresorhus/execa/pull/643#discussion_r1435905707\nconst getStandardStream = (fdNumber, value, optionName) => {\n\tconst standardStream = STANDARD_STREAMS[fdNumber];\n\n\tif (standardStream === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}: ${value}\\` option is invalid: no such standard stream.`);\n\t}\n\n\treturn standardStream;\n};\n","import {isReadableStream} from 'is-stream';\nimport {isUint8Array} from '../utils/uint-array.js';\nimport {isUrl, isFilePathString} from './type.js';\n\n// Append the `stdin` option with the `input` and `inputFile` options\nexport const handleInputOptions = ({input, inputFile}, fdNumber) => fdNumber === 0\n\t? [\n\t\t...handleInputOption(input),\n\t\t...handleInputFileOption(inputFile),\n\t]\n\t: [];\n\nconst handleInputOption = input => input === undefined ? [] : [{\n\ttype: getInputType(input),\n\tvalue: input,\n\toptionName: 'input',\n}];\n\nconst getInputType = input => {\n\tif (isReadableStream(input, {checkOpen: false})) {\n\t\treturn 'nodeStream';\n\t}\n\n\tif (typeof input === 'string') {\n\t\treturn 'string';\n\t}\n\n\tif (isUint8Array(input)) {\n\t\treturn 'uint8Array';\n\t}\n\n\tthrow new Error('The `input` option must be a string, a Uint8Array or a Node.js Readable stream.');\n};\n\nconst handleInputFileOption = inputFile => inputFile === undefined ? [] : [{\n\t...getInputFileType(inputFile),\n\toptionName: 'inputFile',\n}];\n\nconst getInputFileType = inputFile => {\n\tif (isUrl(inputFile)) {\n\t\treturn {type: 'fileUrl', value: inputFile};\n\t}\n\n\tif (isFilePathString(inputFile)) {\n\t\treturn {type: 'filePath', value: {file: inputFile}};\n\t}\n\n\tthrow new Error('The `inputFile` option must be a file path string or a file URL.');\n};\n","import {\n\tSPECIAL_DUPLICATE_TYPES_SYNC,\n\tSPECIAL_DUPLICATE_TYPES,\n\tFORBID_DUPLICATE_TYPES,\n\tTYPE_TO_MESSAGE,\n} from './type.js';\n\n// Duplicates in the same file descriptor is most likely an error.\n// However, this can be useful with generators.\nexport const filterDuplicates = stdioItems => stdioItems.filter((stdioItemOne, indexOne) =>\n\tstdioItems.every((stdioItemTwo, indexTwo) => stdioItemOne.value !== stdioItemTwo.value\n\t\t|| indexOne >= indexTwo\n\t\t|| stdioItemOne.type === 'generator'\n\t\t|| stdioItemOne.type === 'asyncGenerator'));\n\n// Check if two file descriptors are sharing the same target.\n// For example `{stdout: {file: './output.txt'}, stderr: {file: './output.txt'}}`.\nexport const getDuplicateStream = ({stdioItem: {type, value, optionName}, direction, fileDescriptors, isSync}) => {\n\tconst otherStdioItems = getOtherStdioItems(fileDescriptors, type);\n\tif (otherStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (isSync) {\n\t\tvalidateDuplicateStreamSync({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t\treturn;\n\t}\n\n\tif (SPECIAL_DUPLICATE_TYPES.has(type)) {\n\t\treturn getDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n\n\tif (FORBID_DUPLICATE_TYPES.has(type)) {\n\t\tvalidateDuplicateTransform({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t});\n\t}\n};\n\n// Values shared by multiple file descriptors\nconst getOtherStdioItems = (fileDescriptors, type) => fileDescriptors\n\t.flatMap(({direction, stdioItems}) => stdioItems\n\t\t.filter(stdioItem => stdioItem.type === type)\n\t\t.map((stdioItem => ({...stdioItem, direction}))));\n\n// With `execaSync()`, do not allow setting a file path both in input and output\nconst validateDuplicateStreamSync = ({otherStdioItems, type, value, optionName, direction}) => {\n\tif (SPECIAL_DUPLICATE_TYPES_SYNC.has(type)) {\n\t\tgetDuplicateStreamInstance({\n\t\t\totherStdioItems,\n\t\t\ttype,\n\t\t\tvalue,\n\t\t\toptionName,\n\t\t\tdirection,\n\t\t});\n\t}\n};\n\n// When two file descriptors share the file or stream, we need to re-use the same underlying stream.\n// Otherwise, the stream would be closed twice when piping ends.\n// This is only an issue with output file descriptors.\n// This is not a problem with generator functions since those create a new instance for each file descriptor.\n// We also forbid input and output file descriptors sharing the same file or stream, since that does not make sense.\nconst getDuplicateStreamInstance = ({otherStdioItems, type, value, optionName, direction}) => {\n\tconst duplicateStdioItems = otherStdioItems.filter(stdioItem => hasSameValue(stdioItem, value));\n\tif (duplicateStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tconst differentStdioItem = duplicateStdioItems.find(stdioItem => stdioItem.direction !== direction);\n\tthrowOnDuplicateStream(differentStdioItem, optionName, type);\n\n\treturn direction === 'output' ? duplicateStdioItems[0].stream : undefined;\n};\n\nconst hasSameValue = ({type, value}, secondValue) => {\n\tif (type === 'filePath') {\n\t\treturn value.path === secondValue.path;\n\t}\n\n\tif (type === 'fileUrl') {\n\t\treturn value.href === secondValue.href;\n\t}\n\n\treturn value === secondValue;\n};\n\n// We do not allow two file descriptors to share the same Duplex or TransformStream.\n// This is because those are set directly to `subprocess.std*`.\n// For example, this could result in `subprocess.stdout` and `subprocess.stderr` being the same value.\n// This means reading from either would get data from both stdout and stderr.\nconst validateDuplicateTransform = ({otherStdioItems, type, value, optionName}) => {\n\tconst duplicateStdioItem = otherStdioItems.find(({value: {transform}}) => transform === value.transform);\n\tthrowOnDuplicateStream(duplicateStdioItem, optionName, type);\n};\n\nconst throwOnDuplicateStream = (stdioItem, optionName, type) => {\n\tif (stdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${stdioItem.optionName}\\` and \\`${optionName}\\` options must not target ${TYPE_TO_MESSAGE[type]} that is the same.`);\n\t}\n};\n","import {getStreamName, isStandardStream} from '../utils/standard-stream.js';\nimport {normalizeTransforms} from '../transform/normalize.js';\nimport {getFdObjectMode} from '../transform/object-mode.js';\nimport {\n\tgetStdioItemType,\n\tisRegularUrl,\n\tisUnknownStdioString,\n\tFILE_TYPES,\n} from './type.js';\nimport {getStreamDirection} from './direction.js';\nimport {normalizeStdioOption} from './stdio-option.js';\nimport {handleNativeStream} from './native.js';\nimport {handleInputOptions} from './input-option.js';\nimport {filterDuplicates, getDuplicateStream} from './duplicate.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async/sync mode\n// They are converted into an array of `fileDescriptors`.\n// Each `fileDescriptor` is normalized, validated and contains all information necessary for further handling.\nexport const handleStdio = (addProperties, options, verboseInfo, isSync) => {\n\tconst stdio = normalizeStdioOption(options, isSync);\n\tconst initialFileDescriptors = stdio.map((stdioOption, fdNumber) => getFileDescriptor({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\tisSync,\n\t}));\n\tconst fileDescriptors = getFinalFileDescriptors({\n\t\tinitialFileDescriptors,\n\t\taddProperties,\n\t\toptions,\n\t\tisSync,\n\t});\n\toptions.stdio = fileDescriptors.map(({stdioItems}) => forwardStdio(stdioItems));\n\treturn fileDescriptors;\n};\n\nconst getFileDescriptor = ({stdioOption, fdNumber, options, isSync}) => {\n\tconst optionName = getStreamName(fdNumber);\n\tconst {stdioItems: initialStdioItems, isStdioArray} = initializeStdioItems({\n\t\tstdioOption,\n\t\tfdNumber,\n\t\toptions,\n\t\toptionName,\n\t});\n\tconst direction = getStreamDirection(initialStdioItems, fdNumber, optionName);\n\tconst stdioItems = initialStdioItems.map(stdioItem => handleNativeStream({\n\t\tstdioItem,\n\t\tisStdioArray,\n\t\tfdNumber,\n\t\tdirection,\n\t\tisSync,\n\t}));\n\tconst normalizedStdioItems = normalizeTransforms(stdioItems, optionName, direction, options);\n\tconst objectMode = getFdObjectMode(normalizedStdioItems, direction);\n\tvalidateFileObjectMode(normalizedStdioItems, objectMode);\n\treturn {direction, objectMode, stdioItems: normalizedStdioItems};\n};\n\n// We make sure passing an array with a single item behaves the same as passing that item without an array.\n// This is what users would expect.\n// For example, `stdout: ['ignore']` behaves the same as `stdout: 'ignore'`.\nconst initializeStdioItems = ({stdioOption, fdNumber, options, optionName}) => {\n\tconst values = Array.isArray(stdioOption) ? stdioOption : [stdioOption];\n\tconst initialStdioItems = [\n\t\t...values.map(value => initializeStdioItem(value, optionName)),\n\t\t...handleInputOptions(options, fdNumber),\n\t];\n\n\tconst stdioItems = filterDuplicates(initialStdioItems);\n\tconst isStdioArray = stdioItems.length > 1;\n\tvalidateStdioArray(stdioItems, isStdioArray, optionName);\n\tvalidateStreams(stdioItems);\n\treturn {stdioItems, isStdioArray};\n};\n\nconst initializeStdioItem = (value, optionName) => ({\n\ttype: getStdioItemType(value, optionName),\n\tvalue,\n\toptionName,\n});\n\nconst validateStdioArray = (stdioItems, isStdioArray, optionName) => {\n\tif (stdioItems.length === 0) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option must not be an empty array.`);\n\t}\n\n\tif (!isStdioArray) {\n\t\treturn;\n\t}\n\n\tfor (const {value, optionName} of stdioItems) {\n\t\tif (INVALID_STDIO_ARRAY_OPTIONS.has(value)) {\n\t\t\tthrow new Error(`The \\`${optionName}\\` option must not include \\`${value}\\`.`);\n\t\t}\n\t}\n};\n\n// Using those `stdio` values together with others for the same stream does not make sense, so we make it fail.\n// However, we do allow it if the array has a single item.\nconst INVALID_STDIO_ARRAY_OPTIONS = new Set(['ignore', 'ipc']);\n\nconst validateStreams = stdioItems => {\n\tfor (const stdioItem of stdioItems) {\n\t\tvalidateFileStdio(stdioItem);\n\t}\n};\n\nconst validateFileStdio = ({type, value, optionName}) => {\n\tif (isRegularUrl(value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: URL\\` option must use the \\`file:\\` scheme.\nFor example, you can use the \\`pathToFileURL()\\` method of the \\`url\\` core module.`);\n\t}\n\n\tif (isUnknownStdioString(type, value)) {\n\t\tthrow new TypeError(`The \\`${optionName}: { file: '...' }\\` option must be used instead of \\`${optionName}: '...'\\`.`);\n\t}\n};\n\nconst validateFileObjectMode = (stdioItems, objectMode) => {\n\tif (!objectMode) {\n\t\treturn;\n\t}\n\n\tconst fileStdioItem = stdioItems.find(({type}) => FILE_TYPES.has(type));\n\tif (fileStdioItem !== undefined) {\n\t\tthrow new TypeError(`The \\`${fileStdioItem.optionName}\\` option cannot use both files and transforms in objectMode.`);\n\t}\n};\n\n// Some `stdio` values require Execa to create streams.\n// For example, file paths create file read/write streams.\n// Those transformations are specified in `addProperties`, which is both direction-specific and type-specific.\nconst getFinalFileDescriptors = ({initialFileDescriptors, addProperties, options, isSync}) => {\n\tconst fileDescriptors = [];\n\n\ttry {\n\t\tfor (const fileDescriptor of initialFileDescriptors) {\n\t\t\tfileDescriptors.push(getFinalFileDescriptor({\n\t\t\t\tfileDescriptor,\n\t\t\t\tfileDescriptors,\n\t\t\t\taddProperties,\n\t\t\t\toptions,\n\t\t\t\tisSync,\n\t\t\t}));\n\t\t}\n\n\t\treturn fileDescriptors;\n\t} catch (error) {\n\t\tcleanupCustomStreams(fileDescriptors);\n\t\tthrow error;\n\t}\n};\n\nconst getFinalFileDescriptor = ({\n\tfileDescriptor: {direction, objectMode, stdioItems},\n\tfileDescriptors,\n\taddProperties,\n\toptions,\n\tisSync,\n}) => {\n\tconst finalStdioItems = stdioItems.map(stdioItem => addStreamProperties({\n\t\tstdioItem,\n\t\taddProperties,\n\t\tdirection,\n\t\toptions,\n\t\tfileDescriptors,\n\t\tisSync,\n\t}));\n\treturn {direction, objectMode, stdioItems: finalStdioItems};\n};\n\nconst addStreamProperties = ({stdioItem, addProperties, direction, options, fileDescriptors, isSync}) => {\n\tconst duplicateStream = getDuplicateStream({\n\t\tstdioItem,\n\t\tdirection,\n\t\tfileDescriptors,\n\t\tisSync,\n\t});\n\n\tif (duplicateStream !== undefined) {\n\t\treturn {...stdioItem, stream: duplicateStream};\n\t}\n\n\treturn {\n\t\t...stdioItem,\n\t\t...addProperties[direction][stdioItem.type](stdioItem, options),\n\t};\n};\n\n// The stream error handling is performed by the piping logic above, which cannot be performed before subprocess spawning.\n// If the subprocess spawning fails (e.g. due to an invalid command), the streams need to be manually destroyed.\n// We need to create those streams before subprocess spawning, in case their creation fails, e.g. when passing an invalid generator as argument.\n// Like this, an exception would be thrown, which would prevent spawning a subprocess.\nexport const cleanupCustomStreams = fileDescriptors => {\n\tfor (const {stdioItems} of fileDescriptors) {\n\t\tfor (const {stream} of stdioItems) {\n\t\t\tif (stream !== undefined && !isStandardStream(stream)) {\n\t\t\t\tstream.destroy();\n\t\t\t}\n\t\t}\n\t}\n};\n\n// When the `std*: Iterable | WebStream | URL | filePath`, `input` or `inputFile` option is used, we pipe to `subprocess.std*`.\n// When the `std*: Array` option is used, we emulate some of the native values ('inherit', Node.js stream and file descriptor integer). To do so, we also need to pipe to `subprocess.std*`.\n// Therefore the `std*` options must be either `pipe` or `overlapped`. Other values do not set `subprocess.std*`.\nconst forwardStdio = stdioItems => {\n\tif (stdioItems.length > 1) {\n\t\treturn stdioItems.some(({value}) => value === 'overlapped') ? 'overlapped' : 'pipe';\n\t}\n\n\tconst [{type, value}] = stdioItems;\n\treturn type === 'native' ? value : 'pipe';\n};\n","import {readFileSync} from 'node:fs';\nimport {bufferToUint8Array} from '../utils/uint-array.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Normalize `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in sync mode\nexport const handleStdioSync = (options, verboseInfo) => handleStdio(addPropertiesSync, options, verboseInfo, true);\n\nconst forbiddenIfSync = ({type, optionName}) => {\n\tthrowInvalidSyncValue(optionName, TYPE_TO_MESSAGE[type]);\n};\n\nconst forbiddenNativeIfSync = ({optionName, value}) => {\n\tif (value === 'ipc' || value === 'overlapped') {\n\t\tthrowInvalidSyncValue(optionName, `\"${value}\"`);\n\t}\n\n\treturn {};\n};\n\nconst throwInvalidSyncValue = (optionName, value) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${value} with synchronous methods.`);\n};\n\n// Create streams used internally for redirecting when using specific values for the `std*` options, in sync mode.\n// For example, `stdin: {file}` reads the file synchronously, then passes it as the `input` option.\nconst addProperties = {\n\tgenerator() {},\n\tasyncGenerator: forbiddenIfSync,\n\twebStream: forbiddenIfSync,\n\tnodeStream: forbiddenIfSync,\n\twebTransform: forbiddenIfSync,\n\tduplex: forbiddenIfSync,\n\tasyncIterable: forbiddenIfSync,\n\tnative: forbiddenNativeIfSync,\n};\n\nconst addPropertiesSync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({contents: [bufferToUint8Array(readFileSync(value))]}),\n\t\tfilePath: ({value: {file}}) => ({contents: [bufferToUint8Array(readFileSync(file))]}),\n\t\tfileNumber: forbiddenIfSync,\n\t\titerable: ({value}) => ({contents: [...value]}),\n\t\tstring: ({value}) => ({contents: [value]}),\n\t\tuint8Array: ({value}) => ({contents: [value]}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({path: value}),\n\t\tfilePath: ({value: {file}}) => ({path: file}),\n\t\tfileNumber: ({value}) => ({path: value}),\n\t\titerable: forbiddenIfSync,\n\t\tstring: forbiddenIfSync,\n\t\tuint8Array: forbiddenIfSync,\n\t},\n};\n","import stripFinalNewlineFunction from 'strip-final-newline';\n\n// Apply `stripFinalNewline` option, which applies to `result.stdout|stderr|all|stdio[*]`.\n// If the `lines` option is used, it is applied on each line, but using a different function.\nexport const stripNewline = (value, {stripFinalNewline}, fdNumber) => getStripFinalNewline(stripFinalNewline, fdNumber) && value !== undefined && !Array.isArray(value)\n\t? stripFinalNewlineFunction(value)\n\t: value;\n\n// Retrieve `stripFinalNewline` option value, including with `subprocess.all`\nexport const getStripFinalNewline = (stripFinalNewline, fdNumber) => fdNumber === 'all'\n\t? stripFinalNewline[1] || stripFinalNewline[2]\n\t: stripFinalNewline[fdNumber];\n","// Split chunks line-wise for generators passed to the `std*` options\nexport const getSplitLinesGenerator = (binary, preserveNewlines, skipped, state) => binary || skipped\n\t? undefined\n\t: initializeSplitLines(preserveNewlines, state);\n\n// Same but for synchronous methods\nexport const splitLinesSync = (chunk, preserveNewlines, objectMode) => objectMode\n\t? chunk.flatMap(item => splitLinesItemSync(item, preserveNewlines))\n\t: splitLinesItemSync(chunk, preserveNewlines);\n\nconst splitLinesItemSync = (chunk, preserveNewlines) => {\n\tconst {transform, final} = initializeSplitLines(preserveNewlines, {});\n\treturn [...transform(chunk), ...final()];\n};\n\nconst initializeSplitLines = (preserveNewlines, state) => {\n\tstate.previousChunks = '';\n\treturn {\n\t\ttransform: splitGenerator.bind(undefined, state, preserveNewlines),\n\t\tfinal: linesFinal.bind(undefined, state),\n\t};\n};\n\n// This imperative logic is much faster than using `String.split()` and uses very low memory.\nconst splitGenerator = function * (state, preserveNewlines, chunk) {\n\tif (typeof chunk !== 'string') {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tlet {previousChunks} = state;\n\tlet start = -1;\n\n\tfor (let end = 0; end < chunk.length; end += 1) {\n\t\tif (chunk[end] === '\\n') {\n\t\t\tconst newlineLength = getNewlineLength(chunk, end, preserveNewlines, state);\n\t\t\tlet line = chunk.slice(start + 1, end + 1 - newlineLength);\n\n\t\t\tif (previousChunks.length > 0) {\n\t\t\t\tline = concatString(previousChunks, line);\n\t\t\t\tpreviousChunks = '';\n\t\t\t}\n\n\t\t\tyield line;\n\t\t\tstart = end;\n\t\t}\n\t}\n\n\tif (start !== chunk.length - 1) {\n\t\tpreviousChunks = concatString(previousChunks, chunk.slice(start + 1));\n\t}\n\n\tstate.previousChunks = previousChunks;\n};\n\nconst getNewlineLength = (chunk, end, preserveNewlines, state) => {\n\tif (preserveNewlines) {\n\t\treturn 0;\n\t}\n\n\tstate.isWindowsNewline = end !== 0 && chunk[end - 1] === '\\r';\n\treturn state.isWindowsNewline ? 2 : 1;\n};\n\nconst linesFinal = function * ({previousChunks}) {\n\tif (previousChunks.length > 0) {\n\t\tyield previousChunks;\n\t}\n};\n\n// Unless `preserveNewlines: true` is used, we strip the newline of each line.\n// This re-adds them after the user `transform` code has run.\nexport const getAppendNewlineGenerator = ({binary, preserveNewlines, readableObjectMode, state}) => binary || preserveNewlines || readableObjectMode\n\t? undefined\n\t: {transform: appendNewlineGenerator.bind(undefined, state)};\n\nconst appendNewlineGenerator = function * ({isWindowsNewline = false}, chunk) {\n\tconst {unixNewline, windowsNewline, LF, concatBytes} = typeof chunk === 'string' ? linesStringInfo : linesUint8ArrayInfo;\n\n\tif (chunk.at(-1) === LF) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst newline = isWindowsNewline ? windowsNewline : unixNewline;\n\tyield concatBytes(chunk, newline);\n};\n\nconst concatString = (firstChunk, secondChunk) => `${firstChunk}${secondChunk}`;\n\nconst linesStringInfo = {\n\twindowsNewline: '\\r\\n',\n\tunixNewline: '\\n',\n\tLF: '\\n',\n\tconcatBytes: concatString,\n};\n\nconst concatUint8Array = (firstChunk, secondChunk) => {\n\tconst chunk = new Uint8Array(firstChunk.length + secondChunk.length);\n\tchunk.set(firstChunk, 0);\n\tchunk.set(secondChunk, firstChunk.length);\n\treturn chunk;\n};\n\nconst linesUint8ArrayInfo = {\n\twindowsNewline: new Uint8Array([0x0D, 0x0A]),\n\tunixNewline: new Uint8Array([0x0A]),\n\tLF: 0x0A,\n\tconcatBytes: concatUint8Array,\n};\n","import {Buffer} from 'node:buffer';\nimport {isUint8Array} from '../utils/uint-array.js';\n\n// Validate the type of chunk argument passed to transform generators\nexport const getValidateTransformInput = (writableObjectMode, optionName) => writableObjectMode\n\t? undefined\n\t: validateStringTransformInput.bind(undefined, optionName);\n\nconst validateStringTransformInput = function * (optionName, chunk) {\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk) && !Buffer.isBuffer(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's transform must use \"objectMode: true\" to receive as input: ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\n// Validate the type of the value returned by transform generators\nexport const getValidateTransformReturn = (readableObjectMode, optionName) => readableObjectMode\n\t? validateObjectTransformReturn.bind(undefined, optionName)\n\t: validateStringTransformReturn.bind(undefined, optionName);\n\nconst validateObjectTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\tyield chunk;\n};\n\nconst validateStringTransformReturn = function * (optionName, chunk) {\n\tvalidateEmptyReturn(optionName, chunk);\n\n\tif (typeof chunk !== 'string' && !isUint8Array(chunk)) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must yield a string or an Uint8Array, not ${typeof chunk}.`);\n\t}\n\n\tyield chunk;\n};\n\nconst validateEmptyReturn = (optionName, chunk) => {\n\tif (chunk === null || chunk === undefined) {\n\t\tthrow new TypeError(`The \\`${optionName}\\` option's function must not call \\`yield ${chunk}\\`.\nInstead, \\`yield\\` should either be called with a value, or not be called at all. For example:\n  if (condition) { yield value; }`);\n\t}\n};\n","import {Buffer} from 'node:buffer';\nimport {StringDecoder} from 'node:string_decoder';\nimport {isUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\n\n/*\nWhen using binary encodings, add an internal generator that converts chunks from `Buffer` to `string` or `Uint8Array`.\nChunks might be Buffer, Uint8Array or strings since:\n- `subprocess.stdout|stderr` emits Buffers\n- `subprocess.stdin.write()` accepts Buffer, Uint8Array or string\n- Previous generators might return Uint8Array or string\n\nHowever, those are converted to Buffer:\n- on writes: `Duplex.writable` `decodeStrings: true` default option\n- on reads: `Duplex.readable` `readableEncoding: null` default option\n*/\nexport const getEncodingTransformGenerator = (binary, encoding, skipped) => {\n\tif (skipped) {\n\t\treturn;\n\t}\n\n\tif (binary) {\n\t\treturn {transform: encodingUint8ArrayGenerator.bind(undefined, new TextEncoder())};\n\t}\n\n\tconst stringDecoder = new StringDecoder(encoding);\n\treturn {\n\t\ttransform: encodingStringGenerator.bind(undefined, stringDecoder),\n\t\tfinal: encodingStringFinal.bind(undefined, stringDecoder),\n\t};\n};\n\nconst encodingUint8ArrayGenerator = function * (textEncoder, chunk) {\n\tif (Buffer.isBuffer(chunk)) {\n\t\tyield bufferToUint8Array(chunk);\n\t} else if (typeof chunk === 'string') {\n\t\tyield textEncoder.encode(chunk);\n\t} else {\n\t\tyield chunk;\n\t}\n};\n\nconst encodingStringGenerator = function * (stringDecoder, chunk) {\n\tyield isUint8Array(chunk) ? stringDecoder.write(chunk) : chunk;\n};\n\nconst encodingStringFinal = function * (stringDecoder) {\n\tconst lastChunk = stringDecoder.end();\n\tif (lastChunk !== '') {\n\t\tyield lastChunk;\n\t}\n};\n","import {callbackify} from 'node:util';\n\n// Applies a series of generator functions asynchronously\nexport const pushChunks = callbackify(async (getChunks, state, getChunksArguments, transformStream) => {\n\tstate.currentIterable = getChunks(...getChunksArguments);\n\n\ttry {\n\t\tfor await (const chunk of state.currentIterable) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\t} finally {\n\t\tdelete state.currentIterable;\n\t}\n});\n\n// For each new chunk, apply each `transform()` method\nexport const transformChunk = async function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor await (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunk(transformedChunk, generators, index + 1);\n\t}\n};\n\n// At the end, apply each `final()` method, followed by the `transform()` method of the next transforms\nexport const finalChunks = async function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunks(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunks = async function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor await (const finalChunk of final()) {\n\t\tyield * transformChunk(finalChunk, generators, index + 1);\n\t}\n};\n\n// Cancel any ongoing async generator when the Transform is destroyed, e.g. when the subprocess errors\nexport const destroyTransform = callbackify(async ({currentIterable}, error) => {\n\tif (currentIterable !== undefined) {\n\t\tawait (error ? currentIterable.throw(error) : currentIterable.return());\n\t\treturn;\n\t}\n\n\tif (error) {\n\t\tthrow error;\n\t}\n});\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n","// Duplicate the code from `run-async.js` but as synchronous functions\nexport const pushChunksSync = (getChunksSync, getChunksArguments, transformStream, done) => {\n\ttry {\n\t\tfor (const chunk of getChunksSync(...getChunksArguments)) {\n\t\t\ttransformStream.push(chunk);\n\t\t}\n\n\t\tdone();\n\t} catch (error) {\n\t\tdone(error);\n\t}\n};\n\n// Run synchronous generators with `execaSync()`\nexport const runTransformSync = (generators, chunks) => [\n\t...chunks.flatMap(chunk => [...transformChunkSync(chunk, generators, 0)]),\n\t...finalChunksSync(generators),\n];\n\nexport const transformChunkSync = function * (chunk, generators, index) {\n\tif (index === generators.length) {\n\t\tyield chunk;\n\t\treturn;\n\t}\n\n\tconst {transform = identityGenerator} = generators[index];\n\tfor (const transformedChunk of transform(chunk)) {\n\t\tyield * transformChunkSync(transformedChunk, generators, index + 1);\n\t}\n};\n\nexport const finalChunksSync = function * (generators) {\n\tfor (const [index, {final}] of Object.entries(generators)) {\n\t\tyield * generatorFinalChunksSync(final, Number(index), generators);\n\t}\n};\n\nconst generatorFinalChunksSync = function * (final, index, generators) {\n\tif (final === undefined) {\n\t\treturn;\n\t}\n\n\tfor (const finalChunk of final()) {\n\t\tyield * transformChunkSync(finalChunk, generators, index + 1);\n\t}\n};\n\nconst identityGenerator = function * (chunk) {\n\tyield chunk;\n};\n","import {Transform, getDefaultHighWaterMark} from 'node:stream';\nimport {isAsyncGenerator} from '../stdio/type.js';\nimport {getSplitLinesGenerator, getAppendNewlineGenerator} from './split.js';\nimport {getValidateTransformInput, getValidateTransformReturn} from './validate.js';\nimport {getEncodingTransformGenerator} from './encoding-transform.js';\nimport {\n\tpushChunks,\n\ttransformChunk,\n\tfinalChunks,\n\tdestroyTransform,\n} from './run-async.js';\nimport {\n\tpushChunksSync,\n\ttransformChunkSync,\n\tfinalChunksSync,\n\trunTransformSync,\n} from './run-sync.js';\n\n/*\nGenerators can be used to transform/filter standard streams.\n\nGenerators have a simple syntax, yet allows all of the following:\n- Sharing `state` between chunks\n- Flushing logic, by using a `final` function\n- Asynchronous logic\n- Emitting multiple chunks from a single source chunk, even if spaced in time, by using multiple `yield`\n- Filtering, by using no `yield`\n\nTherefore, there is no need to allow Node.js or web transform streams.\n\nThe `highWaterMark` is kept as the default value, since this is what `subprocess.std*` uses.\n\nChunks are currently processed serially. We could add a `concurrency` option to parallelize in the future.\n\nTransform an array of generator functions into a `Transform` stream.\n`Duplex.from(generator)` cannot be used because it does not allow setting the `objectMode` and `highWaterMark`.\n*/\nexport const generatorToStream = ({\n\tvalue,\n\tvalue: {transform, final, writableObjectMode, readableObjectMode},\n\toptionName,\n}, {encoding}) => {\n\tconst state = {};\n\tconst generators = addInternalGenerators(value, encoding, optionName);\n\n\tconst transformAsync = isAsyncGenerator(transform);\n\tconst finalAsync = isAsyncGenerator(final);\n\tconst transformMethod = transformAsync\n\t\t? pushChunks.bind(undefined, transformChunk, state)\n\t\t: pushChunksSync.bind(undefined, transformChunkSync);\n\tconst finalMethod = transformAsync || finalAsync\n\t\t? pushChunks.bind(undefined, finalChunks, state)\n\t\t: pushChunksSync.bind(undefined, finalChunksSync);\n\tconst destroyMethod = transformAsync || finalAsync\n\t\t? destroyTransform.bind(undefined, state)\n\t\t: undefined;\n\n\tconst stream = new Transform({\n\t\twritableObjectMode,\n\t\twritableHighWaterMark: getDefaultHighWaterMark(writableObjectMode),\n\t\treadableObjectMode,\n\t\treadableHighWaterMark: getDefaultHighWaterMark(readableObjectMode),\n\t\ttransform(chunk, encoding, done) {\n\t\t\ttransformMethod([chunk, generators, 0], this, done);\n\t\t},\n\t\tflush(done) {\n\t\t\tfinalMethod([generators], this, done);\n\t\t},\n\t\tdestroy: destroyMethod,\n\t});\n\treturn {stream};\n};\n\n// Applies transform generators in sync mode\nexport const runGeneratorsSync = (chunks, stdioItems, encoding, isInput) => {\n\tconst generators = stdioItems.filter(({type}) => type === 'generator');\n\tconst reversedGenerators = isInput ? generators.reverse() : generators;\n\n\tfor (const {value, optionName} of reversedGenerators) {\n\t\tconst generators = addInternalGenerators(value, encoding, optionName);\n\t\tchunks = runTransformSync(generators, chunks);\n\t}\n\n\treturn chunks;\n};\n\n// Generators used internally to convert the chunk type, validate it, and split into lines\nconst addInternalGenerators = (\n\t{transform, final, binary, writableObjectMode, readableObjectMode, preserveNewlines},\n\tencoding,\n\toptionName,\n) => {\n\tconst state = {};\n\treturn [\n\t\t{transform: getValidateTransformInput(writableObjectMode, optionName)},\n\t\tgetEncodingTransformGenerator(binary, encoding, writableObjectMode),\n\t\tgetSplitLinesGenerator(binary, preserveNewlines, writableObjectMode, state),\n\t\t{transform, final},\n\t\t{transform: getValidateTransformReturn(readableObjectMode, optionName)},\n\t\tgetAppendNewlineGenerator({\n\t\t\tbinary,\n\t\t\tpreserveNewlines,\n\t\t\treadableObjectMode,\n\t\t\tstate,\n\t\t}),\n\t].filter(Boolean);\n};\n","import {runGeneratorsSync} from '../transform/generator.js';\nimport {joinToUint8Array, isUint8Array} from '../utils/uint-array.js';\nimport {TYPE_TO_MESSAGE} from '../stdio/type.js';\n\n// Apply `stdin`/`input`/`inputFile` options, before spawning, in sync mode, by converting it to the `input` option\nexport const addInputOptionsSync = (fileDescriptors, options) => {\n\tfor (const fdNumber of getInputFdNumbers(fileDescriptors)) {\n\t\taddInputOptionSync(fileDescriptors, fdNumber, options);\n\t}\n};\n\nconst getInputFdNumbers = fileDescriptors => new Set(Object.entries(fileDescriptors)\n\t.filter(([, {direction}]) => direction === 'input')\n\t.map(([fdNumber]) => Number(fdNumber)));\n\nconst addInputOptionSync = (fileDescriptors, fdNumber, options) => {\n\tconst {stdioItems} = fileDescriptors[fdNumber];\n\tconst allStdioItems = stdioItems.filter(({contents}) => contents !== undefined);\n\tif (allStdioItems.length === 0) {\n\t\treturn;\n\t}\n\n\tif (fdNumber !== 0) {\n\t\tconst [{type, optionName}] = allStdioItems;\n\t\tthrow new TypeError(`Only the \\`stdin\\` option, not \\`${optionName}\\`, can be ${TYPE_TO_MESSAGE[type]} with synchronous methods.`);\n\t}\n\n\tconst allContents = allStdioItems.map(({contents}) => contents);\n\tconst transformedContents = allContents.map(contents => applySingleInputGeneratorsSync(contents, stdioItems));\n\toptions.input = joinToUint8Array(transformedContents);\n};\n\nconst applySingleInputGeneratorsSync = (contents, stdioItems) => {\n\tconst newContents = runGeneratorsSync(contents, stdioItems, 'utf8', true);\n\tvalidateSerializable(newContents);\n\treturn joinToUint8Array(newContents);\n};\n\nconst validateSerializable = newContents => {\n\tconst invalidItem = newContents.find(item => typeof item !== 'string' && !isUint8Array(item));\n\tif (invalidItem !== undefined) {\n\t\tthrow new TypeError(`The \\`stdin\\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${invalidItem}.`);\n\t}\n};\n","import {inspect} from 'node:util';\nimport {escapeLines} from '../arguments/escape.js';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {verboseLog} from './log.js';\n\n// `ignore` opts-out of `verbose` for a specific stream.\n// `ipc` cannot use piping.\n// `inherit` would result in double printing.\n// They can also lead to double printing when passing file descriptor integers or `process.std*`.\n// This only leaves with `pipe` and `overlapped`.\nexport const shouldLogOutput = ({stdioItems, encoding, verboseInfo: {verbose}, fdNumber}) => fdNumber !== 'all'\n\t&& verbose[fdNumber] === 'full'\n\t&& !BINARY_ENCODINGS.has(encoding)\n\t&& fdUsesVerbose(fdNumber)\n\t&& (stdioItems.some(({type, value}) => type === 'native' && PIPED_STDIO_VALUES.has(value))\n\t|| stdioItems.every(({type}) => TRANSFORM_TYPES.has(type)));\n\n// Printing input streams would be confusing.\n// Files and streams can produce big outputs, which we don't want to print.\n// We could print `stdio[3+]` but it often is redirected to files and streams, with the same issue.\n// So we only print stdout and stderr.\nconst fdUsesVerbose = fdNumber => fdNumber === 1 || fdNumber === 2;\n\nconst PIPED_STDIO_VALUES = new Set(['pipe', 'overlapped']);\n\n// `verbose` printing logic with async methods\nexport const logLines = async (linesIterable, stream, verboseInfo) => {\n\tfor await (const line of linesIterable) {\n\t\tif (!isPipingStream(stream)) {\n\t\t\tlogLine(line, verboseInfo);\n\t\t}\n\t}\n};\n\n// `verbose` printing logic with sync methods\nexport const logLinesSync = (linesArray, verboseInfo) => {\n\tfor (const line of linesArray) {\n\t\tlogLine(line, verboseInfo);\n\t}\n};\n\n// When `subprocess.stdout|stderr.pipe()` is called, `verbose` becomes a noop.\n// This prevents the following problems:\n//  - `.pipe()` achieves the same result as using `stdout: 'inherit'`, `stdout: stream`, etc. which also make `verbose` a noop.\n//    For example, `subprocess.stdout.pipe(process.stdin)` would print each line twice.\n//  - When chaining subprocesses with `subprocess.pipe(otherSubprocess)`, only the last one should print its output.\n// Detecting whether `.pipe()` is impossible without monkey-patching it, so we use the following undocumented property.\n// This is not a critical behavior since changes of the following property would only make `verbose` more verbose.\nconst isPipingStream = stream => stream._readableState.pipes.length > 0;\n\n// When `verbose` is `full`, print stdout|stderr\nconst logLine = (line, {verboseId}) => {\n\tconst lines = typeof line === 'string' ? line : inspect(line);\n\tconst escapedLines = escapeLines(lines);\n\tconst spacedLines = escapedLines.replaceAll('\\t', ' '.repeat(TAB_SIZE));\n\tverboseLog(spacedLines, verboseId, 'output');\n};\n\n// Same as `util.inspect()`\nconst TAB_SIZE = 2;\n","import {writeFileSync, appendFileSync} from 'node:fs';\nimport {shouldLogOutput, logLinesSync} from '../verbose/output.js';\nimport {runGeneratorsSync} from '../transform/generator.js';\nimport {splitLinesSync} from '../transform/split.js';\nimport {joinToString, joinToUint8Array, bufferToUint8Array} from '../utils/uint-array.js';\nimport {FILE_TYPES} from '../stdio/type.js';\nimport {truncateMaxBufferSync} from './max-buffer.js';\n\n// Apply `stdout`/`stderr` options, after spawning, in sync mode\nexport const transformOutputSync = ({fileDescriptors, syncResult: {output}, options, isMaxBuffer, verboseInfo}) => {\n\tif (output === null) {\n\t\treturn {output: Array.from({length: 3})};\n\t}\n\n\tconst state = {};\n\tconst outputFiles = new Set([]);\n\tconst transformedOutput = output.map((result, fdNumber) =>\n\t\ttransformOutputResultSync({\n\t\t\tresult,\n\t\t\tfileDescriptors,\n\t\t\tfdNumber,\n\t\t\tstate,\n\t\t\toutputFiles,\n\t\t\tisMaxBuffer,\n\t\t\tverboseInfo,\n\t\t}, options));\n\treturn {output: transformedOutput, ...state};\n};\n\nconst transformOutputResultSync = (\n\t{result, fileDescriptors, fdNumber, state, outputFiles, isMaxBuffer, verboseInfo},\n\t{buffer, encoding, lines, stripFinalNewline, maxBuffer},\n) => {\n\tif (result === null) {\n\t\treturn;\n\t}\n\n\tconst truncatedResult = truncateMaxBufferSync(result, isMaxBuffer, maxBuffer);\n\tconst uint8ArrayResult = bufferToUint8Array(truncatedResult);\n\tconst {stdioItems, objectMode} = fileDescriptors[fdNumber];\n\tconst chunks = runOutputGeneratorsSync([uint8ArrayResult], stdioItems, encoding, state);\n\tconst {serializedResult, finalResult = serializedResult} = serializeChunks({\n\t\tchunks,\n\t\tobjectMode,\n\t\tencoding,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tfdNumber,\n\t});\n\n\tif (shouldLogOutput({\n\t\tstdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\tconst linesArray = splitLinesSync(serializedResult, false, objectMode);\n\t\tlogLinesSync(linesArray, verboseInfo);\n\t}\n\n\tconst returnedResult = buffer[fdNumber] ? finalResult : undefined;\n\n\ttry {\n\t\tif (state.error === undefined) {\n\t\t\twriteToFiles(serializedResult, stdioItems, outputFiles);\n\t\t}\n\n\t\treturn returnedResult;\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn returnedResult;\n\t}\n};\n\n// Applies transform generators to `stdout`/`stderr`\nconst runOutputGeneratorsSync = (chunks, stdioItems, encoding, state) => {\n\ttry {\n\t\treturn runGeneratorsSync(chunks, stdioItems, encoding, false);\n\t} catch (error) {\n\t\tstate.error = error;\n\t\treturn chunks;\n\t}\n};\n\n// The contents is converted to three stages:\n//  - serializedResult: used when the target is a file path/URL or a file descriptor (including 'inherit')\n//  - finalResult/returnedResult: returned as `result.std*`\nconst serializeChunks = ({chunks, objectMode, encoding, lines, stripFinalNewline, fdNumber}) => {\n\tif (objectMode) {\n\t\treturn {serializedResult: chunks};\n\t}\n\n\tif (encoding === 'buffer') {\n\t\treturn {serializedResult: joinToUint8Array(chunks)};\n\t}\n\n\tconst serializedResult = joinToString(chunks, encoding);\n\tif (lines[fdNumber]) {\n\t\treturn {serializedResult, finalResult: splitLinesSync(serializedResult, !stripFinalNewline[fdNumber], objectMode)};\n\t}\n\n\treturn {serializedResult};\n};\n\n// When the `std*` target is a file path/URL or a file descriptor\nconst writeToFiles = (serializedResult, stdioItems, outputFiles) => {\n\tfor (const {path} of stdioItems.filter(({type}) => FILE_TYPES.has(type))) {\n\t\tconst pathString = typeof path === 'string' ? path : path.toString();\n\t\tif (outputFiles.has(pathString)) {\n\t\t\tappendFileSync(path, serializedResult);\n\t\t} else {\n\t\t\toutputFiles.add(pathString);\n\t\t\twriteFileSync(path, serializedResult);\n\t\t}\n\t}\n};\n","import {once} from 'node:events';\nimport {DiscardedError} from '../return/final-error.js';\n\n// If `error` is emitted before `spawn`, `exit` will never be emitted.\n// However, `error` might be emitted after `spawn`, e.g. with the `cancelSignal` option.\n// In that case, `exit` will still be emitted.\n// Since the `exit` event contains the signal name, we want to make sure we are listening for it.\n// This function also takes into account the following unlikely cases:\n//  - `exit` being emitted in the same microtask as `spawn`\n//  - `error` being emitted multiple times\nexport const waitForExit = async subprocess => {\n\tconst [spawnPayload, exitPayload] = await Promise.allSettled([\n\t\tonce(subprocess, 'spawn'),\n\t\tonce(subprocess, 'exit'),\n\t]);\n\n\tif (spawnPayload.status === 'rejected') {\n\t\treturn [];\n\t}\n\n\treturn exitPayload.status === 'rejected'\n\t\t? waitForSubprocessExit(subprocess)\n\t\t: exitPayload.value;\n};\n\nconst waitForSubprocessExit = async subprocess => {\n\ttry {\n\t\treturn await once(subprocess, 'exit');\n\t} catch {\n\t\treturn waitForSubprocessExit(subprocess);\n\t}\n};\n\n// Retrieve the final exit code and|or signal name\nexport const waitForSuccessfulExit = async exitPromise => {\n\tconst [exitCode, signal] = await exitPromise;\n\n\tif (!isSubprocessErrorExit(exitCode, signal) && isFailedExit(exitCode, signal)) {\n\t\tthrow new DiscardedError();\n\t}\n\n\treturn [exitCode, signal];\n};\n\n// When the subprocess fails due to an `error` event\nconst isSubprocessErrorExit = (exitCode, signal) => exitCode === undefined && signal === undefined;\n// When the subprocess fails due to a non-0 exit code or to a signal termination\nexport const isFailedExit = (exitCode, signal) => exitCode !== 0 || signal !== null;\n","import {DiscardedError} from '../return/final-error.js';\nimport {isMaxBufferSync} from '../io/max-buffer.js';\nimport {isFailedExit} from './exit-async.js';\n\n// Retrieve exit code, signal name and error information, with synchronous methods\nexport const getExitResultSync = ({error, status: exitCode, signal, output}, {maxBuffer}) => {\n\tconst resultError = getResultError(error, exitCode, signal);\n\tconst timedOut = resultError?.code === 'ETIMEDOUT';\n\tconst isMaxBuffer = isMaxBufferSync(resultError, output, maxBuffer);\n\treturn {\n\t\tresultError,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t};\n};\n\nconst getResultError = (error, exitCode, signal) => {\n\tif (error !== undefined) {\n\t\treturn error;\n\t}\n\n\treturn isFailedExit(exitCode, signal) ? new DiscardedError() : undefined;\n};\n","import {spawnSync} from 'node:child_process';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {makeError, makeEarlyError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleStdioSync} from '../stdio/handle-sync.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {addInputOptionsSync} from '../io/input-sync.js';\nimport {transformOutputSync} from '../io/output-sync.js';\nimport {getMaxBufferSync} from '../io/max-buffer.js';\nimport {logEarlyResult} from '../verbose/complete.js';\nimport {getAllSync} from '../resolve/all-sync.js';\nimport {getExitResultSync} from '../resolve/exit-sync.js';\n\n// Main shared logic for all sync methods: `execaSync()`, `execaCommandSync()`, `$.sync()`\nexport const execaCoreSync = (rawFile, rawArguments, rawOptions) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleSyncArguments(rawFile, rawArguments, rawOptions);\n\tconst result = spawnSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\n// Compute arguments to pass to `child_process.spawnSync()`\nconst handleSyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\n\ttry {\n\t\tconst syncOptions = normalizeSyncOptions(rawOptions);\n\t\tconst {file, commandArguments, options} = normalizeOptions(rawFile, rawArguments, syncOptions);\n\t\tvalidateSyncOptions(options);\n\t\tconst fileDescriptors = handleStdioSync(options, verboseInfo);\n\t\treturn {\n\t\t\tfile,\n\t\t\tcommandArguments,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tstartTime,\n\t\t\tverboseInfo,\n\t\t\toptions,\n\t\t\tfileDescriptors,\n\t\t};\n\t} catch (error) {\n\t\tlogEarlyResult(error, startTime, verboseInfo);\n\t\tthrow error;\n\t}\n};\n\n// Options normalization logic specific to sync methods\nconst normalizeSyncOptions = options => options.node && !options.ipc ? {...options, ipc: false} : options;\n\n// Options validation logic specific to sync methods\nconst validateSyncOptions = ({ipc, detached, cancelSignal}) => {\n\tif (ipc) {\n\t\tthrowInvalidSyncOption('ipc: true');\n\t}\n\n\tif (detached) {\n\t\tthrowInvalidSyncOption('detached: true');\n\t}\n\n\tif (cancelSignal) {\n\t\tthrowInvalidSyncOption('cancelSignal');\n\t}\n};\n\nconst throwInvalidSyncOption = value => {\n\tthrow new TypeError(`The \"${value}\" option cannot be used with synchronous methods.`);\n};\n\nconst spawnSubprocessSync = ({file, commandArguments, options, command, escapedCommand, verboseInfo, fileDescriptors, startTime}) => {\n\tconst syncResult = runSubprocessSync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t});\n\tif (syncResult.failed) {\n\t\treturn syncResult;\n\t}\n\n\tconst {resultError, exitCode, signal, timedOut, isMaxBuffer} = getExitResultSync(syncResult, options);\n\tconst {output, error = resultError} = transformOutputSync({\n\t\tfileDescriptors,\n\t\tsyncResult,\n\t\toptions,\n\t\tisMaxBuffer,\n\t\tverboseInfo,\n\t});\n\tconst stdio = output.map((stdioOutput, fdNumber) => stripNewline(stdioOutput, options, fdNumber));\n\tconst all = stripNewline(getAllSync(output, options), options, 'all');\n\treturn getSyncResult({\n\t\terror,\n\t\texitCode,\n\t\tsignal,\n\t\ttimedOut,\n\t\tisMaxBuffer,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n};\n\nconst runSubprocessSync = ({file, commandArguments, options, command, escapedCommand, fileDescriptors, startTime}) => {\n\ttry {\n\t\taddInputOptionsSync(fileDescriptors, options);\n\t\tconst normalizedOptions = normalizeSpawnSyncOptions(options);\n\t\treturn spawnSync(file, commandArguments, normalizedOptions);\n\t} catch (error) {\n\t\treturn makeEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tisSync: true,\n\t\t});\n\t}\n};\n\n// The `encoding` option is handled by Execa, not by `child_process.spawnSync()`\nconst normalizeSpawnSyncOptions = ({encoding, maxBuffer, ...options}) => ({...options, encoding: 'buffer', maxBuffer: getMaxBufferSync(maxBuffer)});\n\nconst getSyncResult = ({error, exitCode, signal, timedOut, isMaxBuffer, stdio, all, options, command, escapedCommand, startTime}) => error === undefined\n\t? makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tstartTime,\n\t})\n\t: makeError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut,\n\t\tisCanceled: false,\n\t\tisMaxBuffer,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: true,\n\t});\n","import {isUint8Array, concatUint8Arrays} from '../utils/uint-array.js';\nimport {stripNewline} from '../io/strip-newline.js';\n\n// Retrieve `result.all` with synchronous methods\nexport const getAllSync = ([, stdout, stderr], options) => {\n\tif (!options.all) {\n\t\treturn;\n\t}\n\n\tif (stdout === undefined) {\n\t\treturn stderr;\n\t}\n\n\tif (stderr === undefined) {\n\t\treturn stdout;\n\t}\n\n\tif (Array.isArray(stdout)) {\n\t\treturn Array.isArray(stderr)\n\t\t\t? [...stdout, ...stderr]\n\t\t\t: [...stdout, stripNewline(stderr, options, 'all')];\n\t}\n\n\tif (Array.isArray(stderr)) {\n\t\treturn [stripNewline(stdout, options, 'all'), ...stderr];\n\t}\n\n\tif (isUint8Array(stdout) && isUint8Array(stderr)) {\n\t\treturn concatUint8Arrays([stdout, stderr]);\n\t}\n\n\treturn `${stdout}${stderr}`;\n};\n","import {ChildProcess} from 'node:child_process';\nimport {\n\tPassThrough,\n\tReadable,\n\tWritable,\n\tDuplex,\n} from 'node:stream';\nimport {cleanupCustomStreams} from '../stdio/handle.js';\nimport {makeEarlyError} from './result.js';\nimport {handleResult} from './reject.js';\n\n// When the subprocess fails to spawn.\n// We ensure the returned error is always both a promise and a subprocess.\nexport const handleEarlyError = ({error, command, escapedCommand, fileDescriptors, options, startTime, verboseInfo}) => {\n\tcleanupCustomStreams(fileDescriptors);\n\n\tconst subprocess = new ChildProcess();\n\tcreateDummyStreams(subprocess, fileDescriptors);\n\tObject.assign(subprocess, {readable, writable, duplex});\n\n\tconst earlyError = makeEarlyError({\n\t\terror,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t});\n\tconst promise = handleDummyPromise(earlyError, verboseInfo, options);\n\treturn {subprocess, promise};\n};\n\nconst createDummyStreams = (subprocess, fileDescriptors) => {\n\tconst stdin = createDummyStream();\n\tconst stdout = createDummyStream();\n\tconst stderr = createDummyStream();\n\tconst extraStdio = Array.from({length: fileDescriptors.length - 3}, createDummyStream);\n\tconst all = createDummyStream();\n\tconst stdio = [stdin, stdout, stderr, ...extraStdio];\n\tObject.assign(subprocess, {\n\t\tstdin,\n\t\tstdout,\n\t\tstderr,\n\t\tall,\n\t\tstdio,\n\t});\n};\n\nconst createDummyStream = () => {\n\tconst stream = new PassThrough();\n\tstream.end();\n\treturn stream;\n};\n\nconst readable = () => new Readable({read() {}});\nconst writable = () => new Writable({write() {}});\nconst duplex = () => new Duplex({read() {}, write() {}});\n\nconst handleDummyPromise = async (error, verboseInfo, options) => handleResult(error, verboseInfo, options);\n","import {createReadStream, createWriteStream} from 'node:fs';\nimport {Buffer} from 'node:buffer';\nimport {Readable, Writable, Duplex} from 'node:stream';\nimport {generatorToStream} from '../transform/generator.js';\nimport {handleStdio} from './handle.js';\nimport {TYPE_TO_MESSAGE} from './type.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, before spawning, in async mode\nexport const handleStdioAsync = (options, verboseInfo) => handleStdio(addPropertiesAsync, options, verboseInfo, false);\n\nconst forbiddenIfAsync = ({type, optionName}) => {\n\tthrow new TypeError(`The \\`${optionName}\\` option cannot be ${TYPE_TO_MESSAGE[type]}.`);\n};\n\n// Create streams used internally for piping when using specific values for the `std*` options, in async mode.\n// For example, `stdout: {file}` creates a file stream, which is piped from/to.\nconst addProperties = {\n\tfileNumber: forbiddenIfAsync,\n\tgenerator: generatorToStream,\n\tasyncGenerator: generatorToStream,\n\tnodeStream: ({value}) => ({stream: value}),\n\twebTransform({value: {transform, writableObjectMode, readableObjectMode}}) {\n\t\tconst objectMode = writableObjectMode || readableObjectMode;\n\t\tconst stream = Duplex.fromWeb(transform, {objectMode});\n\t\treturn {stream};\n\t},\n\tduplex: ({value: {transform}}) => ({stream: transform}),\n\tnative() {},\n};\n\nconst addPropertiesAsync = {\n\tinput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createReadStream(value)}),\n\t\tfilePath: ({value: {file}}) => ({stream: createReadStream(file)}),\n\t\twebStream: ({value}) => ({stream: Readable.fromWeb(value)}),\n\t\titerable: ({value}) => ({stream: Readable.from(value)}),\n\t\tasyncIterable: ({value}) => ({stream: Readable.from(value)}),\n\t\tstring: ({value}) => ({stream: Readable.from(value)}),\n\t\tuint8Array: ({value}) => ({stream: Readable.from(Buffer.from(value))}),\n\t},\n\toutput: {\n\t\t...addProperties,\n\t\tfileUrl: ({value}) => ({stream: createWriteStream(value)}),\n\t\tfilePath: ({value: {file}}) => ({stream: createWriteStream(file)}),\n\t\twebStream: ({value}) => ({stream: Writable.fromWeb(value)}),\n\t\titerable: forbiddenIfAsync,\n\t\tasyncIterable: forbiddenIfAsync,\n\t\tstring: forbiddenIfAsync,\n\t\tuint8Array: forbiddenIfAsync,\n\t},\n};\n","import {on, once} from 'node:events';\nimport {PassThrough as PassThroughStream, getDefaultHighWaterMark} from 'node:stream';\nimport {finished} from 'node:stream/promises';\n\nexport default function mergeStreams(streams) {\n\tif (!Array.isArray(streams)) {\n\t\tthrow new TypeError(`Expected an array, got \\`${typeof streams}\\`.`);\n\t}\n\n\tfor (const stream of streams) {\n\t\tvalidateStream(stream);\n\t}\n\n\tconst objectMode = streams.some(({readableObjectMode}) => readableObjectMode);\n\tconst highWaterMark = getHighWaterMark(streams, objectMode);\n\tconst passThroughStream = new MergedStream({\n\t\tobjectMode,\n\t\twritableHighWaterMark: highWaterMark,\n\t\treadableHighWaterMark: highWaterMark,\n\t});\n\n\tfor (const stream of streams) {\n\t\tpassThroughStream.add(stream);\n\t}\n\n\treturn passThroughStream;\n}\n\nconst getHighWaterMark = (streams, objectMode) => {\n\tif (streams.length === 0) {\n\t\treturn getDefaultHighWaterMark(objectMode);\n\t}\n\n\tconst highWaterMarks = streams\n\t\t.filter(({readableObjectMode}) => readableObjectMode === objectMode)\n\t\t.map(({readableHighWaterMark}) => readableHighWaterMark);\n\treturn Math.max(...highWaterMarks);\n};\n\nclass MergedStream extends PassThroughStream {\n\t#streams = new Set([]);\n\t#ended = new Set([]);\n\t#aborted = new Set([]);\n\t#onFinished;\n\t#unpipeEvent = Symbol('unpipe');\n\t#streamPromises = new WeakMap();\n\n\tadd(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (this.#streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#streams.add(stream);\n\n\t\tthis.#onFinished ??= onMergedStreamFinished(this, this.#streams, this.#unpipeEvent);\n\t\tconst streamPromise = endWhenStreamsDone({\n\t\t\tpassThroughStream: this,\n\t\t\tstream,\n\t\t\tstreams: this.#streams,\n\t\t\tended: this.#ended,\n\t\t\taborted: this.#aborted,\n\t\t\tonFinished: this.#onFinished,\n\t\t\tunpipeEvent: this.#unpipeEvent,\n\t\t});\n\t\tthis.#streamPromises.set(stream, streamPromise);\n\n\t\tstream.pipe(this, {end: false});\n\t}\n\n\tasync remove(stream) {\n\t\tvalidateStream(stream);\n\n\t\tif (!this.#streams.has(stream)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst streamPromise = this.#streamPromises.get(stream);\n\t\tif (streamPromise === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.#streamPromises.delete(stream);\n\n\t\tstream.unpipe(this);\n\t\tawait streamPromise;\n\t\treturn true;\n\t}\n}\n\nconst onMergedStreamFinished = async (passThroughStream, streams, unpipeEvent) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_COUNT);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tonMergedStreamEnd(passThroughStream, controller),\n\t\t\tonInputStreamsUnpipe(passThroughStream, streams, unpipeEvent, controller),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_COUNT);\n\t}\n};\n\nconst onMergedStreamEnd = async (passThroughStream, {signal}) => {\n\ttry {\n\t\tawait finished(passThroughStream, {signal, cleanup: true});\n\t} catch (error) {\n\t\terrorOrAbortStream(passThroughStream, error);\n\t\tthrow error;\n\t}\n};\n\nconst onInputStreamsUnpipe = async (passThroughStream, streams, unpipeEvent, {signal}) => {\n\tfor await (const [unpipedStream] of on(passThroughStream, 'unpipe', {signal})) {\n\t\tif (streams.has(unpipedStream)) {\n\t\t\tunpipedStream.emit(unpipeEvent);\n\t\t}\n\t}\n};\n\nconst validateStream = stream => {\n\tif (typeof stream?.pipe !== 'function') {\n\t\tthrow new TypeError(`Expected a readable stream, got: \\`${typeof stream}\\`.`);\n\t}\n};\n\nconst endWhenStreamsDone = async ({passThroughStream, stream, streams, ended, aborted, onFinished, unpipeEvent}) => {\n\tupdateMaxListeners(passThroughStream, PASSTHROUGH_LISTENERS_PER_STREAM);\n\tconst controller = new AbortController();\n\n\ttry {\n\t\tawait Promise.race([\n\t\t\tafterMergedStreamFinished(onFinished, stream, controller),\n\t\t\tonInputStreamEnd({\n\t\t\t\tpassThroughStream,\n\t\t\t\tstream,\n\t\t\t\tstreams,\n\t\t\t\tended,\n\t\t\t\taborted,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t\tonInputStreamUnpipe({\n\t\t\t\tstream,\n\t\t\t\tstreams,\n\t\t\t\tended,\n\t\t\t\taborted,\n\t\t\t\tunpipeEvent,\n\t\t\t\tcontroller,\n\t\t\t}),\n\t\t]);\n\t} finally {\n\t\tcontroller.abort();\n\t\tupdateMaxListeners(passThroughStream, -PASSTHROUGH_LISTENERS_PER_STREAM);\n\t}\n\n\tif (streams.size > 0 && streams.size === ended.size + aborted.size) {\n\t\tif (ended.size === 0 && aborted.size > 0) {\n\t\t\tabortStream(passThroughStream);\n\t\t} else {\n\t\t\tendStream(passThroughStream);\n\t\t}\n\t}\n};\n\nconst afterMergedStreamFinished = async (onFinished, stream, {signal}) => {\n\ttry {\n\t\tawait onFinished;\n\t\tif (!signal.aborted) {\n\t\t\tabortStream(stream);\n\t\t}\n\t} catch (error) {\n\t\tif (!signal.aborted) {\n\t\t\terrorOrAbortStream(stream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamEnd = async ({passThroughStream, stream, streams, ended, aborted, controller: {signal}}) => {\n\ttry {\n\t\tawait finished(stream, {\n\t\t\tsignal,\n\t\t\tcleanup: true,\n\t\t\treadable: true,\n\t\t\twritable: false,\n\t\t});\n\t\tif (streams.has(stream)) {\n\t\t\tended.add(stream);\n\t\t}\n\t} catch (error) {\n\t\tif (signal.aborted || !streams.has(stream)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (isAbortError(error)) {\n\t\t\taborted.add(stream);\n\t\t} else {\n\t\t\terrorStream(passThroughStream, error);\n\t\t}\n\t}\n};\n\nconst onInputStreamUnpipe = async ({stream, streams, ended, aborted, unpipeEvent, controller: {signal}}) => {\n\tawait once(stream, unpipeEvent, {signal});\n\n\tif (!stream.readable) {\n\t\treturn once(signal, 'abort', {signal});\n\t}\n\n\tstreams.delete(stream);\n\tended.delete(stream);\n\taborted.delete(stream);\n};\n\nconst endStream = stream => {\n\tif (stream.writable) {\n\t\tstream.end();\n\t}\n};\n\nconst errorOrAbortStream = (stream, error) => {\n\tif (isAbortError(error)) {\n\t\tabortStream(stream);\n\t} else {\n\t\terrorStream(stream, error);\n\t}\n};\n\n// This is the error thrown by `finished()` on `stream.destroy()`\nconst isAbortError = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\nconst abortStream = stream => {\n\tif (stream.readable || stream.writable) {\n\t\tstream.destroy();\n\t}\n};\n\n// `stream.destroy(error)` crashes the process with `uncaughtException` if no `error` event listener exists on `stream`.\n// We take care of error handling on user behalf, so we do not want this to happen.\nconst errorStream = (stream, error) => {\n\tif (!stream.destroyed) {\n\t\tstream.once('error', noop);\n\t\tstream.destroy(error);\n\t}\n};\n\nconst noop = () => {};\n\nconst updateMaxListeners = (passThroughStream, increment) => {\n\tconst maxListeners = passThroughStream.getMaxListeners();\n\tif (maxListeners !== 0 && maxListeners !== Number.POSITIVE_INFINITY) {\n\t\tpassThroughStream.setMaxListeners(maxListeners + increment);\n\t}\n};\n\n// Number of times `passThroughStream.on()` is called regardless of streams:\n//  - once due to `finished(passThroughStream)`\n//  - once due to `on(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_COUNT = 2;\n\n// Number of times `passThroughStream.on()` is called per stream:\n//  - once due to `stream.pipe(passThroughStream)`\nconst PASSTHROUGH_LISTENERS_PER_STREAM = 1;\n","import {addAbortListener} from 'node:events';\n\n// Temporarily increase the maximum number of listeners on an eventEmitter\nexport const incrementMaxListeners = (eventEmitter, maxListenersIncrement, signal) => {\n\tconst maxListeners = eventEmitter.getMaxListeners();\n\tif (maxListeners === 0 || maxListeners === Number.POSITIVE_INFINITY) {\n\t\treturn;\n\t}\n\n\teventEmitter.setMaxListeners(maxListeners + maxListenersIncrement);\n\taddAbortListener(signal, () => {\n\t\teventEmitter.setMaxListeners(eventEmitter.getMaxListeners() - maxListenersIncrement);\n\t});\n};\n","import {finished} from 'node:stream/promises';\nimport {isStandardStream} from '../utils/standard-stream.js';\n\n// Similar to `Stream.pipeline(source, destination)`, but does not destroy standard streams\nexport const pipeStreams = (source, destination) => {\n\tsource.pipe(destination);\n\tonSourceFinish(source, destination);\n\tonDestinationFinish(source, destination);\n};\n\n// `source.pipe(destination)` makes `destination` end when `source` ends.\n// But it does not propagate aborts or errors. This function does it.\nconst onSourceFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(source, {cleanup: true, readable: true, writable: false});\n\t} catch {}\n\n\tendDestinationStream(destination);\n};\n\nexport const endDestinationStream = destination => {\n\tif (destination.writable) {\n\t\tdestination.end();\n\t}\n};\n\n// We do the same thing in the other direction as well.\nconst onDestinationFinish = async (source, destination) => {\n\tif (isStandardStream(source) || isStandardStream(destination)) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait finished(destination, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tabortSourceStream(source);\n};\n\nexport const abortSourceStream = source => {\n\tif (source.readable) {\n\t\tsource.destroy();\n\t}\n};\n","import mergeStreams from '@sindresorhus/merge-streams';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {pipeStreams} from './pipeline.js';\n\n// Handle `input`, `inputFile`, `stdin`, `stdout` and `stderr` options, after spawning, in async mode\n// When multiple input streams are used, we merge them to ensure the output stream ends only once each input stream has ended\nexport const pipeOutputAsync = (subprocess, fileDescriptors, controller) => {\n\tconst pipeGroups = new Map();\n\n\tfor (const [fdNumber, {stdioItems, direction}] of Object.entries(fileDescriptors)) {\n\t\tfor (const {stream} of stdioItems.filter(({type}) => TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeTransform(subprocess, stream, direction, fdNumber);\n\t\t}\n\n\t\tfor (const {stream} of stdioItems.filter(({type}) => !TRANSFORM_TYPES.has(type))) {\n\t\t\tpipeStdioItem({\n\t\t\t\tsubprocess,\n\t\t\t\tstream,\n\t\t\t\tdirection,\n\t\t\t\tfdNumber,\n\t\t\t\tpipeGroups,\n\t\t\t\tcontroller,\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (const [outputStream, inputStreams] of pipeGroups.entries()) {\n\t\tconst inputStream = inputStreams.length === 1 ? inputStreams[0] : mergeStreams(inputStreams);\n\t\tpipeStreams(inputStream, outputStream);\n\t}\n};\n\n// When using transforms, `subprocess.stdin|stdout|stderr|stdio` is directly mutated\nconst pipeTransform = (subprocess, stream, direction, fdNumber) => {\n\tif (direction === 'output') {\n\t\tpipeStreams(subprocess.stdio[fdNumber], stream);\n\t} else {\n\t\tpipeStreams(stream, subprocess.stdio[fdNumber]);\n\t}\n\n\tconst streamProperty = SUBPROCESS_STREAM_PROPERTIES[fdNumber];\n\tif (streamProperty !== undefined) {\n\t\tsubprocess[streamProperty] = stream;\n\t}\n\n\tsubprocess.stdio[fdNumber] = stream;\n};\n\nconst SUBPROCESS_STREAM_PROPERTIES = ['stdin', 'stdout', 'stderr'];\n\n// Most `std*` option values involve piping `subprocess.std*` to a stream.\n// The stream is either passed by the user or created internally.\nconst pipeStdioItem = ({subprocess, stream, direction, fdNumber, pipeGroups, controller}) => {\n\tif (stream === undefined) {\n\t\treturn;\n\t}\n\n\tsetStandardStreamMaxListeners(stream, controller);\n\n\tconst [inputStream, outputStream] = direction === 'output'\n\t\t? [stream, subprocess.stdio[fdNumber]]\n\t\t: [subprocess.stdio[fdNumber], stream];\n\tconst outputStreams = pipeGroups.get(inputStream) ?? [];\n\tpipeGroups.set(inputStream, [...outputStreams, outputStream]);\n};\n\n// Multiple subprocesses might be piping from/to `process.std*` at the same time.\n// This is not necessarily an error and should not print a `maxListeners` warning.\nconst setStandardStreamMaxListeners = (stream, {signal}) => {\n\tif (isStandardStream(stream)) {\n\t\tincrementMaxListeners(stream, MAX_LISTENERS_INCREMENT, signal);\n\t}\n};\n\n// `source.pipe(destination)` adds at most 1 listener for each event.\n// If `stdin` option is an array, the values might be combined with `merge-streams`.\n// That library also listens for `source` end, which adds 1 more listener.\nconst MAX_LISTENERS_INCREMENT = 2;\n","/**\n * This is not the set of all possible signals.\n *\n * It IS, however, the set of all signals that trigger\n * an exit on either Linux or BSD systems.  Linux is a\n * superset of the signal names supported on BSD, and\n * the unknown signals just fail to register, so we can\n * catch that easily enough.\n *\n * Windows signals are a different set, since there are\n * signals that terminate Windows processes, but don't\n * terminate (or don't even exist) on Posix systems.\n *\n * Don't bother with SIGKILL.  It's uncatchable, which\n * means that we can't fire any callbacks anyway.\n *\n * If a user does happen to register a handler on a non-\n * fatal signal like SIGWINCH or something, and then\n * exit, it'll end up firing `process.emit('exit')`, so\n * the handler will be fired anyway.\n *\n * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n * artificially, inherently leave the process in a\n * state from which it is not safe to try and enter JS\n * listeners.\n */\nexport const signals = [];\nsignals.push('SIGHUP', 'SIGINT', 'SIGTERM');\nif (process.platform !== 'win32') {\n    signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n    );\n}\nif (process.platform === 'linux') {\n    signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');\n}\n//# sourceMappingURL=signals.js.map","// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nimport { signals } from './signals.js';\nexport { signals };\nconst processOk = (process) => !!process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function';\nconst kExitEmitter = Symbol.for('signal-exit emitter');\nconst global = globalThis;\nconst ObjectDefineProperty = Object.defineProperty.bind(Object);\n// teeny special purpose ee\nclass Emitter {\n    emitted = {\n        afterExit: false,\n        exit: false,\n    };\n    listeners = {\n        afterExit: [],\n        exit: [],\n    };\n    count = 0;\n    id = Math.random();\n    constructor() {\n        if (global[kExitEmitter]) {\n            return global[kExitEmitter];\n        }\n        ObjectDefineProperty(global, kExitEmitter, {\n            value: this,\n            writable: false,\n            enumerable: false,\n            configurable: false,\n        });\n    }\n    on(ev, fn) {\n        this.listeners[ev].push(fn);\n    }\n    removeListener(ev, fn) {\n        const list = this.listeners[ev];\n        const i = list.indexOf(fn);\n        /* c8 ignore start */\n        if (i === -1) {\n            return;\n        }\n        /* c8 ignore stop */\n        if (i === 0 && list.length === 1) {\n            list.length = 0;\n        }\n        else {\n            list.splice(i, 1);\n        }\n    }\n    emit(ev, code, signal) {\n        if (this.emitted[ev]) {\n            return false;\n        }\n        this.emitted[ev] = true;\n        let ret = false;\n        for (const fn of this.listeners[ev]) {\n            ret = fn(code, signal) === true || ret;\n        }\n        if (ev === 'exit') {\n            ret = this.emit('afterExit', code, signal) || ret;\n        }\n        return ret;\n    }\n}\nclass SignalExitBase {\n}\nconst signalExitWrap = (handler) => {\n    return {\n        onExit(cb, opts) {\n            return handler.onExit(cb, opts);\n        },\n        load() {\n            return handler.load();\n        },\n        unload() {\n            return handler.unload();\n        },\n    };\n};\nclass SignalExitFallback extends SignalExitBase {\n    onExit() {\n        return () => { };\n    }\n    load() { }\n    unload() { }\n}\nclass SignalExit extends SignalExitBase {\n    // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n    // so use a supported signal instead\n    /* c8 ignore start */\n    #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP';\n    /* c8 ignore stop */\n    #emitter = new Emitter();\n    #process;\n    #originalProcessEmit;\n    #originalProcessReallyExit;\n    #sigListeners = {};\n    #loaded = false;\n    constructor(process) {\n        super();\n        this.#process = process;\n        // { <signal>: <listener fn>, ... }\n        this.#sigListeners = {};\n        for (const sig of signals) {\n            this.#sigListeners[sig] = () => {\n                // If there are no other listeners, an exit is coming!\n                // Simplest way: remove us and then re-send the signal.\n                // We know that this will kill the process, so we can\n                // safely emit now.\n                const listeners = this.#process.listeners(sig);\n                let { count } = this.#emitter;\n                // This is a workaround for the fact that signal-exit v3 and signal\n                // exit v4 are not aware of each other, and each will attempt to let\n                // the other handle it, so neither of them do. To correct this, we\n                // detect if we're the only handler *except* for previous versions\n                // of signal-exit, and increment by the count of listeners it has\n                // created.\n                /* c8 ignore start */\n                const p = process;\n                if (typeof p.__signal_exit_emitter__ === 'object' &&\n                    typeof p.__signal_exit_emitter__.count === 'number') {\n                    count += p.__signal_exit_emitter__.count;\n                }\n                /* c8 ignore stop */\n                if (listeners.length === count) {\n                    this.unload();\n                    const ret = this.#emitter.emit('exit', null, sig);\n                    /* c8 ignore start */\n                    const s = sig === 'SIGHUP' ? this.#hupSig : sig;\n                    if (!ret)\n                        process.kill(process.pid, s);\n                    /* c8 ignore stop */\n                }\n            };\n        }\n        this.#originalProcessReallyExit = process.reallyExit;\n        this.#originalProcessEmit = process.emit;\n    }\n    onExit(cb, opts) {\n        /* c8 ignore start */\n        if (!processOk(this.#process)) {\n            return () => { };\n        }\n        /* c8 ignore stop */\n        if (this.#loaded === false) {\n            this.load();\n        }\n        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';\n        this.#emitter.on(ev, cb);\n        return () => {\n            this.#emitter.removeListener(ev, cb);\n            if (this.#emitter.listeners['exit'].length === 0 &&\n                this.#emitter.listeners['afterExit'].length === 0) {\n                this.unload();\n            }\n        };\n    }\n    load() {\n        if (this.#loaded) {\n            return;\n        }\n        this.#loaded = true;\n        // This is the number of onSignalExit's that are in play.\n        // It's important so that we can count the correct number of\n        // listeners on signals, and don't wait for the other one to\n        // handle it instead of us.\n        this.#emitter.count += 1;\n        for (const sig of signals) {\n            try {\n                const fn = this.#sigListeners[sig];\n                if (fn)\n                    this.#process.on(sig, fn);\n            }\n            catch (_) { }\n        }\n        this.#process.emit = (ev, ...a) => {\n            return this.#processEmit(ev, ...a);\n        };\n        this.#process.reallyExit = (code) => {\n            return this.#processReallyExit(code);\n        };\n    }\n    unload() {\n        if (!this.#loaded) {\n            return;\n        }\n        this.#loaded = false;\n        signals.forEach(sig => {\n            const listener = this.#sigListeners[sig];\n            /* c8 ignore start */\n            if (!listener) {\n                throw new Error('Listener not defined for signal: ' + sig);\n            }\n            /* c8 ignore stop */\n            try {\n                this.#process.removeListener(sig, listener);\n                /* c8 ignore start */\n            }\n            catch (_) { }\n            /* c8 ignore stop */\n        });\n        this.#process.emit = this.#originalProcessEmit;\n        this.#process.reallyExit = this.#originalProcessReallyExit;\n        this.#emitter.count -= 1;\n    }\n    #processReallyExit(code) {\n        /* c8 ignore start */\n        if (!processOk(this.#process)) {\n            return 0;\n        }\n        this.#process.exitCode = code || 0;\n        /* c8 ignore stop */\n        this.#emitter.emit('exit', this.#process.exitCode, null);\n        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);\n    }\n    #processEmit(ev, ...args) {\n        const og = this.#originalProcessEmit;\n        if (ev === 'exit' && processOk(this.#process)) {\n            if (typeof args[0] === 'number') {\n                this.#process.exitCode = args[0];\n                /* c8 ignore start */\n            }\n            /* c8 ignore start */\n            const ret = og.call(this.#process, ev, ...args);\n            /* c8 ignore start */\n            this.#emitter.emit('exit', this.#process.exitCode, null);\n            /* c8 ignore stop */\n            return ret;\n        }\n        else {\n            return og.call(this.#process, ev, ...args);\n        }\n    }\n}\nconst process = globalThis.process;\n// wrap so that we call the method on the actual handler, without\n// exporting it directly.\nexport const { \n/**\n * Called when the process is exiting, whether via signal, explicit\n * exit, or running out of stuff to do.\n *\n * If the global process object is not suitable for instrumentation,\n * then this will be a no-op.\n *\n * Returns a function that may be used to unload signal-exit.\n */\nonExit, \n/**\n * Load the listeners.  Likely you never need to call this, unless\n * doing a rather deep integration with signal-exit functionality.\n * Mostly exposed for the benefit of testing.\n *\n * @internal\n */\nload, \n/**\n * Unload the listeners.  Likely you never need to call this, unless\n * doing a rather deep integration with signal-exit functionality.\n * Mostly exposed for the benefit of testing.\n *\n * @internal\n */\nunload, } = signalExitWrap(processOk(process) ? new SignalExit(process) : new SignalExitFallback());\n//# sourceMappingURL=index.js.map","import {addAbortListener} from 'node:events';\nimport {onExit} from 'signal-exit';\n\n// If the `cleanup` option is used, call `subprocess.kill()` when the parent process exits\nexport const cleanupOnExit = (subprocess, {cleanup, detached}, {signal}) => {\n\tif (!cleanup || detached) {\n\t\treturn;\n\t}\n\n\tconst removeExitHandler = onExit(() => {\n\t\tsubprocess.kill();\n\t});\n\taddAbortListener(signal, () => {\n\t\tremoveExitHandler();\n\t});\n};\n","import {normalizeParameters} from '../methods/parameters.js';\nimport {getStartTime} from '../return/duration.js';\nimport {SUBPROCESS_OPTIONS, getToStream, getFromStream} from '../arguments/fd-options.js';\n\n// Normalize and validate arguments passed to `source.pipe(destination)`\nexport const normalizePipeArguments = ({source, sourcePromise, boundOptions, createNested}, ...pipeArguments) => {\n\tconst startTime = getStartTime();\n\tconst {\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfrom,\n\t\tunpipeSignal,\n\t} = getDestinationStream(boundOptions, createNested, pipeArguments);\n\tconst {sourceStream, sourceError} = getSourceStream(source, from);\n\tconst {options: sourceOptions, fileDescriptors} = SUBPROCESS_OPTIONS.get(source);\n\treturn {\n\t\tsourcePromise,\n\t\tsourceStream,\n\t\tsourceOptions,\n\t\tsourceError,\n\t\tdestination,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tunpipeSignal,\n\t\tfileDescriptors,\n\t\tstartTime,\n\t};\n};\n\nconst getDestinationStream = (boundOptions, createNested, pipeArguments) => {\n\ttry {\n\t\tconst {\n\t\t\tdestination,\n\t\t\tpipeOptions: {from, to, unpipeSignal} = {},\n\t\t} = getDestination(boundOptions, createNested, ...pipeArguments);\n\t\tconst destinationStream = getToStream(destination, to);\n\t\treturn {\n\t\t\tdestination,\n\t\t\tdestinationStream,\n\t\t\tfrom,\n\t\t\tunpipeSignal,\n\t\t};\n\t} catch (error) {\n\t\treturn {destinationError: error};\n\t}\n};\n\n// Piping subprocesses can use three syntaxes:\n//  - source.pipe('command', commandArguments, pipeOptionsOrDestinationOptions)\n//  - source.pipe`command commandArgument` or source.pipe(pipeOptionsOrDestinationOptions)`command commandArgument`\n//  - source.pipe(execa(...), pipeOptions)\nconst getDestination = (boundOptions, createNested, firstArgument, ...pipeArguments) => {\n\tif (Array.isArray(firstArgument)) {\n\t\tconst destination = createNested(mapDestinationArguments, boundOptions)(firstArgument, ...pipeArguments);\n\t\treturn {destination, pipeOptions: boundOptions};\n\t}\n\n\tif (typeof firstArgument === 'string' || firstArgument instanceof URL) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(\"file\", ..., options) or .pipe(execa(\"file\", ..., options)) instead of .pipe(options)(\"file\", ...).');\n\t\t}\n\n\t\tconst [rawFile, rawArguments, rawOptions] = normalizeParameters(firstArgument, ...pipeArguments);\n\t\tconst destination = createNested(mapDestinationArguments)(rawFile, rawArguments, rawOptions);\n\t\treturn {destination, pipeOptions: rawOptions};\n\t}\n\n\tif (SUBPROCESS_OPTIONS.has(firstArgument)) {\n\t\tif (Object.keys(boundOptions).length > 0) {\n\t\t\tthrow new TypeError('Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).');\n\t\t}\n\n\t\treturn {destination: firstArgument, pipeOptions: pipeArguments[0]};\n\t}\n\n\tthrow new TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${firstArgument}`);\n};\n\n// Force `stdin: 'pipe'` with the destination subprocess\nconst mapDestinationArguments = ({options}) => ({options: {...options, stdin: 'pipe', piped: true}});\n\nconst getSourceStream = (source, from) => {\n\ttry {\n\t\tconst sourceStream = getFromStream(source, from);\n\t\treturn {sourceStream};\n\t} catch (error) {\n\t\treturn {sourceError: error};\n\t}\n};\n","import {makeEarlyError} from '../return/result.js';\nimport {abortSourceStream, endDestinationStream} from '../io/pipeline.js';\n\n// When passing invalid arguments to `source.pipe()`, throw asynchronously.\n// We also abort both subprocesses.\nexport const handlePipeArgumentsError = ({\n\tsourceStream,\n\tsourceError,\n\tdestinationStream,\n\tdestinationError,\n\tfileDescriptors,\n\tsourceOptions,\n\tstartTime,\n}) => {\n\tconst error = getPipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t});\n\tif (error !== undefined) {\n\t\tthrow createNonCommandError({\n\t\t\terror,\n\t\t\tfileDescriptors,\n\t\t\tsourceOptions,\n\t\t\tstartTime,\n\t\t});\n\t}\n};\n\nconst getPipeArgumentsError = ({sourceStream, sourceError, destinationStream, destinationError}) => {\n\tif (sourceError !== undefined && destinationError !== undefined) {\n\t\treturn destinationError;\n\t}\n\n\tif (destinationError !== undefined) {\n\t\tabortSourceStream(sourceStream);\n\t\treturn destinationError;\n\t}\n\n\tif (sourceError !== undefined) {\n\t\tendDestinationStream(destinationStream);\n\t\treturn sourceError;\n\t}\n};\n\n// Specific error return value when passing invalid arguments to `subprocess.pipe()` or when using `unpipeSignal`\nexport const createNonCommandError = ({error, fileDescriptors, sourceOptions, startTime}) => makeEarlyError({\n\terror,\n\tcommand: PIPE_COMMAND_MESSAGE,\n\tescapedCommand: PIPE_COMMAND_MESSAGE,\n\tfileDescriptors,\n\toptions: sourceOptions,\n\tstartTime,\n\tisSync: false,\n});\n\nconst PIPE_COMMAND_MESSAGE = 'source.pipe(destination)';\n","// Like Bash, we await both subprocesses. This is unlike some other shells which only await the destination subprocess.\n// Like Bash with the `pipefail` option, if either subprocess fails, the whole pipe fails.\n// Like Bash, if both subprocesses fail, we return the failure of the destination.\n// This ensures both subprocesses' errors are present, using `error.pipedFrom`.\nexport const waitForBothSubprocesses = async subprocessPromises => {\n\tconst [\n\t\t{status: sourceStatus, reason: sourceReason, value: sourceResult = sourceReason},\n\t\t{status: destinationStatus, reason: destinationReason, value: destinationResult = destinationReason},\n\t] = await subprocessPromises;\n\n\tif (!destinationResult.pipedFrom.includes(sourceResult)) {\n\t\tdestinationResult.pipedFrom.push(sourceResult);\n\t}\n\n\tif (destinationStatus === 'rejected') {\n\t\tthrow destinationResult;\n\t}\n\n\tif (sourceStatus === 'rejected') {\n\t\tthrow sourceResult;\n\t}\n\n\treturn destinationResult;\n};\n","import {finished} from 'node:stream/promises';\nimport mergeStreams from '@sindresorhus/merge-streams';\nimport {incrementMaxListeners} from '../utils/max-listeners.js';\nimport {pipeStreams} from '../io/pipeline.js';\n\n// The piping behavior is like Bash.\n// In particular, when one subprocess exits, the other is not terminated by a signal.\n// Instead, its stdout (for the source) or stdin (for the destination) closes.\n// If the subprocess uses it, it will make it error with SIGPIPE or EPIPE (for the source) or end (for the destination).\n// If it does not use it, it will continue running.\n// This allows for subprocesses to gracefully exit and lower the coupling between subprocesses.\nexport const pipeSubprocessStream = (sourceStream, destinationStream, maxListenersController) => {\n\tconst mergedStream = MERGED_STREAMS.has(destinationStream)\n\t\t? pipeMoreSubprocessStream(sourceStream, destinationStream)\n\t\t: pipeFirstSubprocessStream(sourceStream, destinationStream);\n\tincrementMaxListeners(sourceStream, SOURCE_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tincrementMaxListeners(destinationStream, DESTINATION_LISTENERS_PER_PIPE, maxListenersController.signal);\n\tcleanupMergedStreamsMap(destinationStream);\n\treturn mergedStream;\n};\n\n// We use `merge-streams` to allow for multiple sources to pipe to the same destination.\nconst pipeFirstSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = mergeStreams([sourceStream]);\n\tpipeStreams(mergedStream, destinationStream);\n\tMERGED_STREAMS.set(destinationStream, mergedStream);\n\treturn mergedStream;\n};\n\nconst pipeMoreSubprocessStream = (sourceStream, destinationStream) => {\n\tconst mergedStream = MERGED_STREAMS.get(destinationStream);\n\tmergedStream.add(sourceStream);\n\treturn mergedStream;\n};\n\nconst cleanupMergedStreamsMap = async destinationStream => {\n\ttry {\n\t\tawait finished(destinationStream, {cleanup: true, readable: false, writable: true});\n\t} catch {}\n\n\tMERGED_STREAMS.delete(destinationStream);\n};\n\nconst MERGED_STREAMS = new WeakMap();\n\n// Number of listeners set up on `sourceStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `merge-streams`\nconst SOURCE_LISTENERS_PER_PIPE = 2;\n// Number of listeners set up on `destinationStream` by each `sourceStream.pipe(destinationStream)`\n// Those are added by `finished()` in `cleanupMergedStreamsMap()`\nconst DESTINATION_LISTENERS_PER_PIPE = 1;\n","import {aborted} from 'node:util';\nimport {createNonCommandError} from './throw.js';\n\n// When passing an `unpipeSignal` option, abort piping when the signal is aborted.\n// However, do not terminate the subprocesses.\nexport const unpipeOnAbort = (unpipeSignal, unpipeContext) => unpipeSignal === undefined\n\t? []\n\t: [unpipeOnSignalAbort(unpipeSignal, unpipeContext)];\n\nconst unpipeOnSignalAbort = async (unpipeSignal, {sourceStream, mergedStream, fileDescriptors, sourceOptions, startTime}) => {\n\tawait aborted(unpipeSignal, sourceStream);\n\tawait mergedStream.remove(sourceStream);\n\tconst error = new Error('Pipe canceled by `unpipeSignal` option.');\n\tthrow createNonCommandError({\n\t\terror,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n};\n","import isPlainObject from 'is-plain-obj';\nimport {normalizePipeArguments} from './pipe-arguments.js';\nimport {handlePipeArgumentsError} from './throw.js';\nimport {waitForBothSubprocesses} from './sequence.js';\nimport {pipeSubprocessStream} from './streaming.js';\nimport {unpipeOnAbort} from './abort.js';\n\n// Pipe a subprocess' `stdout`/`stderr`/`stdio` into another subprocess' `stdin`\nexport const pipeToSubprocess = (sourceInfo, ...pipeArguments) => {\n\tif (isPlainObject(pipeArguments[0])) {\n\t\treturn pipeToSubprocess.bind(undefined, {\n\t\t\t...sourceInfo,\n\t\t\tboundOptions: {...sourceInfo.boundOptions, ...pipeArguments[0]},\n\t\t});\n\t}\n\n\tconst {destination, ...normalizedInfo} = normalizePipeArguments(sourceInfo, ...pipeArguments);\n\tconst promise = handlePipePromise({...normalizedInfo, destination});\n\tpromise.pipe = pipeToSubprocess.bind(undefined, {\n\t\t...sourceInfo,\n\t\tsource: destination,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t});\n\treturn promise;\n};\n\n// Asynchronous logic when piping subprocesses\nconst handlePipePromise = async ({\n\tsourcePromise,\n\tsourceStream,\n\tsourceOptions,\n\tsourceError,\n\tdestination,\n\tdestinationStream,\n\tdestinationError,\n\tunpipeSignal,\n\tfileDescriptors,\n\tstartTime,\n}) => {\n\tconst subprocessPromises = getSubprocessPromises(sourcePromise, destination);\n\thandlePipeArgumentsError({\n\t\tsourceStream,\n\t\tsourceError,\n\t\tdestinationStream,\n\t\tdestinationError,\n\t\tfileDescriptors,\n\t\tsourceOptions,\n\t\tstartTime,\n\t});\n\tconst maxListenersController = new AbortController();\n\ttry {\n\t\tconst mergedStream = pipeSubprocessStream(sourceStream, destinationStream, maxListenersController);\n\t\treturn await Promise.race([\n\t\t\twaitForBothSubprocesses(subprocessPromises),\n\t\t\t...unpipeOnAbort(unpipeSignal, {\n\t\t\t\tsourceStream,\n\t\t\t\tmergedStream,\n\t\t\t\tsourceOptions,\n\t\t\t\tfileDescriptors,\n\t\t\t\tstartTime,\n\t\t\t}),\n\t\t]);\n\t} finally {\n\t\tmaxListenersController.abort();\n\t}\n};\n\n// `.pipe()` awaits the subprocess promises.\n// When invalid arguments are passed to `.pipe()`, we throw an error, which prevents awaiting them.\n// We need to ensure this does not create unhandled rejections.\nconst getSubprocessPromises = (sourcePromise, destination) => Promise.allSettled([sourcePromise, destination]);\n","export const identity = value => value;\n\nexport const noop = () => undefined;\n\nexport const getContentsProperty = ({contents}) => contents;\n\nexport const throwObjectStream = chunk => {\n\tthrow new Error(`Streams in object mode are not supported: ${String(chunk)}`);\n};\n\nexport const getLengthProperty = convertedChunk => convertedChunk.length;\n","import {getStreamContents} from './contents.js';\nimport {identity, noop, getContentsProperty} from './utils.js';\n\nexport async function getStreamAsArray(stream, options) {\n\treturn getStreamContents(stream, arrayMethods, options);\n}\n\nconst initArray = () => ({contents: []});\n\nconst increment = () => 1;\n\nconst addArrayChunk = (convertedChunk, {contents}) => {\n\tcontents.push(convertedChunk);\n\treturn contents;\n};\n\nconst arrayMethods = {\n\tinit: initArray,\n\tconvertChunk: {\n\t\tstring: identity,\n\t\tbuffer: identity,\n\t\tarrayBuffer: identity,\n\t\tdataView: identity,\n\t\ttypedArray: identity,\n\t\tothers: identity,\n\t},\n\tgetSize: increment,\n\ttruncateChunk: noop,\n\taddChunk: addArrayChunk,\n\tgetFinalChunk: noop,\n\tfinalize: getContentsProperty,\n};\n","import {getStreamContents} from './contents.js';\nimport {noop, throwObjectStream, getLengthProperty} from './utils.js';\n\nexport async function getStreamAsArrayBuffer(stream, options) {\n\treturn getStreamContents(stream, arrayBufferMethods, options);\n}\n\nconst initArrayBuffer = () => ({contents: new ArrayBuffer(0)});\n\nconst useTextEncoder = chunk => textEncoder.encode(chunk);\nconst textEncoder = new TextEncoder();\n\nconst useUint8Array = chunk => new Uint8Array(chunk);\n\nconst useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n\nconst truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\n// `contents` is an increasingly growing `Uint8Array`.\nconst addArrayBufferChunk = (convertedChunk, {contents, length: previousLength}, length) => {\n\tconst newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);\n\tnew Uint8Array(newContents).set(convertedChunk, previousLength);\n\treturn newContents;\n};\n\n// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.\n// This means its last bytes are zeroes (not stream data), which need to be\n// trimmed at the end with `ArrayBuffer.slice()`.\nconst resizeArrayBufferSlow = (contents, length) => {\n\tif (length <= contents.byteLength) {\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(getNewContentsLength(length));\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of\n// the stream data. It does not include extraneous zeroes to trim at the end.\n// The underlying `ArrayBuffer` does allocate a number of bytes that is a power\n// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.\nconst resizeArrayBuffer = (contents, length) => {\n\tif (length <= contents.maxByteLength) {\n\t\tcontents.resize(length);\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(length, {maxByteLength: getNewContentsLength(length)});\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// Retrieve the closest `length` that is both >= and a power of 2\nconst getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));\n\nconst SCALE_FACTOR = 2;\n\nconst finalizeArrayBuffer = ({contents, length}) => hasArrayBufferResize() ? contents : contents.slice(0, length);\n\n// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available\n// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.\n// eslint-disable-next-line no-warning-comments\n// TODO: remove after dropping support for Node 20.\n// eslint-disable-next-line no-warning-comments\n// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available\nconst hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;\n\nconst arrayBufferMethods = {\n\tinit: initArrayBuffer,\n\tconvertChunk: {\n\t\tstring: useTextEncoder,\n\t\tbuffer: useUint8Array,\n\t\tarrayBuffer: useUint8Array,\n\t\tdataView: useUint8ArrayWithOffset,\n\t\ttypedArray: useUint8ArrayWithOffset,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProperty,\n\ttruncateChunk: truncateArrayBufferChunk,\n\taddChunk: addArrayBufferChunk,\n\tgetFinalChunk: noop,\n\tfinalize: finalizeArrayBuffer,\n};\n","import {getStreamContents} from './contents.js';\nimport {\n\tidentity,\n\tgetContentsProperty,\n\tthrowObjectStream,\n\tgetLengthProperty,\n} from './utils.js';\n\nexport async function getStreamAsString(stream, options) {\n\treturn getStreamContents(stream, stringMethods, options);\n}\n\nconst initString = () => ({contents: '', textDecoder: new TextDecoder()});\n\nconst useTextDecoder = (chunk, {textDecoder}) => textDecoder.decode(chunk, {stream: true});\n\nconst addStringChunk = (convertedChunk, {contents}) => contents + convertedChunk;\n\nconst truncateStringChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\nconst getFinalStringChunk = ({textDecoder}) => {\n\tconst finalChunk = textDecoder.decode();\n\treturn finalChunk === '' ? undefined : finalChunk;\n};\n\nconst stringMethods = {\n\tinit: initString,\n\tconvertChunk: {\n\t\tstring: identity,\n\t\tbuffer: useTextDecoder,\n\t\tarrayBuffer: useTextDecoder,\n\t\tdataView: useTextDecoder,\n\t\ttypedArray: useTextDecoder,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProperty,\n\ttruncateChunk: truncateStringChunk,\n\taddChunk: addStringChunk,\n\tgetFinalChunk: getFinalStringChunk,\n\tfinalize: getContentsProperty,\n};\n","import {on} from 'node:events';\nimport {getDefaultHighWaterMark} from 'node:stream';\nimport {getEncodingTransformGenerator} from '../transform/encoding-transform.js';\nimport {getSplitLinesGenerator} from '../transform/split.js';\nimport {transformChunkSync, finalChunksSync} from '../transform/run-sync.js';\n\n// Iterate over lines of `subprocess.stdout`, used by `subprocess.readable|duplex|iterable()`\nexport const iterateOnSubprocessStream = ({subprocessStdout, subprocess, binary, shouldEncode, encoding, preserveNewlines}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnExit(subprocess, controller);\n\treturn iterateOnStream({\n\t\tstream: subprocessStdout,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode: !subprocessStdout.readableObjectMode && shouldEncode,\n\t\tencoding,\n\t\tshouldSplit: !subprocessStdout.readableObjectMode,\n\t\tpreserveNewlines,\n\t});\n};\n\nconst stopReadingOnExit = async (subprocess, controller) => {\n\ttry {\n\t\tawait subprocess;\n\t} catch {} finally {\n\t\tcontroller.abort();\n\t}\n};\n\n// Iterate over lines of `subprocess.stdout`, used by `result.stdout` and the `verbose: 'full'` option.\n// Applies the `lines` and `encoding` options.\nexport const iterateForResult = ({stream, onStreamEnd, lines, encoding, stripFinalNewline, allMixed}) => {\n\tconst controller = new AbortController();\n\tstopReadingOnStreamEnd(onStreamEnd, controller, stream);\n\tconst objectMode = stream.readableObjectMode && !allMixed;\n\treturn iterateOnStream({\n\t\tstream,\n\t\tcontroller,\n\t\tbinary: encoding === 'buffer',\n\t\tshouldEncode: !objectMode,\n\t\tencoding,\n\t\tshouldSplit: !objectMode && lines,\n\t\tpreserveNewlines: !stripFinalNewline,\n\t});\n};\n\nconst stopReadingOnStreamEnd = async (onStreamEnd, controller, stream) => {\n\ttry {\n\t\tawait onStreamEnd;\n\t} catch {\n\t\tstream.destroy();\n\t} finally {\n\t\tcontroller.abort();\n\t}\n};\n\nconst iterateOnStream = ({stream, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => {\n\tconst onStdoutChunk = on(stream, 'data', {\n\t\tsignal: controller.signal,\n\t\thighWaterMark: HIGH_WATER_MARK,\n\t\t// Backward compatibility with older name for this option\n\t\t// See https://github.com/nodejs/node/pull/52080#discussion_r1525227861\n\t\t// @todo Remove after removing support for Node 21\n\t\thighWatermark: HIGH_WATER_MARK,\n\t});\n\treturn iterateOnData({\n\t\tonStdoutChunk,\n\t\tcontroller,\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n};\n\nexport const DEFAULT_OBJECT_HIGH_WATER_MARK = getDefaultHighWaterMark(true);\n\n// The `highWaterMark` of `events.on()` is measured in number of events, not in bytes.\n// Not knowing the average amount of bytes per `data` event, we use the same heuristic as streams in objectMode, since they have the same issue.\n// Therefore, we use the value of `getDefaultHighWaterMark(true)`.\n// Note: this option does not exist on Node 18, but this is ok since the logic works without it. It just consumes more memory.\nconst HIGH_WATER_MARK = DEFAULT_OBJECT_HIGH_WATER_MARK;\n\nconst iterateOnData = async function * ({onStdoutChunk, controller, binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) {\n\tconst generators = getGenerators({\n\t\tbinary,\n\t\tshouldEncode,\n\t\tencoding,\n\t\tshouldSplit,\n\t\tpreserveNewlines,\n\t});\n\n\ttry {\n\t\tfor await (const [chunk] of onStdoutChunk) {\n\t\t\tyield * transformChunkSync(chunk, generators, 0);\n\t\t}\n\t} catch (error) {\n\t\tif (!controller.signal.aborted) {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tyield * finalChunksSync(generators);\n\t}\n};\n\nconst getGenerators = ({binary, shouldEncode, encoding, shouldSplit, preserveNewlines}) => [\n\tgetEncodingTransformGenerator(binary, encoding, !shouldEncode),\n\tgetSplitLinesGenerator(binary, preserveNewlines, !shouldSplit, {}),\n].filter(Boolean);\n","import {setImmediate} from 'node:timers/promises';\nimport getStream, {getStreamAsArrayBuffer, getStreamAsArray} from 'get-stream';\nimport {isArrayBuffer} from '../utils/uint-array.js';\nimport {shouldLogOutput, logLines} from '../verbose/output.js';\nimport {iterateForResult} from './iterate.js';\nimport {handleMaxBuffer} from './max-buffer.js';\nimport {getStripFinalNewline} from './strip-newline.js';\n\n// Retrieve `result.stdout|stderr|all|stdio[*]`\nexport const getStreamOutput = async ({stream, onStreamEnd, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo: {fileDescriptors}}) => {\n\tif (shouldLogOutput({\n\t\tstdioItems: fileDescriptors[fdNumber]?.stdioItems,\n\t\tencoding,\n\t\tverboseInfo,\n\t\tfdNumber,\n\t})) {\n\t\tconst linesIterable = iterateForResult({\n\t\t\tstream,\n\t\t\tonStreamEnd,\n\t\t\tlines: true,\n\t\t\tencoding,\n\t\t\tstripFinalNewline: true,\n\t\t\tallMixed,\n\t\t});\n\t\tlogLines(linesIterable, stream, verboseInfo);\n\t}\n\n\tif (!buffer) {\n\t\tawait resumeStream(stream);\n\t\treturn;\n\t}\n\n\tconst stripFinalNewlineValue = getStripFinalNewline(stripFinalNewline, fdNumber);\n\tconst iterable = iterateForResult({\n\t\tstream,\n\t\tonStreamEnd,\n\t\tlines,\n\t\tencoding,\n\t\tstripFinalNewline: stripFinalNewlineValue,\n\t\tallMixed,\n\t});\n\treturn getStreamContents({\n\t\tstream,\n\t\titerable,\n\t\tfdNumber,\n\t\tencoding,\n\t\tmaxBuffer,\n\t\tlines,\n\t});\n};\n\n// When using `buffer: false`, users need to read `subprocess.stdout|stderr|all` right away\n// See https://github.com/sindresorhus/execa/issues/730 and https://github.com/sindresorhus/execa/pull/729#discussion_r1465496310\nconst resumeStream = async stream => {\n\tawait setImmediate();\n\tif (stream.readableFlowing === null) {\n\t\tstream.resume();\n\t}\n};\n\nconst getStreamContents = async ({stream, stream: {readableObjectMode}, iterable, fdNumber, encoding, maxBuffer, lines}) => {\n\ttry {\n\t\tif (readableObjectMode || lines) {\n\t\t\treturn await getStreamAsArray(iterable, {maxBuffer});\n\t\t}\n\n\t\tif (encoding === 'buffer') {\n\t\t\treturn new Uint8Array(await getStreamAsArrayBuffer(iterable, {maxBuffer}));\n\t\t}\n\n\t\treturn await getStream(iterable, {maxBuffer});\n\t} catch (error) {\n\t\treturn handleBufferedData(handleMaxBuffer({\n\t\t\terror,\n\t\t\tstream,\n\t\t\treadableObjectMode,\n\t\t\tlines,\n\t\t\tencoding,\n\t\t\tfdNumber,\n\t\t}));\n\t}\n};\n\n// On failure, `result.stdout|stderr|all` should contain the currently buffered stream\n// They are automatically closed and flushed by Node.js when the subprocess exits\n// When `buffer` is `false`, `streamPromise` is `undefined` and there is no buffered data to retrieve\nexport const getBufferedData = async streamPromise => {\n\ttry {\n\t\treturn await streamPromise;\n\t} catch (error) {\n\t\treturn handleBufferedData(error);\n\t}\n};\n\n// Ensure we are returning Uint8Arrays when using `encoding: 'buffer'`\nconst handleBufferedData = ({bufferedData}) => isArrayBuffer(bufferedData)\n\t? new Uint8Array(bufferedData)\n\t: bufferedData;\n","import {finished} from 'node:stream/promises';\n\n// Wraps `finished(stream)` to handle the following case:\n//  - When the subprocess exits, Node.js automatically calls `subprocess.stdin.destroy()`, which we need to ignore.\n//  - However, we still need to throw if `subprocess.stdin.destroy()` is called before subprocess exit.\nexport const waitForStream = async (stream, fdNumber, streamInfo, {isSameDirection, stopOnExit = false} = {}) => {\n\tconst state = handleStdinDestroy(stream, streamInfo);\n\tconst abortController = new AbortController();\n\ttry {\n\t\tawait Promise.race([\n\t\t\t...(stopOnExit ? [streamInfo.exitPromise] : []),\n\t\t\tfinished(stream, {cleanup: true, signal: abortController.signal}),\n\t\t]);\n\t} catch (error) {\n\t\tif (!state.stdinCleanedUp) {\n\t\t\thandleStreamError(error, fdNumber, streamInfo, isSameDirection);\n\t\t}\n\t} finally {\n\t\tabortController.abort();\n\t}\n};\n\n// If `subprocess.stdin` is destroyed before being fully written to, it is considered aborted and should throw an error.\n// This can happen for example when user called `subprocess.stdin.destroy()` before `subprocess.stdin.end()`.\n// However, Node.js calls `subprocess.stdin.destroy()` on exit for cleanup purposes.\n// https://github.com/nodejs/node/blob/0b4cdb4b42956cbd7019058e409e06700a199e11/lib/internal/child_process.js#L278\n// This is normal and should not throw an error.\n// Therefore, we need to differentiate between both situations to know whether to throw an error.\n// Unfortunately, events (`close`, `error`, `end`, `exit`) cannot be used because `.destroy()` can take an arbitrary amount of time.\n// For example, `stdin: 'pipe'` is implemented as a TCP socket, and its `.destroy()` method waits for TCP disconnection.\n// Therefore `.destroy()` might end before or after subprocess exit, based on OS speed and load.\n// The only way to detect this is to spy on `subprocess.stdin._destroy()` by wrapping it.\n// If `subprocess.exitCode` or `subprocess.signalCode` is set, it means `.destroy()` is being called by Node.js itself.\nconst handleStdinDestroy = (stream, {originalStreams: [originalStdin], subprocess}) => {\n\tconst state = {stdinCleanedUp: false};\n\tif (stream === originalStdin) {\n\t\tspyOnStdinDestroy(stream, subprocess, state);\n\t}\n\n\treturn state;\n};\n\nconst spyOnStdinDestroy = (subprocessStdin, subprocess, state) => {\n\tconst {_destroy} = subprocessStdin;\n\tsubprocessStdin._destroy = (...destroyArguments) => {\n\t\tsetStdinCleanedUp(subprocess, state);\n\t\t_destroy.call(subprocessStdin, ...destroyArguments);\n\t};\n};\n\nconst setStdinCleanedUp = ({exitCode, signalCode}, state) => {\n\tif (exitCode !== null || signalCode !== null) {\n\t\tstate.stdinCleanedUp = true;\n\t}\n};\n\n// We ignore EPIPEs on writable streams and aborts on readable streams since those can happen normally.\n// When one stream errors, the error is propagated to the other streams on the same file descriptor.\n// Those other streams might have a different direction due to the above.\n// When this happens, the direction of both the initial stream and the others should then be taken into account.\n// Therefore, we keep track of whether a stream error is currently propagating.\nconst handleStreamError = (error, fdNumber, streamInfo, isSameDirection) => {\n\tif (!shouldIgnoreStreamError(error, fdNumber, streamInfo, isSameDirection)) {\n\t\tthrow error;\n\t}\n};\n\nconst shouldIgnoreStreamError = (error, fdNumber, streamInfo, isSameDirection = true) => {\n\tif (streamInfo.propagating) {\n\t\treturn isStreamEpipe(error) || isStreamAbort(error);\n\t}\n\n\tstreamInfo.propagating = true;\n\treturn isInputFileDescriptor(streamInfo, fdNumber) === isSameDirection\n\t\t? isStreamEpipe(error)\n\t\t: isStreamAbort(error);\n};\n\n// Unfortunately, we cannot use the stream's class or properties to know whether it is readable or writable.\n// For example, `subprocess.stdin` is technically a Duplex, but can only be used as a writable.\n// Therefore, we need to use the file descriptor's direction (`stdin` is input, `stdout` is output, etc.).\n// However, while `subprocess.std*` and transforms follow that direction, any stream passed the `std*` option has the opposite direction.\n// For example, `subprocess.stdin` is a writable, but the `stdin` option is a readable.\nexport const isInputFileDescriptor = ({fileDescriptors}, fdNumber) => fdNumber !== 'all' && fileDescriptors[fdNumber].direction === 'input';\n\n// When `stream.destroy()` is called without an `error` argument, stream is aborted.\n// This is the only way to abort a readable stream, which can be useful in some instances.\n// Therefore, we ignore this error on readable streams.\nexport const isStreamAbort = error => error?.code === 'ERR_STREAM_PREMATURE_CLOSE';\n\n// When `stream.write()` is called but the underlying source has been closed, `EPIPE` is emitted.\n// When piping subprocesses, the source subprocess usually decides when to stop piping.\n// However, there are some instances when the destination does instead, such as `... | head -n1`.\n// It notifies the source by using `EPIPE`.\n// Therefore, we ignore this error on writable streams.\nconst isStreamEpipe = error => error?.code === 'EPIPE';\n","import {getStreamOutput} from '../io/contents.js';\nimport {waitForStream, isInputFileDescriptor} from './wait-stream.js';\n\n// Read the contents of `subprocess.std*` and|or wait for its completion\nexport const waitForStdioStreams = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => subprocess.stdio.map((stream, fdNumber) => waitForSubprocessStream({\n\tstream,\n\tfdNumber,\n\tencoding,\n\tbuffer: buffer[fdNumber],\n\tmaxBuffer: maxBuffer[fdNumber],\n\tlines: lines[fdNumber],\n\tallMixed: false,\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n}));\n\n// Read the contents of `subprocess.std*` or `subprocess.all` and|or wait for its completion\nexport const waitForSubprocessStream = async ({stream, fdNumber, encoding, buffer, maxBuffer, lines, allMixed, stripFinalNewline, verboseInfo, streamInfo}) => {\n\tif (!stream) {\n\t\treturn;\n\t}\n\n\tconst onStreamEnd = waitForStream(stream, fdNumber, streamInfo);\n\tif (isInputFileDescriptor(streamInfo, fdNumber)) {\n\t\tawait onStreamEnd;\n\t\treturn;\n\t}\n\n\tconst [output] = await Promise.all([\n\t\tgetStreamOutput({\n\t\t\tstream,\n\t\t\tonStreamEnd,\n\t\t\tfdNumber,\n\t\t\tencoding,\n\t\t\tbuffer,\n\t\t\tmaxBuffer,\n\t\t\tlines,\n\t\t\tallMixed,\n\t\t\tstripFinalNewline,\n\t\t\tverboseInfo,\n\t\t\tstreamInfo,\n\t\t}),\n\t\tonStreamEnd,\n\t]);\n\treturn output;\n};\n","import mergeStreams from '@sindresorhus/merge-streams';\nimport {waitForSubprocessStream} from './stdio.js';\n\n// `all` interleaves `stdout` and `stderr`\nexport const makeAllStream = ({stdout, stderr}, {all}) => all && (stdout || stderr)\n\t? mergeStreams([stdout, stderr].filter(Boolean))\n\t: undefined;\n\n// Read the contents of `subprocess.all` and|or wait for its completion\nexport const waitForAllStream = ({subprocess, encoding, buffer, maxBuffer, lines, stripFinalNewline, verboseInfo, streamInfo}) => waitForSubprocessStream({\n\t...getAllStream(subprocess, buffer),\n\tfdNumber: 'all',\n\tencoding,\n\tmaxBuffer: maxBuffer[1] + maxBuffer[2],\n\tlines: lines[1] || lines[2],\n\tallMixed: getAllMixed(subprocess),\n\tstripFinalNewline,\n\tverboseInfo,\n\tstreamInfo,\n});\n\nconst getAllStream = ({stdout, stderr, all}, [, bufferStdout, bufferStderr]) => {\n\tconst buffer = bufferStdout || bufferStderr;\n\tif (!buffer) {\n\t\treturn {stream: all, buffer};\n\t}\n\n\tif (!bufferStdout) {\n\t\treturn {stream: stderr, buffer};\n\t}\n\n\tif (!bufferStderr) {\n\t\treturn {stream: stdout, buffer};\n\t}\n\n\treturn {stream: all, buffer};\n};\n\n// When `subprocess.stdout` is in objectMode but not `subprocess.stderr` (or the opposite), we need to use both:\n//  - `getStreamAsArray()` for the chunks in objectMode, to return as an array without changing each chunk\n//  - `getStreamAsArrayBuffer()` or `getStream()` for the chunks not in objectMode, to convert them from Buffers to string or Uint8Array\n// We do this by emulating the Buffer -> string|Uint8Array conversion performed by `get-stream` with our own, which is identical.\nconst getAllMixed = ({all, stdout, stderr}) => all\n\t&& stdout\n\t&& stderr\n\t&& stdout.readableObjectMode !== stderr.readableObjectMode;\n","import {once} from 'node:events';\nimport {isStream as isNodeStream} from 'is-stream';\nimport {throwOnTimeout} from '../terminate/timeout.js';\nimport {isStandardStream} from '../utils/standard-stream.js';\nimport {TRANSFORM_TYPES} from '../stdio/type.js';\nimport {getBufferedData} from '../io/contents.js';\nimport {waitForAllStream} from './all-async.js';\nimport {waitForStdioStreams} from './stdio.js';\nimport {waitForExit, waitForSuccessfulExit} from './exit-async.js';\nimport {waitForStream} from './wait-stream.js';\n\n// Retrieve result of subprocess: exit code, signal, error, streams (stdout/stderr/all)\nexport const waitForSubprocessResult = async ({\n\tsubprocess,\n\toptions: {encoding, buffer, maxBuffer, lines, timeoutDuration: timeout, stripFinalNewline},\n\tcontext,\n\tverboseInfo,\n\tfileDescriptors,\n\toriginalStreams,\n\tonInternalError,\n\tcontroller,\n}) => {\n\tconst exitPromise = waitForExit(subprocess);\n\tconst streamInfo = {\n\t\toriginalStreams,\n\t\tfileDescriptors,\n\t\tsubprocess,\n\t\texitPromise,\n\t\tpropagating: false,\n\t};\n\n\tconst stdioPromises = waitForStdioStreams({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst allPromise = waitForAllStream({\n\t\tsubprocess,\n\t\tencoding,\n\t\tbuffer,\n\t\tmaxBuffer,\n\t\tlines,\n\t\tstripFinalNewline,\n\t\tverboseInfo,\n\t\tstreamInfo,\n\t});\n\tconst originalPromises = waitForOriginalStreams(originalStreams, subprocess, streamInfo);\n\tconst customStreamsEndPromises = waitForCustomStreamsEnd(fileDescriptors, streamInfo);\n\n\ttry {\n\t\treturn await Promise.race([\n\t\t\tPromise.all([\n\t\t\t\t{},\n\t\t\t\twaitForSuccessfulExit(exitPromise),\n\t\t\t\tPromise.all(stdioPromises),\n\t\t\t\tallPromise,\n\t\t\t\t...originalPromises,\n\t\t\t\t...customStreamsEndPromises,\n\t\t\t]),\n\t\t\tonInternalError,\n\t\t\tthrowOnSubprocessError(subprocess, controller),\n\t\t\t...throwOnTimeout(subprocess, timeout, context, controller),\n\t\t]);\n\t} catch (error) {\n\t\treturn Promise.all([\n\t\t\t{error},\n\t\t\texitPromise,\n\t\t\tPromise.all(stdioPromises.map(stdioPromise => getBufferedData(stdioPromise))),\n\t\t\tgetBufferedData(allPromise),\n\t\t\tPromise.allSettled(originalPromises),\n\t\t\tPromise.allSettled(customStreamsEndPromises),\n\t\t]);\n\t}\n};\n\n// Transforms replace `subprocess.std*`, which means they are not exposed to users.\n// However, we still want to wait for their completion.\nconst waitForOriginalStreams = (originalStreams, subprocess, streamInfo) =>\n\toriginalStreams.map((stream, fdNumber) => stream === subprocess.stdio[fdNumber]\n\t\t? undefined\n\t\t: waitForStream(stream, fdNumber, streamInfo));\n\n// Some `stdin`/`stdout`/`stderr` options create a stream, e.g. when passing a file path.\n// The `.pipe()` method automatically ends that stream when `subprocess` ends.\n// This makes sure we wait for the completion of those streams, in order to catch any error.\nconst waitForCustomStreamsEnd = (fileDescriptors, streamInfo) => fileDescriptors.flatMap(({stdioItems}, fdNumber) => stdioItems\n\t.filter(({value, stream = value}) => isNodeStream(stream, {checkOpen: false}) && !isStandardStream(stream))\n\t.map(({type, value, stream = value}) => waitForStream(stream, fdNumber, streamInfo, {\n\t\tisSameDirection: TRANSFORM_TYPES.has(type),\n\t\tstopOnExit: type === 'native',\n\t})));\n\n// Fails when the subprocess emits an `error` event\nconst throwOnSubprocessError = async (subprocess, {signal}) => {\n\tconst [error] = await once(subprocess, 'error', {signal});\n\tthrow error;\n};\n","export const createDeferred = () => {\n\tconst methods = {};\n\tconst promise = new Promise((resolve, reject) => {\n\t\tObject.assign(methods, {resolve, reject});\n\t});\n\treturn Object.assign(promise, methods);\n};\n","import {createDeferred} from '../utils/deferred.js';\n\n// When using multiple `.readable()`/`.writable()`/`.duplex()`, `final` and `destroy` should wait for other streams\nexport const initializeConcurrentStreams = () => ({\n\treadableDestroy: new WeakMap(),\n\twritableFinal: new WeakMap(),\n\twritableDestroy: new WeakMap(),\n});\n\n// Each file descriptor + `waitName` has its own array of promises.\n// Each promise is a single `.readable()`/`.writable()`/`.duplex()` call.\nexport const addConcurrentStream = (concurrentStreams, stream, waitName) => {\n\tconst weakMap = concurrentStreams[waitName];\n\tif (!weakMap.has(stream)) {\n\t\tweakMap.set(stream, []);\n\t}\n\n\tconst promises = weakMap.get(stream);\n\tconst promise = createDeferred();\n\tpromises.push(promise);\n\tconst resolve = promise.resolve.bind(promise);\n\treturn {resolve, promises};\n};\n\n// Wait for other streams, but stop waiting when subprocess ends\nexport const waitForConcurrentStreams = async ({resolve, promises}, subprocess) => {\n\tresolve();\n\tconst [isSubprocessExit] = await Promise.race([\n\t\tPromise.allSettled([true, subprocess]),\n\t\tPromise.all([false, ...promises]),\n\t]);\n\treturn !isSubprocessExit;\n};\n","import {finished} from 'node:stream/promises';\nimport {isStreamAbort} from '../resolve/wait-stream.js';\n\nexport const safeWaitForSubprocessStdin = async subprocessStdin => {\n\tif (subprocessStdin === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t} catch {}\n};\n\nexport const safeWaitForSubprocessStdout = async subprocessStdout => {\n\tif (subprocessStdout === undefined) {\n\t\treturn;\n\t}\n\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t} catch {}\n};\n\nexport const waitForSubprocessStdin = async subprocessStdin => {\n\tawait finished(subprocessStdin, {cleanup: true, readable: false, writable: true});\n};\n\nexport const waitForSubprocessStdout = async subprocessStdout => {\n\tawait finished(subprocessStdout, {cleanup: true, readable: true, writable: false});\n};\n\n// When `readable` or `writable` aborts/errors, awaits the subprocess, for the reason mentioned above\nexport const waitForSubprocess = async (subprocess, error) => {\n\tawait subprocess;\n\tif (error) {\n\t\tthrow error;\n\t}\n};\n\nexport const destroyOtherStream = (stream, isOpen, error) => {\n\tif (error && !isStreamAbort(error)) {\n\t\tstream.destroy(error);\n\t} else if (isOpen) {\n\t\tstream.destroy();\n\t}\n};\n","import {Readable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream, DEFAULT_OBJECT_HIGH_WATER_MARK} from '../io/iterate.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdin,\n\twaitForSubprocessStdout,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Readable` stream that forwards from `stdout` and awaits the subprocess\nexport const createReadable = ({subprocess, concurrentStreams, encoding}, {from, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst readable = new Readable({\n\t\tread,\n\t\tdestroy: callbackify(onReadableDestroy.bind(undefined, {subprocessStdout, subprocess, waitReadableDestroy})),\n\t\thighWaterMark: readableHighWaterMark,\n\t\tobjectMode: readableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable,\n\t\tsubprocess,\n\t});\n\treturn readable;\n};\n\n// Retrieve `stdout` (or other stream depending on `from`)\nexport const getSubprocessStdout = (subprocess, from, concurrentStreams) => {\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst waitReadableDestroy = addConcurrentStream(concurrentStreams, subprocessStdout, 'readableDestroy');\n\treturn {subprocessStdout, waitReadableDestroy};\n};\n\nexport const getReadableOptions = ({readableEncoding, readableObjectMode, readableHighWaterMark}, binary) => binary\n\t? {readableEncoding, readableObjectMode, readableHighWaterMark}\n\t: {readableEncoding, readableObjectMode: true, readableHighWaterMark: DEFAULT_OBJECT_HIGH_WATER_MARK};\n\nexport const getReadableMethods = ({subprocessStdout, subprocess, binary, encoding, preserveNewlines}) => {\n\tconst onStdoutDataDone = createDeferred();\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: !binary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\n\treturn {\n\t\tread() {\n\t\t\tonRead(this, onStdoutData, onStdoutDataDone);\n\t\t},\n\t\tonStdoutDataDone,\n\t};\n};\n\n// Forwards data from `stdout` to `readable`\nconst onRead = async (readable, onStdoutData, onStdoutDataDone) => {\n\ttry {\n\t\tconst {value, done} = await onStdoutData.next();\n\t\tif (done) {\n\t\t\tonStdoutDataDone.resolve();\n\t\t} else {\n\t\t\treadable.push(value);\n\t\t}\n\t} catch {}\n};\n\n// When `subprocess.stdout` ends/aborts/errors, do the same on `readable`.\n// Await the subprocess, for the same reason as above.\nexport const onStdoutFinished = async ({subprocessStdout, onStdoutDataDone, readable, subprocess, subprocessStdin}) => {\n\ttry {\n\t\tawait waitForSubprocessStdout(subprocessStdout);\n\t\tawait subprocess;\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tawait onStdoutDataDone;\n\n\t\tif (readable.readable) {\n\t\t\treadable.push(null);\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdin(subprocessStdin);\n\t\tdestroyOtherReadable(readable, error);\n\t}\n};\n\n// When `readable` aborts/errors, do the same on `subprocess.stdout`\nexport const onReadableDestroy = async ({subprocessStdout, subprocess, waitReadableDestroy}, error) => {\n\tif (await waitForConcurrentStreams(waitReadableDestroy, subprocess)) {\n\t\tdestroyOtherReadable(subprocessStdout, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherReadable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.readable, error);\n};\n","import {Writable} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {getToStream} from '../arguments/fd-options.js';\nimport {addConcurrentStream, waitForConcurrentStreams} from './concurrent.js';\nimport {\n\tsafeWaitForSubprocessStdout,\n\twaitForSubprocessStdin,\n\twaitForSubprocess,\n\tdestroyOtherStream,\n} from './shared.js';\n\n// Create a `Writable` stream that forwards to `stdin` and awaits the subprocess\nexport const createWritable = ({subprocess, concurrentStreams}, {to} = {}) => {\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst writable = new Writable({\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onWritableDestroy.bind(undefined, {\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\thighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\tobjectMode: subprocessStdin.writableObjectMode,\n\t});\n\tonStdinFinished(subprocessStdin, writable);\n\treturn writable;\n};\n\n// Retrieve `stdin` (or other stream depending on `to`)\nexport const getSubprocessStdin = (subprocess, to, concurrentStreams) => {\n\tconst subprocessStdin = getToStream(subprocess, to);\n\tconst waitWritableFinal = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableFinal');\n\tconst waitWritableDestroy = addConcurrentStream(concurrentStreams, subprocessStdin, 'writableDestroy');\n\treturn {subprocessStdin, waitWritableFinal, waitWritableDestroy};\n};\n\nexport const getWritableMethods = (subprocessStdin, subprocess, waitWritableFinal) => ({\n\twrite: onWrite.bind(undefined, subprocessStdin),\n\tfinal: callbackify(onWritableFinal.bind(undefined, subprocessStdin, subprocess, waitWritableFinal)),\n});\n\n// Forwards data from `writable` to `stdin`\nconst onWrite = (subprocessStdin, chunk, encoding, done) => {\n\tif (subprocessStdin.write(chunk, encoding)) {\n\t\tdone();\n\t} else {\n\t\tsubprocessStdin.once('drain', done);\n\t}\n};\n\n// Ensures that the writable `final` and readable `end` events awaits the subprocess.\n// Like this, any subprocess failure is propagated as a stream `error` event, instead of being lost.\n// The user does not need to `await` the subprocess anymore, but now needs to await the stream completion or error.\n// When multiple writables are targeting the same stream, they wait for each other, unless the subprocess ends first.\nconst onWritableFinal = async (subprocessStdin, subprocess, waitWritableFinal) => {\n\tif (await waitForConcurrentStreams(waitWritableFinal, subprocess)) {\n\t\tif (subprocessStdin.writable) {\n\t\t\tsubprocessStdin.end();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n\n// When `subprocess.stdin` ends/aborts/errors, do the same on `writable`.\nexport const onStdinFinished = async (subprocessStdin, writable, subprocessStdout) => {\n\ttry {\n\t\tawait waitForSubprocessStdin(subprocessStdin);\n\t\tif (writable.writable) {\n\t\t\twritable.end();\n\t\t}\n\t} catch (error) {\n\t\tawait safeWaitForSubprocessStdout(subprocessStdout);\n\t\tdestroyOtherWritable(writable, error);\n\t}\n};\n\n// When `writable` aborts/errors, do the same on `subprocess.stdin`\nexport const onWritableDestroy = async ({subprocessStdin, subprocess, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait waitForConcurrentStreams(waitWritableFinal, subprocess);\n\tif (await waitForConcurrentStreams(waitWritableDestroy, subprocess)) {\n\t\tdestroyOtherWritable(subprocessStdin, error);\n\t\tawait waitForSubprocess(subprocess, error);\n\t}\n};\n\nconst destroyOtherWritable = (stream, error) => {\n\tdestroyOtherStream(stream, stream.writable, error);\n};\n","import {Duplex} from 'node:stream';\nimport {callbackify} from 'node:util';\nimport {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {\n\tgetSubprocessStdout,\n\tgetReadableOptions,\n\tgetReadableMethods,\n\tonStdoutFinished,\n\tonReadableDestroy,\n} from './readable.js';\nimport {\n\tgetSubprocessStdin,\n\tgetWritableMethods,\n\tonStdinFinished,\n\tonWritableDestroy,\n} from './writable.js';\n\n// Create a `Duplex` stream combining both `subprocess.readable()` and `subprocess.writable()`\nexport const createDuplex = ({subprocess, concurrentStreams, encoding}, {from, to, binary: binaryOption = true, preserveNewlines = true} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst {subprocessStdout, waitReadableDestroy} = getSubprocessStdout(subprocess, from, concurrentStreams);\n\tconst {subprocessStdin, waitWritableFinal, waitWritableDestroy} = getSubprocessStdin(subprocess, to, concurrentStreams);\n\tconst {readableEncoding, readableObjectMode, readableHighWaterMark} = getReadableOptions(subprocessStdout, binary);\n\tconst {read, onStdoutDataDone} = getReadableMethods({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\tconst duplex = new Duplex({\n\t\tread,\n\t\t...getWritableMethods(subprocessStdin, subprocess, waitWritableFinal),\n\t\tdestroy: callbackify(onDuplexDestroy.bind(undefined, {\n\t\t\tsubprocessStdout,\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitReadableDestroy,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t})),\n\t\treadableHighWaterMark,\n\t\twritableHighWaterMark: subprocessStdin.writableHighWaterMark,\n\t\treadableObjectMode,\n\t\twritableObjectMode: subprocessStdin.writableObjectMode,\n\t\tencoding: readableEncoding,\n\t});\n\tonStdoutFinished({\n\t\tsubprocessStdout,\n\t\tonStdoutDataDone,\n\t\treadable: duplex,\n\t\tsubprocess,\n\t\tsubprocessStdin,\n\t});\n\tonStdinFinished(subprocessStdin, duplex, subprocessStdout);\n\treturn duplex;\n};\n\nconst onDuplexDestroy = async ({subprocessStdout, subprocessStdin, subprocess, waitReadableDestroy, waitWritableFinal, waitWritableDestroy}, error) => {\n\tawait Promise.all([\n\t\tonReadableDestroy({subprocessStdout, subprocess, waitReadableDestroy}, error),\n\t\tonWritableDestroy({\n\t\t\tsubprocessStdin,\n\t\t\tsubprocess,\n\t\t\twaitWritableFinal,\n\t\t\twaitWritableDestroy,\n\t\t}, error),\n\t]);\n};\n","import {BINARY_ENCODINGS} from '../arguments/encoding-option.js';\nimport {getFromStream} from '../arguments/fd-options.js';\nimport {iterateOnSubprocessStream} from '../io/iterate.js';\n\n// Convert the subprocess to an async iterable\nexport const createIterable = (subprocess, encoding, {\n\tfrom,\n\tbinary: binaryOption = false,\n\tpreserveNewlines = false,\n} = {}) => {\n\tconst binary = binaryOption || BINARY_ENCODINGS.has(encoding);\n\tconst subprocessStdout = getFromStream(subprocess, from);\n\tconst onStdoutData = iterateOnSubprocessStream({\n\t\tsubprocessStdout,\n\t\tsubprocess,\n\t\tbinary,\n\t\tshouldEncode: true,\n\t\tencoding,\n\t\tpreserveNewlines,\n\t});\n\treturn iterateOnStdoutData(onStdoutData, subprocessStdout, subprocess);\n};\n\nconst iterateOnStdoutData = async function * (onStdoutData, subprocessStdout, subprocess) {\n\ttry {\n\t\tyield * onStdoutData;\n\t} finally {\n\t\tif (subprocessStdout.readable) {\n\t\t\tsubprocessStdout.destroy();\n\t\t}\n\n\t\tawait subprocess;\n\t}\n};\n","import {initializeConcurrentStreams} from './concurrent.js';\nimport {createReadable} from './readable.js';\nimport {createWritable} from './writable.js';\nimport {createDuplex} from './duplex.js';\nimport {createIterable} from './iterable.js';\n\n// Add methods to convert the subprocess to a stream or iterable\nexport const addConvertedStreams = (subprocess, {encoding}) => {\n\tconst concurrentStreams = initializeConcurrentStreams();\n\tsubprocess.readable = createReadable.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.writable = createWritable.bind(undefined, {subprocess, concurrentStreams});\n\tsubprocess.duplex = createDuplex.bind(undefined, {subprocess, concurrentStreams, encoding});\n\tsubprocess.iterable = createIterable.bind(undefined, subprocess, encoding);\n\tsubprocess[Symbol.asyncIterator] = createIterable.bind(undefined, subprocess, encoding, {});\n};\n","// The return value is a mixin of `subprocess` and `Promise`\nexport const mergePromise = (subprocess, promise) => {\n\tfor (const [property, descriptor] of descriptors) {\n\t\tconst value = descriptor.value.bind(promise);\n\t\tReflect.defineProperty(subprocess, property, {...descriptor, value});\n\t}\n};\n\n// eslint-disable-next-line unicorn/prefer-top-level-await\nconst nativePromisePrototype = (async () => {})().constructor.prototype;\n\nconst descriptors = ['then', 'catch', 'finally'].map(property => [\n\tproperty,\n\tReflect.getOwnPropertyDescriptor(nativePromisePrototype, property),\n]);\n","import {setMaxListeners} from 'node:events';\nimport {spawn} from 'node:child_process';\nimport {MaxBufferError} from 'get-stream';\nimport {handleCommand} from '../arguments/command.js';\nimport {normalizeOptions} from '../arguments/options.js';\nimport {SUBPROCESS_OPTIONS} from '../arguments/fd-options.js';\nimport {makeError, makeSuccessResult} from '../return/result.js';\nimport {handleResult} from '../return/reject.js';\nimport {handleEarlyError} from '../return/early-error.js';\nimport {handleStdioAsync} from '../stdio/handle-async.js';\nimport {stripNewline} from '../io/strip-newline.js';\nimport {pipeOutputAsync} from '../io/output-async.js';\nimport {subprocessKill} from '../terminate/kill.js';\nimport {cleanupOnExit} from '../terminate/cleanup.js';\nimport {pipeToSubprocess} from '../pipe/setup.js';\nimport {logEarlyResult} from '../verbose/complete.js';\nimport {makeAllStream} from '../resolve/all-async.js';\nimport {waitForSubprocessResult} from '../resolve/wait-subprocess.js';\nimport {addConvertedStreams} from '../convert/add.js';\nimport {createDeferred} from '../utils/deferred.js';\nimport {mergePromise} from './promise.js';\n\n// Main shared logic for all async methods: `execa()`, `execaCommand()`, `$`, `execaNode()`\nexport const execaCoreAsync = (rawFile, rawArguments, rawOptions, createNested) => {\n\tconst {file, commandArguments, command, escapedCommand, startTime, verboseInfo, options, fileDescriptors} = handleAsyncArguments(rawFile, rawArguments, rawOptions);\n\tconst {subprocess, promise} = spawnSubprocessAsync({\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tfileDescriptors,\n\t});\n\tsubprocess.pipe = pipeToSubprocess.bind(undefined, {\n\t\tsource: subprocess,\n\t\tsourcePromise: promise,\n\t\tboundOptions: {},\n\t\tcreateNested,\n\t});\n\tmergePromise(subprocess, promise);\n\tSUBPROCESS_OPTIONS.set(subprocess, {options, fileDescriptors});\n\treturn subprocess;\n};\n\n// Compute arguments to pass to `child_process.spawn()`\nconst handleAsyncArguments = (rawFile, rawArguments, rawOptions) => {\n\tconst {command, escapedCommand, startTime, verboseInfo} = handleCommand(rawFile, rawArguments, rawOptions);\n\n\ttry {\n\t\tconst {file, commandArguments, options: normalizedOptions} = normalizeOptions(rawFile, rawArguments, rawOptions);\n\t\tconst options = handleAsyncOptions(normalizedOptions);\n\t\tconst fileDescriptors = handleStdioAsync(options, verboseInfo);\n\t\treturn {\n\t\t\tfile,\n\t\t\tcommandArguments,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tstartTime,\n\t\t\tverboseInfo,\n\t\t\toptions,\n\t\t\tfileDescriptors,\n\t\t};\n\t} catch (error) {\n\t\tlogEarlyResult(error, startTime, verboseInfo);\n\t\tthrow error;\n\t}\n};\n\n// Options normalization logic specific to async methods.\n// Prevent passing the `timeout` option directly to `child_process.spawn()`.\nconst handleAsyncOptions = ({timeout, signal, cancelSignal, ...options}) => {\n\tif (signal !== undefined) {\n\t\tthrow new TypeError('The \"signal\" option has been renamed to \"cancelSignal\" instead.');\n\t}\n\n\treturn {...options, timeoutDuration: timeout, signal: cancelSignal};\n};\n\nconst spawnSubprocessAsync = ({file, commandArguments, options, startTime, verboseInfo, command, escapedCommand, fileDescriptors}) => {\n\tlet subprocess;\n\ttry {\n\t\tsubprocess = spawn(file, commandArguments, options);\n\t} catch (error) {\n\t\treturn handleEarlyError({\n\t\t\terror,\n\t\t\tcommand,\n\t\t\tescapedCommand,\n\t\t\tfileDescriptors,\n\t\t\toptions,\n\t\t\tstartTime,\n\t\t\tverboseInfo,\n\t\t});\n\t}\n\n\tconst controller = new AbortController();\n\tsetMaxListeners(Number.POSITIVE_INFINITY, controller.signal);\n\n\tconst originalStreams = [...subprocess.stdio];\n\tpipeOutputAsync(subprocess, fileDescriptors, controller);\n\tcleanupOnExit(subprocess, options, controller);\n\n\tconst onInternalError = createDeferred();\n\tsubprocess.kill = subprocessKill.bind(undefined, {\n\t\tkill: subprocess.kill.bind(subprocess),\n\t\toptions,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\tsubprocess.all = makeAllStream(subprocess, options);\n\taddConvertedStreams(subprocess, options);\n\n\tconst promise = handlePromise({\n\t\tsubprocess,\n\t\toptions,\n\t\tstartTime,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\treturn {subprocess, promise};\n};\n\n// Asynchronous logic, as opposed to the previous logic which can be run synchronously, i.e. can be returned to user right away\nconst handlePromise = async ({subprocess, options, startTime, verboseInfo, fileDescriptors, originalStreams, command, escapedCommand, onInternalError, controller}) => {\n\tconst context = {timedOut: false};\n\n\tconst [errorInfo, [exitCode, signal], stdioResults, allResult] = await waitForSubprocessResult({\n\t\tsubprocess,\n\t\toptions,\n\t\tcontext,\n\t\tverboseInfo,\n\t\tfileDescriptors,\n\t\toriginalStreams,\n\t\tonInternalError,\n\t\tcontroller,\n\t});\n\tcontroller.abort();\n\tonInternalError.resolve();\n\n\tconst stdio = stdioResults.map((stdioResult, fdNumber) => stripNewline(stdioResult, options, fdNumber));\n\tconst all = stripNewline(allResult, options, 'all');\n\tconst result = getAsyncResult({\n\t\terrorInfo,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\tcontext,\n\t\toptions,\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstartTime,\n\t});\n\treturn handleResult(result, verboseInfo, options);\n};\n\nconst getAsyncResult = ({errorInfo, exitCode, signal, stdio, all, context, options, command, escapedCommand, startTime}) => 'error' in errorInfo\n\t? makeError({\n\t\terror: errorInfo.error,\n\t\tcommand,\n\t\tescapedCommand,\n\t\ttimedOut: context.timedOut,\n\t\tisCanceled: options.signal?.aborted === true,\n\t\tisMaxBuffer: errorInfo.error instanceof MaxBufferError,\n\t\texitCode,\n\t\tsignal,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tstartTime,\n\t\tisSync: false,\n\t})\n\t: makeSuccessResult({\n\t\tcommand,\n\t\tescapedCommand,\n\t\tstdio,\n\t\tall,\n\t\toptions,\n\t\tstartTime,\n\t});\n","import isPlainObject from 'is-plain-obj';\nimport {FD_SPECIFIC_OPTIONS} from '../arguments/specific.js';\n\n// Deep merge specific options like `env`. Shallow merge the other ones.\nexport const mergeOptions = (boundOptions, options) => {\n\tconst newOptions = Object.fromEntries(\n\t\tObject.entries(options).map(([optionName, optionValue]) => [\n\t\t\toptionName,\n\t\t\tmergeOption(optionName, boundOptions[optionName], optionValue),\n\t\t]),\n\t);\n\treturn {...boundOptions, ...newOptions};\n};\n\nconst mergeOption = (optionName, boundOptionValue, optionValue) => {\n\tif (DEEP_OPTIONS.has(optionName) && isPlainObject(boundOptionValue) && isPlainObject(optionValue)) {\n\t\treturn {...boundOptionValue, ...optionValue};\n\t}\n\n\treturn optionValue;\n};\n\nconst DEEP_OPTIONS = new Set(['env', ...FD_SPECIFIC_OPTIONS]);\n","import isPlainObject from 'is-plain-obj';\nimport {normalizeParameters} from './parameters.js';\nimport {isTemplateString, parseTemplates} from './template.js';\nimport {execaCoreSync} from './main-sync.js';\nimport {execaCoreAsync} from './main-async.js';\nimport {mergeOptions} from './bind.js';\n\n// Wraps every exported methods to provide the following features:\n//  - template string syntax: execa`command argument`\n//  - options binding: boundExeca = execa(options)\n//  - optional argument/options: execa(file), execa(file, args), execa(file, options), execa(file, args, options)\n// `mapArguments()` and `setBoundExeca()` allows for method-specific logic.\nexport const createExeca = (mapArguments, boundOptions, deepOptions, setBoundExeca) => {\n\tconst createNested = (mapArguments, boundOptions, setBoundExeca) => createExeca(mapArguments, boundOptions, deepOptions, setBoundExeca);\n\tconst boundExeca = (...execaArguments) => callBoundExeca({\n\t\tmapArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t\tsetBoundExeca,\n\t\tcreateNested,\n\t}, ...execaArguments);\n\n\tif (setBoundExeca !== undefined) {\n\t\tsetBoundExeca(boundExeca, createNested, boundOptions);\n\t}\n\n\treturn boundExeca;\n};\n\nconst callBoundExeca = ({mapArguments, deepOptions = {}, boundOptions = {}, setBoundExeca, createNested}, firstArgument, ...nextArguments) => {\n\tif (isPlainObject(firstArgument)) {\n\t\treturn createNested(mapArguments, mergeOptions(boundOptions, firstArgument), setBoundExeca);\n\t}\n\n\tconst {file, commandArguments, options, isSync} = parseArguments({\n\t\tmapArguments,\n\t\tfirstArgument,\n\t\tnextArguments,\n\t\tdeepOptions,\n\t\tboundOptions,\n\t});\n\treturn isSync\n\t\t? execaCoreSync(file, commandArguments, options)\n\t\t: execaCoreAsync(file, commandArguments, options, createNested);\n};\n\nconst parseArguments = ({mapArguments, firstArgument, nextArguments, deepOptions, boundOptions}) => {\n\tconst callArguments = isTemplateString(firstArgument)\n\t\t? parseTemplates(firstArgument, nextArguments)\n\t\t: [firstArgument, ...nextArguments];\n\tconst [initialFile, initialArguments, initialOptions] = normalizeParameters(...callArguments);\n\tconst mergedOptions = mergeOptions(mergeOptions(deepOptions, boundOptions), initialOptions);\n\tconst {\n\t\tfile = initialFile,\n\t\tcommandArguments = initialArguments,\n\t\toptions = mergedOptions,\n\t\tisSync = false,\n\t} = mapArguments({file: initialFile, commandArguments: initialArguments, options: mergedOptions});\n\treturn {\n\t\tfile,\n\t\tcommandArguments,\n\t\toptions,\n\t\tisSync,\n\t};\n};\n","// Main logic for `execaCommand()`\nexport const mapCommandAsync = ({file, commandArguments}) => parseCommand(file, commandArguments);\n\n// Main logic for `execaCommandSync()`\nexport const mapCommandSync = ({file, commandArguments}) => ({...parseCommand(file, commandArguments), isSync: true});\n\n// Convert `execaCommand(command)` into `execa(file, ...commandArguments)`\nconst parseCommand = (command, unusedArguments) => {\n\tif (unusedArguments.length > 0) {\n\t\tthrow new TypeError(`The command and its arguments must be passed as a single string: ${command} ${unusedArguments}.`);\n\t}\n\n\tconst tokens = [];\n\tfor (const token of command.trim().split(SPACES_REGEXP)) {\n\t\t// Allow spaces to be escaped by a backslash if not meant as a delimiter\n\t\tconst previousToken = tokens.at(-1);\n\t\tif (previousToken && previousToken.endsWith('\\\\')) {\n\t\t\t// Merge previous token with current one\n\t\t\ttokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;\n\t\t} else {\n\t\t\ttokens.push(token);\n\t\t}\n\t}\n\n\tconst [file, ...commandArguments] = tokens;\n\treturn {file, commandArguments};\n};\n\nconst SPACES_REGEXP = / +/g;\n","// Sets `$.sync` and `$.s`\nexport const setScriptSync = (boundExeca, createNested, boundOptions) => {\n\tboundExeca.sync = createNested(mapScriptSync, boundOptions);\n\tboundExeca.s = boundExeca.sync;\n};\n\n// Main logic for `$`\nexport const mapScriptAsync = ({options}) => getScriptOptions(options);\n\n// Main logic for `$.sync`\nconst mapScriptSync = ({options}) => ({...getScriptOptions(options), isSync: true});\n\n// `$` is like `execa` but with script-friendly options: `{stdin: 'inherit', preferLocal: true}`\nconst getScriptOptions = options => ({options: {...getScriptStdinOption(options), ...options}});\n\nconst getScriptStdinOption = ({input, inputFile, stdio}) => input === undefined && inputFile === undefined && stdio === undefined\n\t? {stdin: 'inherit'}\n\t: {};\n\n// When using $(...).pipe(...), most script-friendly options should apply to both commands.\n// However, some options (like `stdin: 'inherit'`) would create issues with piping, i.e. cannot be deep.\nexport const deepScriptOptions = {preferLocal: true};\n","import {createExeca} from './lib/methods/create.js';\nimport {mapCommandAsync, mapCommandSync} from './lib/methods/command.js';\nimport {mapNode} from './lib/methods/node.js';\nimport {mapScriptAsync, setScriptSync, deepScriptOptions} from './lib/methods/script.js';\n\nexport {ExecaError, ExecaSyncError} from './lib/return/final-error.js';\n\nexport const execa = createExeca(() => ({}));\nexport const execaSync = createExeca(() => ({isSync: true}));\nexport const execaCommand = createExeca(mapCommandAsync);\nexport const execaCommandSync = createExeca(mapCommandSync);\nexport const execaNode = createExeca(mapNode);\nexport const $ = createExeca(mapScriptAsync, {}, deepScriptOptions, setScriptSync);\n"],"names":["cp","parse","enoent","spawn","command","args","options","parsed","spawned","hookChildProcess","module","exports","sync","result","spawnSync","error","verifyENOENTSync","status","_parse","_enoent","isWin","process","platform","notFoundError","original","syscall","Object","assign","Error","code","errno","path","spawnargs","verifyENOENT","file","originalEmit","emit","name","arg1","err","call","apply","arguments","resolveCommand","escape","readShebang","isExecutableRegExp","isCmdShimRegExp","Array","isArray","slice","undefined","shell","commandFile","shebang","unshift","detectShebang","needsShell","test","forceShell","needsDoubleEscapeMetaChars","normalize","map","arg","argument","shellCommand","concat","join","env","comspec","windowsVerbatimArguments","parseNonShell","metaCharsRegExp","replace","doubleEscapeMetaChars","fs","shebangCommand","buffer","Buffer","alloc","fd","openSync","readSync","closeSync","e","toString","which","getPathKey","resolveCommandAttempt","withoutPathExt","cwd","hasCustomCwd","shouldSwitchCwd","chdir","disabled","resolved","pathExt","delimiter","resolve","core","isexe","cb","Promise","TypeError","reject","er","is","ignoreErrors","global","TESTING_WINDOWS","checkStat","statSync","stat","isFile","mod","mode","uid","gid","myUid","getuid","myGid","getgid","u","parseInt","g","checkMode","isSymbolicLink","pathext","PATHEXT","split","indexOf","i","length","p","toLowerCase","substr","checkPathExt","isWindows","OSTYPE","COLON","getNotFoundError","cmd","getPathInfo","opt","colon","pathEnv","match","PATH","pathExtExe","found","step","all","ppRaw","pathPart","pCmd","subStep","ii","ext","push","then","res","j","cur","ex","nothrow","pathKey","environment","keys","reverse","find","key","toUpperCase","shebangRegex","string","binary","pop","isPlainObject","value","prototype","getPrototypeOf","Symbol","toStringTag","iterator","safeNormalizeFileUrl","fileString","normalizeFileUrl","URL","fileURLToPath","normalizeParameters","rawFile","rawArguments","rawOptions","filePath","commandArguments","some","commandArgument","normalizedArguments","String","nullByteArgument","normalizedArgument","includes","objectToString","isUint8Array","bufferToUint8Array","Uint8Array","byteOffset","byteLength","textEncoder","TextEncoder","stringToUint8Array","encode","textDecoder","TextDecoder","uint8ArrayToString","uint8Array","decode","joinToUint8Array","uint8ArraysOrStrings","concatUint8Arrays","stringsToUint8Arrays","uint8ArrayOrString","uint8Arrays","getJoinLength","index","set","joinLength","parseTemplate","templates","expressions","tokens","template","raw","nextTokens","leadingWhitespaces","trailingWhitespaces","splitByWhitespaces","newTokens","concatTokens","expression","expressionTokens","parseExpression","rawTemplate","templateStart","DELIMITERS","has","templateIndex","rawIndex","rawCharacter","nextRawCharacter","ESCAPE_LENGTH","Set","x","isSeparated","at","typeOfExpression","getSubprocessResult","ChildProcess","stdout","hasColors","format","open","close","input","openCode","closeCode","lastIndex","bold","gray","redBright","yellowBright","verboseDefault","debuglog","enabled","VERBOSE_ID","isVerbose","verbose","fdVerbose","VERBOSE_VALUES","common","circleQuestionMark","questionMarkPrefix","square","squareDarkShade","squareMediumShade","squareLightShade","squareTop","squareBottom","squareLeft","squareRight","squareCenter","bullet","dot","ellipsis","pointerSmall","triangleUp","triangleUpSmall","triangleDown","triangleDownSmall","triangleLeftSmall","triangleRightSmall","home","heart","musicNote","musicNoteBeamed","arrowUp","arrowDown","arrowLeft","arrowRight","arrowLeftRight","arrowUpDown","almostEqual","notEqual","lessOrEqual","greaterOrEqual","identical","infinity","subscriptZero","subscriptOne","subscriptTwo","subscriptThree","subscriptFour","subscriptFive","subscriptSix","subscriptSeven","subscriptEight","subscriptNine","oneHalf","oneThird","oneQuarter","oneFifth","oneSixth","oneEighth","twoThirds","twoFifths","threeQuarters","threeFifths","threeEighths","fourFifths","fiveSixths","fiveEighths","sevenEighths","line","lineBold","lineDouble","lineDashed0","lineDashed1","lineDashed2","lineDashed3","lineDashed4","lineDashed5","lineDashed6","lineDashed7","lineDashed8","lineDashed9","lineDashed10","lineDashed11","lineDashed12","lineDashed13","lineDashed14","lineDashed15","lineVertical","lineVerticalBold","lineVerticalDouble","lineVerticalDashed0","lineVerticalDashed1","lineVerticalDashed2","lineVerticalDashed3","lineVerticalDashed4","lineVerticalDashed5","lineVerticalDashed6","lineVerticalDashed7","lineVerticalDashed8","lineVerticalDashed9","lineVerticalDashed10","lineVerticalDashed11","lineDownLeft","lineDownLeftArc","lineDownBoldLeftBold","lineDownBoldLeft","lineDownLeftBold","lineDownDoubleLeftDouble","lineDownDoubleLeft","lineDownLeftDouble","lineDownRight","lineDownRightArc","lineDownBoldRightBold","lineDownBoldRight","lineDownRightBold","lineDownDoubleRightDouble","lineDownDoubleRight","lineDownRightDouble","lineUpLeft","lineUpLeftArc","lineUpBoldLeftBold","lineUpBoldLeft","lineUpLeftBold","lineUpDoubleLeftDouble","lineUpDoubleLeft","lineUpLeftDouble","lineUpRight","lineUpRightArc","lineUpBoldRightBold","lineUpBoldRight","lineUpRightBold","lineUpDoubleRightDouble","lineUpDoubleRight","lineUpRightDouble","lineUpDownLeft","lineUpBoldDownBoldLeftBold","lineUpBoldDownBoldLeft","lineUpDownLeftBold","lineUpBoldDownLeftBold","lineUpDownBoldLeftBold","lineUpDownBoldLeft","lineUpBoldDownLeft","lineUpDoubleDownDoubleLeftDouble","lineUpDoubleDownDoubleLeft","lineUpDownLeftDouble","lineUpDownRight","lineUpBoldDownBoldRightBold","lineUpBoldDownBoldRight","lineUpDownRightBold","lineUpBoldDownRightBold","lineUpDownBoldRightBold","lineUpDownBoldRight","lineUpBoldDownRight","lineUpDoubleDownDoubleRightDouble","lineUpDoubleDownDoubleRight","lineUpDownRightDouble","lineDownLeftRight","lineDownBoldLeftBoldRightBold","lineDownLeftBoldRightBold","lineDownBoldLeftRight","lineDownBoldLeftBoldRight","lineDownBoldLeftRightBold","lineDownLeftRightBold","lineDownLeftBoldRight","lineDownDoubleLeftDoubleRightDouble","lineDownDoubleLeftRight","lineDownLeftDoubleRightDouble","lineUpLeftRight","lineUpBoldLeftBoldRightBold","lineUpLeftBoldRightBold","lineUpBoldLeftRight","lineUpBoldLeftBoldRight","lineUpBoldLeftRightBold","lineUpLeftRightBold","lineUpLeftBoldRight","lineUpDoubleLeftDoubleRightDouble","lineUpDoubleLeftRight","lineUpLeftDoubleRightDouble","lineUpDownLeftRight","lineUpBoldDownBoldLeftBoldRightBold","lineUpDownBoldLeftBoldRightBold","lineUpBoldDownLeftBoldRightBold","lineUpBoldDownBoldLeftRightBold","lineUpBoldDownBoldLeftBoldRight","lineUpBoldDownLeftRight","lineUpDownBoldLeftRight","lineUpDownLeftBoldRight","lineUpDownLeftRightBold","lineUpBoldDownBoldLeftRight","lineUpDownLeftBoldRightBold","lineUpBoldDownLeftBoldRight","lineUpBoldDownLeftRightBold","lineUpDownBoldLeftBoldRight","lineUpDownBoldLeftRightBold","lineUpDoubleDownDoubleLeftDoubleRightDouble","lineUpDoubleDownDoubleLeftRight","lineUpDownLeftDoubleRightDouble","lineCross","lineBackslash","lineSlash","specialMainSymbols","tick","info","warning","cross","squareSmall","squareSmallFilled","circle","circleFilled","circleDotted","circleDouble","circleCircle","circleCross","circlePipe","radioOn","radioOff","checkboxOn","checkboxOff","checkboxCircleOn","checkboxCircleOff","pointer","triangleUpOutline","triangleLeft","triangleRight","lozenge","lozengeOutline","hamburger","smiley","mustache","star","play","nodejs","oneSeventh","oneNinth","oneTenth","mainSymbols","fallbackSymbols","TERM","Boolean","WT_SESSION","TERMINUS_SUBLIME","ConEmuTask","TERM_PROGRAM","TERMINAL_EMULATOR","verboseLog","entries","verboseId","icon","color","prefixedLines","addPrefix","writeFileSync","STDERR_FD","addPrefixToLine","identity","getTimestamp","ICONS","date","Date","padField","getHours","getMinutes","getSeconds","getMilliseconds","field","padding","padStart","pipedCommand","output","success","getStartTime","hrtime","bigint","getDurationMs","startTime","Number","escapeLines","lines","stripVTControlCharacters","escapeControlCharacters","replaceAll","SPECIAL_CHAR_REGEXP","character","escapeControlCharacter","commonEscape","COMMON_ESCAPES","codepoint","codePointAt","codepointHex","ASTRAL_START","NO_ESCAPE_REGEXP","isStandardStream","stream","STANDARD_STREAMS","STANDARD_STREAMS_ALIASES","getStreamName","fdNumber","normalizeFdSpecificOption","optionName","optionBaseArray","from","getStdioLength","optionArray","normalizeFdSpecificValue","addDefaultValue","stdio","Math","max","optionValue","normalizeOptionObject","fill","fdName","sort","compareFdName","parseFdName","fdNameA","fdNameB","getFdNameOrder","parseFd","regexpResult","FD_REGEXP","exec","DEFAULT_OPTIONS","maxBuffer","stripFinalNewline","FD_SPECIFIC_OPTIONS","handleCommand","escapedCommand","fileAndArguments","fileAndArgument","quoteString","escapedArgument","joinCommand","verboseInfo","verboseItem","allowedValues","allowedValue","validateVerbose","getVerboseInfo","piped","logCommand","npmRunPathEnv","pathName","pathOption","preferLocal","execPath","addExecPath","cwdString","cwdPath","previous","applyPreferLocal","execPathString","applyExecPath","npmRunPath","DiscardedError","setErrorName","ErrorClass","defineProperty","writable","enumerable","configurable","execaErrorSymbol","isErrorInstance","ExecaError","ExecaSyncError","normalizeSignalArgument","signal","normalizeSignal","signalNameOrInteger","isInteger","normalizeSignalInteger","normalizeSignalName","getAvailableSignals","signalInteger","signalsIntegerToName","get","Map","constants","signals","signalName","getAvailableSignalNames","getAvailableSignalIntegers","values","signalIntegerTwo","subprocessKill","kill","forceKillAfterDelay","killSignal","onInternalError","controller","signalOrError","errorArgument","parseKillArguments","emitKillError","killResult","setKillTimeout","async","shouldForceKill","setTimeout","throwOnTimeout","subprocess","timeout","context","killAfterTimeout","timedOut","TEXT_ENCODINGS","BINARY_ENCODINGS","ENCODINGS","ENCODING_ALIASES","ucs2","serializeEncoding","encoding","getDefaultCwd","message","normalizeOptions","normalizeCwd","processedFile","processedArguments","processedOptions","node","shouldHandleNode","nodePath","nodeOptions","execArgv","filter","nodeOption","startsWith","formerNodePath","normalizedNodePath","resolvedNodePath","newOptions","basename","ipc","handleNodeOption","initialOptions","fdOptions","optionsCopy","normalizeFdSpecificOptions","addDefaultOptions","isFinite","validateTimeout","correctEncoding","lowerEncoding","getCorrectEncoding","correctEncodings","validateEncoding","getEnv","normalizeKillSignal","normalizeForceKillAfterDelay","extendEnv","localDir","localDirectory","cleanup","windowsHide","serialization","envOption","getRealtimeSignal","number","SIGRTMIN","action","description","standard","SIGNALS","forced","getSignals","realtimeSignals","getRealtimeSignals","defaultNumber","constantSignal","supported","getSignalByName","signalsByName","fromEntries","getSignalsByName","findSignalByNumber","signalA","stripFinalNewlineString","ArrayBuffer","isView","BYTES_PER_ELEMENT","stripFinalNewlineBinary","signalsA","SIGRTMAX","getSignalByNumber","getSignalsByNumber","LF","CR","LF_BINARY","subarray","CR_BINARY","isStream","checkOpen","readable","pipe","isWritableStream","write","end","writableObjectMode","destroy","destroyed","isReadableStream","read","readableObjectMode","isDuplexStream","a","c","constructor","t","this","next","done","releaseLock","cancel","n","o","r","return","create","h","preventCancel","getReader","s","getAsyncIterable","nodeImports","on","getStreamIterable","asyncIterator","AbortController","state","handleStreamEnd","chunk","aborted","finished","abort","getStreamContents","init","convertChunk","getSize","truncateChunk","addChunk","getFinalChunk","finalize","POSITIVE_INFINITY","asyncIterable","convertedChunk","getChunkType","appendChunk","appendFinalChunk","normalizedError","bufferedData","chunkSize","newLength","addNewChunk","truncatedChunk","MaxBufferError","contents","typeOfChunk","globalThis","isBuffer","prototypeName","super","getMaxBufferSync","stdoutMaxBuffer","getErrorPrefix","originalError","isMaxBuffer","errorCode","signalDescription","exitCode","isCanceled","streamName","threshold","unit","maxBufferInfo","getMaxBufferInfo","getMaxBufferMessage","serializeMessageItem","messageItem","makeSuccessResult","omitUndefinedProperties","durationMs","failed","isTerminated","stderr","pipedFrom","makeEarlyError","fileDescriptors","isSync","makeError","rawExitCode","rawSignal","timeoutDuration","normalizeExitPayload","originalMessage","shortMessage","prefix","escapedOriginalMessage","cwdStat","isDirectory","fixCwdError","getOriginalMessage","messagePart","serializeMessagePart","createMessages","cause","getFinalError","getErrorProperties","toZeroIfInfinity","prettyMilliseconds","milliseconds","isBigInt","colonNotation","compact","formatSubMilliseconds","separateMilliseconds","unitCount","secondsDecimalDigits","millisecondsDecimalDigits","add","long","short","valueString","isZero","wholeDigits","minLength","repeat","word","count","days","trunc","hours","minutes","seconds","microseconds","nanoseconds","parseNumber","parseBigint","parseMilliseconds","BigInt","millisecondsAndBelow","roundedMilliseconds","round","ceil","millisecondsString","toFixed","parseFloat","secondsFixed","decimalDigits","flooredInterimValue","floor","floorDecimals","secondsString","keepDecimalsOnWholeSeconds","separator","logEarlyResult","logResult","getIcon","logError","logDuration","durationMessage","handleResult","logFinalResult","getStdioItemType","isAsyncGenerator","isSyncGenerator","isUrl","isFilePathObject","isWebStream","isAsyncIterableObject","isIterableObject","getTransformStreamType","transform","isTransformOptions","getTransformObjectType","getDuplexType","getGeneratorObjectType","validateNonGeneratorType","final","objectMode","typeName","checkUndefinedOption","checkBooleanOption","isGenerator","isFilePathString","KNOWN_STDIO_STRINGS","isObject","TRANSFORM_TYPES","FILE_TYPES","SPECIAL_DUPLICATE_TYPES_SYNC","SPECIAL_DUPLICATE_TYPES","FORBID_DUPLICATE_TYPES","TYPE_TO_MESSAGE","generator","asyncGenerator","fileUrl","fileNumber","webStream","nodeStream","webTransform","duplex","native","iterable","getTransformObjectModes","newTransforms","direction","getOutputObjectModes","getInputObjectModes","getTransforms","stdioItems","transforms","type","stdioItem","normalizeTransform","sortTransforms","normalizeDuplex","normalizeTransformStream","normalizeGenerator","binaryOption","preserveNewlines","KNOWN_DIRECTIONS","anyDirection","alwaysInput","guessStreamDirection","standardStreamDirection","getStandardStreamDirection","hasAlias","alias","stdioOption","item","isOutputPipeOnly","every","getToStream","destination","to","isWritable","SUBPROCESS_OPTIONS","getFdNumber","destinationStream","getInvalidStdioOptionMessage","getFromStream","source","sourceStream","WeakMap","parseFdNumber","validateFdNumber","validOptions","defaultValue","getOptionName","fileDescriptor","getUsedDescriptor","getInvalidStdioOption","serializeOptionValue","stdin","usedDescriptor","getTargetFd","targetFdNumber","getTargetFdNumber","readFileSync","standardStreamIndex","getStandardStream","standardStream","handleInputOptions","inputFile","handleInputOption","handleInputFileOption","getInputType","getInputFileType","getDuplicateStreamInstance","otherStdioItems","duplicateStdioItems","hasSameValue","differentStdioItem","throwOnDuplicateStream","secondValue","href","handleStdio","addProperties","stdioArray","_","getStdioArray","normalizeStdioSync","normalizeStdioAsync","normalizeStdioOption","initialFileDescriptors","getFileDescriptor","getFinalFileDescriptors","forwardStdio","initialStdioItems","isStdioArray","initializeStdioItems","directions","getStdioItemDirection","getStreamDirection","targetFd","handleNativeStreamSync","handleNativeStreamAsync","handleNativeStream","normalizedStdioItems","normalizeTransforms","lastTransform","findLast","getFdObjectMode","validateFileObjectMode","stdioItemOne","indexOne","stdioItemTwo","indexTwo","filterDuplicates","initializeStdioItem","validateStdioArray","validateStreams","INVALID_STDIO_ARRAY_OPTIONS","validateFileStdio","protocol","isRegularUrl","isUnknownStdioString","fileStdioItem","getFinalFileDescriptor","cleanupCustomStreams","finalStdioItems","addStreamProperties","duplicateStream","flatMap","getOtherStdioItems","duplicateStdioItem","validateDuplicateTransform","validateDuplicateStreamSync","getDuplicateStream","forbiddenIfSync","throwInvalidSyncValue","addPropertiesSync","stripNewline","getStripFinalNewline","getSplitLinesGenerator","skipped","initializeSplitLines","splitLinesSync","splitLinesItemSync","previousChunks","splitGenerator","bind","linesFinal","start","newlineLength","getNewlineLength","concatString","isWindowsNewline","getAppendNewlineGenerator","appendNewlineGenerator","unixNewline","windowsNewline","concatBytes","linesStringInfo","linesUint8ArrayInfo","newline","firstChunk","secondChunk","getValidateTransformInput","validateStringTransformInput","getValidateTransformReturn","validateObjectTransformReturn","validateStringTransformReturn","validateEmptyReturn","getEncodingTransformGenerator","encodingUint8ArrayGenerator","stringDecoder","StringDecoder","encodingStringGenerator","encodingStringFinal","lastChunk","pushChunks","callbackify","getChunks","getChunksArguments","transformStream","currentIterable","transformChunk","generators","identityGenerator","transformedChunk","finalChunks","generatorFinalChunks","finalChunk","destroyTransform","throw","pushChunksSync","getChunksSync","runTransformSync","chunks","transformChunkSync","finalChunksSync","generatorFinalChunksSync","generatorToStream","addInternalGenerators","transformAsync","finalAsync","transformMethod","finalMethod","destroyMethod","Transform","writableHighWaterMark","getDefaultHighWaterMark","readableHighWaterMark","flush","runGeneratorsSync","isInput","reversedGenerators","addInputOptionSync","allStdioItems","transformedContents","applySingleInputGeneratorsSync","newContents","validateSerializable","invalidItem","shouldLogOutput","fdUsesVerbose","PIPED_STDIO_VALUES","isPipingStream","_readableState","pipes","logLine","inspect","spacedLines","TAB_SIZE","runOutputGeneratorsSync","serializeChunks","serializedResult","decoder","strings","finalString","uint8ArraysToStrings","joinToString","finalResult","writeToFiles","outputFiles","pathString","appendFileSync","waitForSubprocessExit","once","waitForSuccessfulExit","exitPromise","isSubprocessErrorExit","isFailedExit","getResultError","normalizeSyncOptions","validateSyncOptions","detached","cancelSignal","throwInvalidSyncOption","spawnSubprocessSync","syncResult","runSubprocessSync","resultError","isMaxBufferSync","getExitResultSync","truncatedResult","maxBufferValue","truncateMaxBufferSync","uint8ArrayResult","linesArray","logLinesSync","returnedResult","transformOutputResultSync","transformOutputSync","stdioOutput","getAllSync","getSyncResult","getInputFdNumbers","addInputOptionsSync","normalizedOptions","normalizeSpawnSyncOptions","createDummyStream","PassThrough","Readable","Writable","Duplex","handleDummyPromise","forbiddenIfAsync","fromWeb","addPropertiesAsync","createReadStream","createWriteStream","mergeStreams","streams","validateStream","highWaterMark","getHighWaterMark","passThroughStream","MergedStream","highWaterMarks","onMergedStreamFinished","streamPromise","endWhenStreamsDone","ended","onFinished","unpipeEvent","remove","delete","unpipe","updateMaxListeners","PASSTHROUGH_LISTENERS_COUNT","race","onMergedStreamEnd","onInputStreamsUnpipe","errorOrAbortStream","unpipedStream","PASSTHROUGH_LISTENERS_PER_STREAM","afterMergedStreamFinished","onInputStreamEnd","onInputStreamUnpipe","size","abortStream","endStream","isAbortError","errorStream","noop","increment","maxListeners","getMaxListeners","setMaxListeners","incrementMaxListeners","eventEmitter","maxListenersIncrement","addAbortListener","pipeStreams","onSourceFinish","onDestinationFinish","endDestinationStream","abortSourceStream","pipeTransform","streamProperty","SUBPROCESS_STREAM_PROPERTIES","pipeStdioItem","pipeGroups","setStandardStreamMaxListeners","inputStream","outputStream","outputStreams","MAX_LISTENERS_INCREMENT","processOk","removeListener","reallyExit","listeners","pid","kExitEmitter","for","ObjectDefineProperty","Emitter","emitted","afterExit","exit","id","random","ev","fn","list","splice","ret","SignalExitBase","onExit","load","unload","handler","sig","__signal_exit_emitter__","opts","alwaysLast","forEach","listener","og","getDestination","boundOptions","createNested","firstArgument","pipeArguments","mapDestinationArguments","pipeOptions","createNonCommandError","sourceOptions","PIPE_COMMAND_MESSAGE","waitForBothSubprocesses","sourceStatus","reason","sourceReason","sourceResult","destinationStatus","destinationReason","destinationResult","subprocessPromises","MERGED_STREAMS","unpipeOnAbort","unpipeSignal","unpipeContext","unpipeOnSignalAbort","mergedStream","pipeToSubprocess","sourceInfo","normalizedInfo","sourcePromise","destinationError","getDestinationStream","sourceError","getSourceStream","normalizePipeArguments","promise","handlePipePromise","getSubprocessPromises","getPipeArgumentsError","handlePipeArgumentsError","maxListenersController","pipeMoreSubprocessStream","pipeFirstSubprocessStream","cleanupMergedStreamsMap","pipeSubprocessStream","allSettled","getContentsProperty","throwObjectStream","getLengthProperty","arrayMethods","arrayBuffer","dataView","typedArray","others","useUint8Array","useUint8ArrayWithOffset","getNewContentsLength","SCALE_FACTOR","log","hasArrayBufferResize","arrayBufferMethods","previousLength","maxByteLength","resize","resizeArrayBuffer","resizeArrayBufferSlow","useTextDecoder","stringMethods","iterateOnSubprocessStream","subprocessStdout","shouldEncode","stopReadingOnExit","iterateOnStream","shouldSplit","iterateForResult","onStreamEnd","allMixed","stopReadingOnStreamEnd","onStdoutChunk","HIGH_WATER_MARK","highWatermark","iterateOnData","DEFAULT_OBJECT_HIGH_WATER_MARK","getGenerators","getStreamOutput","streamInfo","linesIterable","logLines","resumeStream","stripFinalNewlineValue","setImmediate","readableFlowing","resume","getStreamAsArray","getStreamAsArrayBuffer","handleBufferedData","getMaxBufferUnit","handleMaxBuffer","getBufferedData","isArrayBuffer","waitForStream","isSameDirection","stopOnExit","handleStdinDestroy","abortController","stdinCleanedUp","handleStreamError","originalStreams","originalStdin","spyOnStdinDestroy","subprocessStdin","_destroy","destroyArguments","setStdinCleanedUp","signalCode","shouldIgnoreStreamError","propagating","isStreamEpipe","isStreamAbort","isInputFileDescriptor","waitForSubprocessStream","getAllStream","bufferStdout","bufferStderr","getAllMixed","waitForOriginalStreams","waitForCustomStreamsEnd","throwOnSubprocessError","createDeferred","methods","addConcurrentStream","concurrentStreams","waitName","weakMap","promises","waitForConcurrentStreams","isSubprocessExit","safeWaitForSubprocessStdin","waitForSubprocessStdin","waitForSubprocessStdout","waitForSubprocess","destroyOtherStream","isOpen","createReadable","waitReadableDestroy","getSubprocessStdout","readableEncoding","getReadableOptions","onStdoutDataDone","getReadableMethods","onReadableDestroy","onStdoutFinished","onStdoutData","onRead","destroyOtherReadable","createWritable","waitWritableFinal","waitWritableDestroy","getSubprocessStdin","getWritableMethods","onWritableDestroy","onStdinFinished","onWrite","onWritableFinal","safeWaitForSubprocessStdout","destroyOtherWritable","createDuplex","onDuplexDestroy","createIterable","iterateOnStdoutData","addConvertedStreams","readableDestroy","writableFinal","writableDestroy","nativePromisePrototype","descriptors","property","Reflect","getOwnPropertyDescriptor","handleAsyncArguments","handleAsyncOptions","handleStdioAsync","spawnSubprocessAsync","extraStdio","createDummyStreams","earlyError","handleEarlyError","inputStreams","pipeOutputAsync","removeExitHandler","cleanupOnExit","makeAllStream","handlePromise","errorInfo","stdioResults","allResult","spawnPayload","exitPayload","waitForExit","stdioPromises","waitForStdioStreams","allPromise","waitForAllStream","originalPromises","customStreamsEndPromises","stdioPromise","waitForSubprocessResult","stdioResult","getAsyncResult","mergeOptions","mergeOption","boundOptionValue","DEEP_OPTIONS","createExeca","mapArguments","deepOptions","setBoundExeca","boundExeca","execaArguments","callBoundExeca","nextArguments","parseArguments","syncOptions","handleStdioSync","handleSyncArguments","execaCoreSync","descriptor","mergePromise","execaCoreAsync","callArguments","parseTemplates","initialFile","initialArguments","mergedOptions","parseCommand","unusedArguments","token","trim","SPACES_REGEXP","previousToken","endsWith","mapScriptSync","getScriptOptions","getScriptStdinOption","execa"],"sourceRoot":""}